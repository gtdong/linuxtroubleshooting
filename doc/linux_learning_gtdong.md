# Linux学习小记
前言:这是小编在学习linux时总结的笔记和相关心得，欢迎与我交流。
                             
## 目录
* [第一章: 计算机基础](#计算机基础)
  * [一、Linux操作系统与云计算](#Linux操作系统与云计算)
  * [二、计算机基础知识](#计算机基础知识)

## 计算机基础

### Linux操作系统和云计算

#### 1.windows系统和linux系统对比

Windows：在个人用户中使用率高于95%   
Linux  ：服务器中的使用率在80%以上，Windows在服务器中的使用率为15-16%

Linux的特点：免费、开源(源程序是开放的)、稳定安全   
Unix的特点 ：行业占比只有2-3%，收费  
            稳定性、安全性好于Linux  
            使用范围：国企、银行

#### 2.操作系统的发展

服务器：  
手机操作系统： Android：  基于  Linux
              IOS：      基于  Unix
              Win phone

#### 3.云计算

云计算定义 ：云计算是一种按使用量付费的模式，这种模式提供可用的、便捷的、按需的网络访问，进入可配置的计算资源共享池（资源包括网络、服务器、存储、应用软件服务），这些资源能够被快速提供，只需投入很少的管理工作，或与服务器供应商进行很少的交互。  

云计算：在Windows操作系统中安装虚拟化操作软件（虚拟化服务），通过虚拟化服务实现云计算服务和功能  
超级计算机（云）：在计算机上安装Linux系统，在windows系统上安装虚拟化软件，把所有计算机的性能利用虚拟化技术连接起来形成一个超级计算机，也就是云。理论上，存储空间理论上是无限的，运算性能理论上也是无限的。  
特点：  优势:性能好、低廉、方便  劣势：所有的数据都放在别人的服务器上

云计算（公有云）核心技术由亚马逊开发  
                        国内：阿里

#### 4.公有云与似有云

公有云: 面对中小型企业和个人用
私有云: 面对大型企业和公司

#### 5.云计算三种服务  

IaaS: 基础设施即服   
PaaS: 平台即服务  
SaaS: 软件即服务

#### 6.集群

负载均衡：压力负担  
高可用：数据备份


#### 7.计算机的三个时代

计算机时代（计算机的出现60年代）  
互联网时代   
云计算

### 计算机基础知识
1.计算机存储单位：
比特位        bit          存储方式   0  1（二进制）
字节：     1Byte = 8bit
           1KB   =1024Byte
           1MB =1024KB
           1GB = 1024MB
           1TB = 1024GB
           1EB = 1024TB
           1PB = 1024EB
           1ZB = 1024PB
2.
英文编码：ASCII码
简体中文：gb2312
繁体中文：big5       现在使用的：UTF-8
3.
计算机经历的四个时代
第一代：（1946年-1956年） 电子管计算机时代
第二代 （1958年-1964年） 晶体管计算机时代
第三代（1964年-1972年）  集成电路计算机时代
第四代(1972年至今     大规模、超大规模计算机时代
5.摩尔定律：每18个月，集成电路的密度会增加1倍（每18个月计算机的性能会增加1倍）
I5: 双核  4线成
三代I7  四核 8线成
四代I7  六核12线成


CPU：中央处理器，电脑的大脑，功能：负责算术和逻辑运算
分为：针脚式和触点式
      触点式易于安装，但传输速度小于针脚式

6.常见插槽：
 
 PCI :66MB/s      外接声卡、 网卡（基本淘汰，现在的网卡、声卡基本上都在主板上集成）
     IDE: 133MB/s      光驱      和 老式硬盘
  SATA：500MB/s     硬盘   （固态硬盘速度基本与SATA槽匹配）
     PCI-E:1000MB/s     显卡（目前家用主板中速度最快的槽）
DDR4: 3000MB/S    内存
CPU速度：2GHz*8Byte*8
网速: 100Mbps = 100M  bit/s/8

7.CPU存储数据的方式：分级存储   
FSB：   前段总线频率   北桥和南桥通信的频率

CPU散热分为  风冷散热和水冷散
8.老式硬盘的对接方式：一块标准的主板有两块IDE槽，一块槽可以接两块盘








Primary slave   primary master   secondary master
Secondary  salave




9.硬件挑选：   前提条件 ：不会上当受骗

1.CPU
1）芯片品牌    Intel  AMD
2）系列  i3  i5   i7（i3 和i5性能差距不大）
3）代数  3代  4代  （i7三代2500左右）
4）主频   价格允许选主频最高的
2.主板
1）芯片系列  Intel  AMD
2）品牌  华硕 技嘉 微星   华擎
3）价格
3.内存
1）代数    3     4    DDR4代内存，需要四代主板支持
2）大小     16MB好于8MB，
3）主频  选高的
4）价格

升级电脑主要升级硬盘
4.显卡
1）芯片品牌  NVIDIA   AMD
2）芯片系列    1050  1060  1070  1080  1080TI（正常1060 ）
3）价格

4.硬盘
1）芯片类型  固态  机械   固态价格高于机械
2）大小
3）品牌（不需要）





2017.6.23
BIOS的设置与分区
1.BIOS（Basic Input/Output System）：基本输入/输出系统
CMOS：互补金属氧化物半导体存储器
      功能:保存当前系统的硬件配置和用户对某些参数的设定
区别：BIOS是软件（操作系统）  CMOS是硬件

CMOS设置
通常按Del或F2进行设置（台式机），笔记本：F2
Windows密码破译：需要一个第三方工具（U盘、光驱）修改系统文件

2.磁盘分区
MBR分区表：最大支持2.1TB硬盘，最多支持4个分区
GPT分区表：（全局唯一标示分区表）：GPT支持9.4ZB硬盘
理论上支持的分区数没有限制：但Windows限制128个分区
MBR分区类型
主分区：最多只能有4个
扩展分区：（突破4个分区的限制）
最多只能有1个有4个
主分区加扩展分区最多有4个
不能写入数据，只能包含逻辑分区（扩展分区理论上可以分10 个以上逻辑分区，具体分多少和硬盘接触有关）

3.格式化：写入文件系统
文件系统  ： FAT16   FAT32  NTFS （Windows）
             EXT2  EXT3  EXT4    （Linux）






Inode+时间+权限 +大小      INode：I节点 ：128B








格式化：把一个分区分成两部分——上部分放索引，下部分放文件——查索引——判断权限——找位置

ISA防火墙  ：界面漂亮、配置简单、逻辑清晰

4.Windows安装步骤
1)拔网线（机房容易中毒）
2)安装Windows系统
3)安装驱动（光盘安装、官网下载驱动）
4)安装杀毒软件和防火墙
5)插入网线
6)更新（Windows补丁、病毒库、防火墙）
7)安装常用工具软件
8)服务器基本优化

5.Windows安装方法
1)光盘安装
2)U盘安装
3)磁盘对考              前提：光盘、U盘启动时（不能在开机的状态进行 ）        需要使用第三方工具（刻录工具）：Ghost
                             在服务器上不稳定
Linux刻录工具：dd命令
4)网络批量安装

进行3、4操作的前提：母盘和被刻录盘一致






























2017.6.26
1.虚拟机使用
     内存：    centOS6     最小628MB
     处理器   数量：1    
     硬盘：可随时添加
     光驱：  设备状态选择已连接

2.网络连接：
连接方式：    是否可以访问真实机       局域网   公网 
桥接             是                     是      是
         优点：限制最少      缺点：  占用真实网段IP
NAT              是                     不能    是
仅主机           是                    不能    不能

3.虚拟机网络连接：桥接设置
①设置为桥接
②桥接有线网卡（编辑—虚拟网络编辑器—桥接到有线网卡）

虚拟机网络连接：NAT连接
①开启VMnet8
②VMnet  会自动分配一个IP网段192.168.254.1
③虚拟机需要和VMnet位于同一个网段
④虚拟机的网关是192.168.254.2

        仅主机
4.Iternet发展史                                 
ARPAnet	TCP/IP

                     NSFnet


                    ANSnet
Iternet成熟的标志：Web的出现（20世纪90年代初）我国  1997年 清华大学

5.互联网的典型应用
1）WWW：万维网
URL：统一资源定位
协议//域名或IP端口/路径/网页文件名
http//www.itxdl.cn：80/aaaaa/index.html

C/S结构（click/serve）
B/S结构（browr/serve）

Internet的顶级域名分为gtld和cctld
域名分级：     IP地址    （DNS服务器  域名解析为IP地址）
.net  .com  .cn         一级域名
   国际域名分配组织定义，不能够随便更改
.ambrother     .sina    二级域名
   个人或组织申请的，二级域名+一级域名必须全球唯一
www                     三级域名
   个人或组织自由定义的

端口：80（服务及应用）

2)FTP文件传输协议     端口：20  21  （可以修改权限）
3)电子邮件
SMTP：简单 邮件传输协议          端口：25    发信
POP3：邮局协议3代                 端口：110    收信 

6.邮件分类：网页邮件     简单  邮件保存在对方服务器.没有实时提醒
            客户端邮件：    邮件可以保存在本地，有实时提醒，需要一定的配置


2017.6.27
互联网的接入方法
1、	拨号网络
优点：
      使用电话线上网（不用重新布线）
缺点：
      慢         56Kps  = 56K bit/s =7KB
      占用电话线
         贵         4+4/小时
   TSDN：专线网络    144kps
   DDN：          最多能接30台

2.ADSL：非对称数字用户环路
优点：使用电话线上网
       语音线路和数字线路分开
       速度较快        8Mbps  20Mbps  （极限速度、已淘汰）
        费用较为便宜
缺点:
     慢拨号网络   动态Ip
动态Ip不可以搭建服务器

3.FTTH      光纤入户
优点：快       费用和ADSL基本一致
缺点：动态IP

4.固定IP上网
优点:快
固定IP地址
没有限速
缺点：贵      4IP+  10-50M
       256Ip  +100M




交换机:用于同一个网段进行通信
路由器：用于不同网段进行通信
      逻辑网段：ip网段   192.168.19.233
      物理网段：有物理分隔

广播域：交换机不会分割广播域，路由器会分割广播域
      例如：病毒在局域网中的传播速度非常快

小区宽带：






互联网的根本目的：实现资源共享、信息传递

计算机网络发展
第一阶段：ARPANET  关键技术：分组交换  30年代
第二阶段：NSFNet   关键技术：TCP/IP   70.-80年代
第三阶段：浏览器Mosai    关键技术 Web技术  90年代

网络协议与标准  

ISO国际标准化组织      （广）
IEEE电气和电子工程学会   （局）
 IEEE802.3   有线局域网标准
IEEE802.11  无线局域网标准

网络拓扑结构
星型拓扑                                    hub：集线器
优点：
易于实现
易于网络扩展
易于故障排查
缺点：
中心节点压力大
组网成本较高







进制转换
十进制：  0 1 2  3  4   5   6   7   8    9   10   11  12  13 14  15  16
二进制：  0 1 10 11 100 101 110 111 1000 1001 1010
十六进制：0 1  2 3 4    5   6   7   8    9     A    B   C   D  E  F  10
十进制转为二进制：  除2取余
173
10101101

二进制转为十进制：  乘2取幂
100111=1*25 +0*24 +0*23 +1*22+1*21+1*21=39

装水桶法：
10000000
1     1     1      1      1         1          1        1   128   64     32     16     8         4          2         1
二进制转十进制
10101101 =128+32+8+4+1=173

十进制转二进制
185-128=57-32=25-16=9-8=1
1    0     1     1   1    0     0     1
十六进制转十进制
E     B
14     11
1110    1011=128+64+32+8+2+1=235

十进制转为16进制
105
0110    1001
6          9     =69+

八进制
0  1   2  3  4  5  6  7  8   9    10
0  1   2  3  4  5  6  7  10  11  12  13
136
010  001  000
2      1    0    =210
八进制转十进制
5    6    7
101   110   111
375







2017.6.28
一、OSI模型和TCP/IP模型
ISO/OSI七层模型（理论模型）
OSI：开放系统互联
IOS：思科交换机和路由器的操作













每层功能：
7、	应用层：
为用户提供服务，给用户一个操作界面
6、	表示层
为数据提供表示、加密、压缩
5、	会话层
确定数据是否需要进行网络传递
4、	传输层
对报文进行分组
提供传输协议的选择：TCP（传输控制协议）：可靠的，面向连接的协议
						（可靠，准确）（慢）
UDP（用户数据报协议）：不可靠的，面向无连接的协议
	（快）（不可靠）
端口封装
差错校验
3、网络层：
IP地址编址：
路由选择
2、数据链路层
MAC地址编址
1、物理层
数据实际传输
电气特性定义

二、注意事项：
1、上三层是为用户提供服务的，下四层负责实际数据传输
2、越是上层，越智能，可以识别所有当前层以下的数据，越贴近用户。
越是下层，越傻瓜，越贴近硬件
3、下四层的传输单位：
传输层：	数据段（报文）
网络层：	数据包（报文分组）
数据链路层：数据帧
物理层：	比特（位）
4、数据发送时，数据从上层向下层传输
数据接收时，数据从下层向上层传输
5、数据不能跨层传递，每层之间通过逻辑的接口传递
6、物理层负责实际数据传递，其它层只是逻辑对应
7、OSI模型只是理论模型，不能对应实际协议或硬件

三、TCP/IP模型对应的协议：
	应用层：
		HTTP：	超文本传输协议		（网站访问web）（Apache、nginx）（IIS）
		FTP:		文件传输协议		（网络文件传输）
		TFTP：	简单文件传输协议	（交换机和路由器系统重装）
		SMTP：	简单邮件传输协议	（发信）
		POP3：	邮局协议3代		（收信）
		SNMP：	简单网络管理协议	（服务器监控）
		DNS：	域名系统			（域名与IP解析）

	传输层：
		TCP：	传输控制协议	（面向连接的、可靠的传输协议）
		UDP：	用户数据报协议	（面向无连接的、不可靠的传输协议）

	网络层协议：
		IP：		网际协议
		ICMP：	互联网控制消息协议		（网络探测，ping）
		IGMP：	互联网组管理协议
		ARP：	地址解析协议			（IP  --  MAC）
		RARP：	反向地址解析协议		（MAC  --  IP）

	数据链路层：

	物理层：
		PPP：	点对点协议
		PPPOE：	点对点拨号协议
四、
泛洪：	是用于交换机解析未知MAC地址的协议

ARP：地址解析协议			IP  --》  MAC
RARP：反向地址解析协议		MAC		--》	IP
ARP协议：是用于电脑之间解析MAC地址的协议

MAC地址：硬件地址

交换机不能分割广播域
路由器会分割广播域




加密：
对称加密：		压缩包加密
非对称钥匙对加

服务器健康原则：	70/90		内存/CPU

广播域：
冲突域：		CSMA/CD			集线器（不会分割冲突域）
								网桥（分割冲突域，不会分割广播域）

交换机：会分割冲突域、不会分割广播域
路由器：即分割冲突域，也分割广播域

















2017.6.29  
                        IP协议
1、IP地址分类

A类：	必须以0开头
00000001.00000000.00000000.00000000		1.0.0.0
01111111.11111111.11111111.11111111		126.255.255.255
	网段数： 2（7）-2  =	126
	主机数： 2（24）-  2

	默认子网掩码：	255.0.0.0

	回环IP：	127.0.0.1		

B类：必须以10开头
10000000.00000000.00000000.00000000		128.0.0.0
10111111.11111111.11111111.11111111		191.255.255.255
	网段数：	2（14） =  16384
	主机数：	2（16） -2  =  65534

	默认子网掩码：	255.255.0.0

C类：必须以110开头
11000000.00000000.00000000.00000000		192.0.0.0
11011111.11111111.11111111.11111111		223.255.255.255
	网段数：	2（21） = 2097152
	主机数：	2（8） -2  =254

	默认子网掩码：	255.255.255.0

D类：必须以1110开头			特殊组播IP
11100000.00000000.00000000.00000000		224.0.0.0
11101111.11111111.11111111.11111111		239.255.255.255


E类：必须以1111开头			保留
11110000.00000000.00000000.00000000		240.0.0.0
11111111.11111111.11111111.11111111		255.255.255.255

2、私有IP地址
私有IP地址：
	10.0.0.0			---		10.255.255.255
	172.16.0.0		---		172.31.255.255
	192.168.0.0		---		192.168.255.255

3、网络地址和主机地址：
	A类：	第1个8位是网络地址，后3个8位是主机地址
	B类：	前2个8位是网络地址，后2个8位是主机地址
	C类：	前3个8位是网络地址，后1个8位是主机地址

4、子网掩码
	默认子网掩码：
	子网掩码和IP地址不能单独出现，否则没有意义
	和子网掩码中1对应的IP地址是网络地址，和0对应的IP地址是主机地址










2017.6.30
子网掩码计算公式：
网络地址：把IP地址和子网掩码的二进制，按位进行逻辑与运算
广播地址:有效子网掩码中，有几个0，就把IP地址额后几位换位1
子网个数：有效子网掩码中，有几个1，子网数就是2的几次方 
主机个数：有效子网掩码中，有几个0，主机数就是2的几次方减2

举例：
192.168.1.167      11000000.10101000.00000001.10100111
255.255.255.248    11111111.11111111.11111111.11111000
网络地址：         11000000.10101000.00000001.10100000  192.168.1.160
广播地址：         11000000.10101000.00000001.10100111  192.168.1.167
子网数：2（5）=32
主机数：2（3）-2=6

这是一个广播地址，无法分配

C类IP子网掩码：
子网掩码           子网位数             子网数           主机数
255.255.255.0      /24                    1               256-2
255．255.255.128   /25                    2               128-2
255．255.255.192   /26                    4               64-2
255．255.255.224   /27                    8               32-2
255．255.255.240   /28                    16              16-2
255．255.255.248   /29                    32              8-2
255．255.255.252   /30                    64              4-2
子网划分的意义：合理分配，节省Ip

举的例子为私有IP，私有IP是免费的，所有私有IP不需要换算



2017.7.3

VlSM:可变长子网掩码划分













销售部：192.168.100.0/25     255.255.255.128   126
生产部：192.168.100.128/26   255.255.255.192     62
财务部：192.168.100.192/27   255.255.255.224     30
客服部：192.168.100.224/27   255.255.255.224     30

2.UDP数据格式
0                               15 16                              31
 源端口（16）	目标端口（16）
长度（16）	校验和（16）
                              数据

3.TCP协议数据格式
4.端口数：      6万多个    （足够用，所以常规服务器不会被占用）
  TCP 80  和  UDP 80   是两个不同的端口










5.TCP协议工作机制
SYN：发起连接包    、信包
ACK ：回复连接包   




、














攻击:

       拒绝服务攻击：DOS（不进行第一次握手，发送大量的请求包，耗费大量可享用资源） 
       解决方法：封掉A的IP

       分布式服务攻击：DDOS
           通过软件模拟，随意变换IP,耗费攻击方和被攻击方资源
       解决方法：准备2个IP，当一个ip被攻击，切换另一个IP（12个小时
                 云：   判断一个IP被攻击，自动增加带宽从而 御攻击

6.网络层协议:
     Telnet :   端口：23（网络连接协议    远程连接
     已经禁止使用：原因： 明文传输.   传播的数据时非密的

命令;   netstat   -an   :用于查看本机的端口

这是一个客户端常规命令，服务器端已经不使用

Telnet IP端口   测试对方端口是否可以连接
退出    ctrl  + ]    ---》  quit
SSH    端口    linux  默认远程端口

 


（1	第一次连接  ， 提示下载公钥，必须点确认
（2	同时将自己的公钥传过去
（3	A向B发信 ，将自己的公钥加密发给B，B可以解开
（4	B向发信，同上

SSL：加密套接字协议层
        保证网页传输安全的协议
NFS：Linux之间进行文件共享

7.中继器：信号还原
   没有中继器，网线的理论传距离只有100米

已经被交换机取代
 



 






 


黄色绝缘皮的为单模光纤
红色绝缘皮的为多模光纤

 
 



直通线：用于连接不同种网络设备
交叉线：用于连接同种网络设备
全反线：两头线序相反，用于交换机、路由器的本地连接



















2017.7.4
1.三大数据库
  免费:MySQL  ：Linux
       Oracle  ：Unix          可跨平台安装
       SQLserver：windows

2.域管理：Windows核心管理

日志处理:轮替     日志切割     
（Linux默认不会做日志切割，需要管理员手动完成）

3.



             A                           B




      1           2

如果给局域网中两台交换机接了两根网线，电脑1发送数据，交换机A进行泛洪，数据通过网线发给B，同时B也进行泛洪，将数据发给A，如此进行循环（交换机 在泛洪时，除了接收口，也会向其他接口发送数据 ）  ，知道其中一台交换机崩溃，这种现象叫做网络风暴。
 
4.以太网

 



 
5.
ATM：      异步传输模式                     思科内部使用
后两种已淘汰，不是OSI模型



 


 


5.网关是默认路由 ，只能设一个     

静态路由     ，会指定上网路径，与网关无关，不影响网关生效





 

















2017.7.5                        windows server

1.网络共享文件查看:
\\192.168.19.62
     使用的端口：   tcp：139          445
Udp ：137         138

 

通过网络共享文件时：共享和安全有一个拒绝时，拒绝权限有限

2.密码三原则：
  （1）复杂性
       密码应该大于8位
       使用大写、小写、符号、数字，四种包含三种
       不能使用现有英文单词
  （2）易记忆：使用自己喜欢的句子或话，用符号进行替换
   (3) 时效性：180天换一次

3.服务器中：管理工具》本机安全策略》账户策略》密码策略》密码必须符合复杂性要求需开启

4.服务器中，用户权限划分要明确


2017.7.6
1.NTFS权限划分         本地权限NTFS之后出现
  权限的累加       一个用户既属于users也属于administrator，权限累加
Windows权限放在组上，linux放在用户上）

                    如果有拒接，拒接权限优先

2.权限继承：新建的目录和文件的默认权限来源于上一个子文件的权限

Linux权限来源于Umask

3.磁盘管理：raid卡     raid：磁盘阵列
   基本分区的缺陷：不能在不损失数据的情况下，动态调整分区的大小
   PQMagic（硬盘魔术师）    强制修改

   动态 磁盘管理：所有的动态分区，  都可以在不损失数据的情况下，调整分区的大小
（1）	简单卷：没有实际使用价值， 因为只能在同一块磁盘中扩容
（2）	跨区卷：
      两块或两块以上硬盘
      每块硬盘可以提供不同 大小
      磁盘动态扩容
      不具备磁盘容错功能
（3）	带区卷：（raid0）                                  raid 1 0
         两块或两块以上硬盘组成                        0
         每块硬盘的大小相同
         读写速度最快的分区方法                     1     1
         损失几率最大
（4）	镜像卷：  Raid 1
只能由两块硬盘组成
每块硬盘的大小必须一致
使用一块硬盘作为数据备份  （磁盘容错功能）           (最少四块盘)
磁盘空间只有磁盘总数的50%
（5）	Raid  5
由三块或三块以上硬盘
每块盘大小一致                    
拥有磁盘容错功能
磁盘利用空间是n-1块盘

软raid修复前提：Windows能正常开机
任何一块盘损坏，Windows打不开 ，无法修复
实际情况软raid无使用价值
实际情况用硬raid卡

服务器中集成了raid了，硬盘坏了，需要通过raid卡把盘删了，才能把新的盘插进去

4.DHCP    动态主机管理协议    （安全、简单、可靠）
         功能：用于给客户机分配IP地址
优点：减少管理员的工作
      避免输入错误的可能
      避免IP冲突
      提高了IP地址的利用率
      方便客户端的配置
缺点：
      使用广播获取服务器Ip，不能跨网段（交换机不会分割广播域，路由器会分割广播域）
      广播获取，先到先得，不可控（不会分配正确的网关、子网掩码）


客户端获取DHCP的过程    
1、客服端通过广播发送    DHCPdiscovery包，寻找DHCP服务器数据包            源IP：0.0.0.0    目的地址：255.255.255.255            无响应：等待1秒，发送第二次。等待9秒，发送第三次。13。16.            有相应：    
2、服务器提供地址信息    DHCPoffer包            用客户端MAC地址回应            数据包中包含IP地址、租约信息等    
3、客户端接受并广播            发送    DHCPrequest广播包，告知网络中所有DHCP主机            发送arp包，检查IP是否可用，若被占用，则拒绝服务器offer包，重新discovery   
4、服务器确认            收到客户端发送的request包后，向客户端发送DHCPPack包，包含IP等网络参数    
5、客户端确认            收到DHCPPack包后，按照内容配置网卡    
6、客户端重新登录            发送request包，请求之前使用过的IP地址    
7、服务器确认            如果可用，服务器则分配DHCPPack包确认信息            如果不可用，服务器分配DHCPack包，告知客户端重新discovery    
8、更新租约            客户端租约期限一半时，向服务器发送DHCPPrequest包，要求更新租约            无回应则，再到一半时（75%），重新发送，依然得不到回应。则租约使用至到期，重新DHCPdiscovery





2017.7.7
1.DNS(Domain  Name System  域名系统)
早期使用host文件解析域名	
位置(c盘/Windows/system32/drivers/etc/hosts
Linux    /etc/hosts

域名分级
根域名：  .    (13个)
FQDN：完全合格域名
      www.itxdl.cn

2.DNS的查询过程


 

1.寻找首选DNS服务器（如果DNS服务器解析过www.sohu.com的IP，IP将会被记录在DNS的缓存里
2.向跟服务器发送请求（询问是否知道www.sohu.com的IP）
3.回应首选DNS服务器，并将.com的IP发给他
4.向“com”DNS发送请求
5. 回应首选DNS服务器，并将sohu的IP发给他
6.向“sohu”DNS发送请求6
7.回应，将sohu.com的IP地址发送给首选DNS服务器
8.将www.sohu.com的Ip地址发给PC
9.PC通过Ip地址访问WEB服务器
10.WEB服务器将内容发给PC

3.
（1）缓存：主要应用于数据库的提升，是一个单独的程序，需要单独搭建

       DNS对服务器的压力也比较大：如果一个IP地址曾经被解析过，Ip地址会存在缓存里，再次访问，将会直接从缓存里调用IP地址，减小了对服务器的压力
DNS缓存保存时间越长，搜索压力越大，普通网站的Ip在DNS上的 缓存时间为10-15分钟（sohu默认3天）

（2）在PC上，用虚拟机搭建一个DNS，虚拟机可以上网，PC可以通过DNS访问公网Ip
（3）
 
（4）从查询内容分类
正向查询：由域名查找IP地址
反向查询：由IP查找域名
（5）资源记录类型












 

（4）域：Domain（域名，当前域的名称）

区域：Zone （保存数据的目录）

                        正向区域
                        反向区域


（5）解析优先级
  一级：本机hosts文件，如果本机hosts文件可以解析，不会去找DNS服务器
 二级：首先DNS手工配置的解析
三级：前两级都没有，才去找根域







2017.7.10             
1.www服务软件
Apache
IIS（Internet Information Services）可以在个人版安装

静态网站:没有交互，没有php语言，或者没有数据库的网站
动态网站:有交互，有数据库的网站

2.三大操作系统出现时间
   Unix       1969
   DOS        1972年左右
   Linux      1991年     发明者  李纳斯.托瓦兹  （Linus.torvalds）
 


 
3.常见的Linux                                                                                                                                                                                                                                                                      
版本分类

   内核版：             主  次  末版本
www.kernel.org    2.  6.  32     Redhat6
                        3.10.x         Redhat7
   发行版：
   RedHat 
      企业版
         RHEL（Redhat Enterprise Linux）   6
      个人版
         Fedora
   Debian

 

4.开源软件
 
Apache           Web服务器
Nginx            web服务器
MySQL            数据库（SQLserver oracle）
PHP              脚本语言
Samba            Windows和linux之间的内网文件服务器
MongoDB          NoSQL数据库               redis
Python          脚本语言
Ruby            脚本语言
Sphinx          中文分词
SQL             机构化查询语言




































7.11
                             Linux安装方法
1.Windows分区步骤：
1.	分区
2.	格式化                               实际硬盘中，先把硬盘分
3.	盘服                            几个大的卷组，每个卷组大概
                                          100MB左右，然后再分INode和block
Linux分区步骤：
1.	分区
2.	格式化
3.	硬件设备文件名
4.	挂载点  使用已经建立的空目录
作为挂载点（任何目录都可以除了/etc 
/bin/ /lib）
挂载过程：Windows  盘符 C：\  D:\ E:\
Linux中.硬件文件名-----指定挂载目录（盘符） 挂载
         /dev/sda1-------/boot




1)	注意事项
注意： Linux下所有内容都是文件，包括硬件
       Linux严格区分大小写
       Linux不可以扩展名区分文件类型，而是靠权限。但是有特例，如压缩文件，rpm软件包文件
       所有的可存储设备都必须挂载使用，包括硬盘






2.分区设备文件名
设备文件名：
      /dev/hda1(IDE硬盘接口)
      /dev/sda1(SCSI硬盘接口、SATA硬盘接口)

  
IDE                                SCSI

/dev/hda1   hd  IDE硬盘    ，sd  SCSI，SATA硬盘   a：第一块硬盘  1：第一个分区
/dev/sda1 
/dev/sda5  第3块SATA硬盘，第一个
           逻辑分区





1 2 3 4这四个分区号只能给主分区和扩展分区，逻辑分区只要用必须从5开始

3.linux中
硬盘文件名------------指定挂载目录（盘符）    挂载
/dev/sdal-------------/boot

4.linux分区
1）、必须分区
  /      根分区必须单独分   越大越好
 swap分区    交换分区
             如果真实内存小于4个G，swap为内存的两倍
             如果真实内存大于4个G，swap和内存一致
             实验环境          不大于2G
2）常用分区
   /boot   启动分区   200MB    /dev/sda1
   /home
   /www
3)密码原则
 

在Linux中看，根目录是最高级目录，下面为一级子目录，再下一级为二级子目录，
从硬盘（disc）上来看，如果给根目录一个单独的分区，它会有自己的存储空间；如果给boot和home单独分区，他们也有自己的存储空间
如果往单独分区的目录下写数据，数据是写在自己的盘中；如果往没有单独分区的子目录（列入、etc）写入数据，它会和根目录共用存储空间

LVm    可支持分区调整

 



 

anaconda-ks.cfg    预留做网络批量安装的模板
Kickstart  网络批量安装的名称


5.Linux  IP地址配置
1.	setup
2.	onboot=yes
3.	service   network restart
4.	以下步骤只针对虚拟机
   虚拟机设置为桥接
5.	桥接到有线网卡
6.	UUID （唯一识别符） （只针对复制镜像冲突）
vi /etc/sysconfig/network-script/ifcfg-eth0
删除mac地址行

rm –rf  /etc/udev/rules.d/70-persistent-net.rules

删除mac地址和UUID绑定文件

Reboot

   重启Linux


 
 
每一个网卡都会有一个唯一的UUID号，不可能重叠，无论是快照、克隆、复制镜像都会导致UUID一样



















            






                                                                                                                                                                                                                                                                                                                                                                                                                                                               
7.12
1.学习Linux的注意事项
1. 1
Linux严格区分大小写
Linux中所有内容以文件形式保存，包括硬件
   硬盘文件是/dev/sd[a-p]
   光盘文件是/dev/sr0

1.2
Linux不靠扩展名区分文件类型，以下是特殊类型，
压缩包：“*.bz2” “*.gz”  “tar.bz2” “*.tgz”
二进制软件包“.rpm”

Linux的不同压缩包解压方式不一样，起扩展名是便于管理员操作
压缩包和二进制软件包必须写扩展名，因为这些包是不能直接用文本打开的，他们通过编译压缩，是乱码的、二进制的 ，不写清楚扩展名无法操作

网页文件：“*.html”、 “*.php”     程序要求
脚本文件：“*.sh”                  程序要求
配置文件：“*.conf”                服务强制要求

1.3
（1）Linux中所有存储设备都必须挂载后才能使用，包括光盘和U盘
（2）只有硬盘可以做自动挂载 光盘和U盘不能做自动挂载
（3）Windows中的程序不能直接在linux上安装和使用（windows软件类型.exe、.msi、.bat）


Linux中所有设备使用时都需要挂载，使用完成必须要卸载（例如光盘使用完不卸载，光盘弹不出
1.4Linux常见目录
目录名	目录作用
/bin/	存放系统命令的目录，普通用户和超级用户都可以执行。不
	过放在/bin 下的命令在单用户模式下也可以执行
	
/sbin/	保存和系统环境设置相关的命令，只有超级用户可以使用这
	
 
	些命令进行系统环境设置，但是有些命令可以允许普通用户
	查看
	
/usr/bin/	存放系统命令的目录，普通用户和超级用户都可以执行。这
	些命令和系统启动无关，在单用户模式下不能执行
	
/usr/sbin/	存放根文件系统不必要的系统管理命令，例如多数服务程序。
	只有超级用户可以使用。大家其实可以注意到Linux的系统，
	在所有“sbin”目录中保存的命令只有超级用户可以使用，
	“bin”目录中保存的命令所有用户都可以使用
	
/boot/	系统启动目录，保存系统启动相关的文件，如内核文件和启
	动引导程序（grub）文件等
	
/dev/	设备文件保存位置。我们已经说过Linux中所有内容以文件形
	式保存，包括硬件。那么这个目录就是用来保存所有硬件设
	备文件的
	
/etc/	配置文件保存位置。系统内所有采用默认安装方式（rpm安
	装）的服务的配置文件全部都保存在这个目录当中，如用户
	账户和密码，服务的启动脚本，常用服务的配置文件等
	
/home/	普通用户的家目录。建立每个用户时，每个用户要有一个默
	认登录位置,这个位置就是这个用户的家目录，所有普通用户
	的家目录就是在/home下建立一个和用户名相同的目录。如
	用户user1的家目录就是/home/user1
	
/lib/	系统调用的函数库保存位置(.so结尾
	
/lost+found/	当系统意外崩溃或机器意外关机，而产生一些文件碎片放在
（分区区分标志）	这里。当系统启动的过程中fsck工具会检查这里，并修复已
	经损坏的文件系统。这个目录只在每个分区中出现，例如
	/lost+found就是根分区的备份恢复目录，
	/boot/lost+found就是/boot分区的备份恢复目录
	
/media/	挂载目录。系统建议是用来挂载媒体设备的，例如软盘和光
	盘
	
/mnt/	挂载目录，早期Linux中只有这一个挂载目录，并没有细分。
	现在这个目录系统建议挂载额外设备，如U盘，移动硬盘和
	其他操作系统的分区
	
 
/misc/	挂载目录。系统建议用来挂载NFS服务的共享目录。我们在
	刚刚已经解释了挂载，童鞋们应该知道只要是一个已经建立
	的空目录就可以作为挂载点。那么系统虽然准备了三个默认
	挂载目录/media、/mnt、/misc，但是到底在哪个目录中挂
	载什么设备都可以由管理员自己决定。例如我接触Linux的时
	候，默认挂载目录只有/mnt一个，所以养成了在/mnt下建
	立不同目录挂载不同设备的习惯。如/mnt/cdrom挂载光盘，
	/mnt/usb挂载U盘，这都是可以的
	
/opt/	第三方安装的软件保存位置。这个目录就是放置和安装其他
	软件的位置，我手工安装的源码包软件都可以安装到这个目
	录当中。不过我还是更加习惯把软件放置到/usr/local/目录
	当中，也就是说/usr/local/目录也可以用来安装软件
	
/proc/	虚拟文件系统，该目录中的数据并不保存到硬盘当中，而是
	保存到内存当中。主要保存系统的内核，进程，外部设备状
	态和网络状态灯。如/proc/cpuinfo 是保存 CPU 信息的
	/proc/devices 是保存设备驱动的列表的，
	/proc/filesystems 是保存文件系统列表的，/proc/net/是保
	存网络协议信息的
	
/sys/	虚拟文件系统。和/proc 目录相似，都是保存在内存当中的，
	主要是保存于内核相关信息的
	
/root/	超级用户的家目录。普通用户家目录在“/home”下，超级
	用于家目录直接在“/”下
	
/srv/	服务数据目录。一些系统服务启动之后，可以在这个目录中
	保存所需要的数据
	
/tmp/	临时目录。系统存放临时文件的目录，该目录下所有用户都
	可以访问和写入。我们建议此目录中不能保存重要数据，最
	好每次开机都把该目录清空
	
/usr/	系统软件资源目录。注意usr不是use的缩写，而是“Unix
	Softwre Resource”的缩写，所以不是存放用户数据，而是
	存放系统软件资源的目录。系统中安装的软件大多数保存在
	这里，所以除了/usr/bin/和/usr/sbin/这两个目录，我在介
	
 
	绍几个/usr/下的二级目录
	
/usr/lib/	应用程序调用的函数库保存位置
	
/usr/X11R6/	图形界面系统保存位置
	
/usr/local/	手工安装的软件保存位置。我们一般建议把自己安装的源码
	包软件安装在这个位置当中
	
/usr/share/	应用程序的资源文件保存位置。如帮助文档，说明文档和字
	体目录。
	
/usr/src/	源码包保存位置。我们手工下载的源码包和内核源码包都可
	以保存到这里。不过我更加习惯把手工下载的源码包保存到
	/usr/local/src/目录中，内核源码保存到/usr/src/linux/目录
	中
	
/var/	动态数据保存位置。主要保存缓存、日志以及软件运行所产
	生的文件
	
/var/www/	RPM包安装的apache的网页主目录
	
/var/lib/	程序运行中需要调用或改变的数据保存位置。如Mysql的数
	据库保存在/var/lib/mysql中 
	
/var/log/	系统日志保存位置
	
/var/run/	一些服务和程序运行后，他们的PID（进程ID）会保存在这
	里
	
/var/spool/	放置队列数据的目录。就是排队等待其他程序使用的数据。
	比如邮件队列和打印队列
	
/var/spool/mail/	新收到的邮件队列保存位置。系统新收到的邮件会保存在这
	个目录当中
	
/var/spool/crom/	系统的定时任务队列保存位置。系统中的定时任务会保存到
	这里

2.服务器使用注意事项
*远程服务器不允许关机，只能重启（服务器在远程）
*重启时应该关闭服务（服务器最容易损坏的是硬盘，关闭服务是为了减少访问量，减少对服务器的压力）
*不要在服务器访问高峰执行高负载命令
*远程配置防火墙不要把自己踢出服务器（所有修复的前提是拿到本机）五分钟定时清空防火墙
*指定合理的密码规范并定期更新
*合理分配权限
*定期备份重要数据和日志

3.
3.1Linux 文件的命名规则
 A. 除了 / 之外，所有的字符都合法，但有些字符最好不用，如空格符、制
表符、退	格符和字符 @ # $ & ( ) - 等；
B.避免使用 . 作为普通文件名的第一个字符；
C.大小写敏感，严格区分大小写（包括文件命名、命令、命令选项、用户名等）

3.2Linux 命令格式		
命令格式 ：命令	-选项	参数（操作对象）
例 ：ls	-la	/etc
选项   用于调整命令功能
参数    命令的操作对象

说明：		
1）当有多个选项时，可以写在一起。
2）两个特殊的目录 . 和 .. ，分别代表当前目录和当前目录的父目录。
3）个别命令不遵循此格式

3.3Linux 命令提示符 [root@localhost /]#

[当前登录用户@当前主机名 当前所在目录的最后一个目录]#

/root/   超级用户家目录
/home/用户名    普通用户
#提示符
#超级用户
$普通用户

4.权限
-rw------- 1 root root 1190 08-10 23：37 anaconda-ks.cfg
第一项：权限位
第二项：引用计数
第三项： root 属主
第四项： root 属组
第五项：  大小 byte
第六项    最后一次修改时间
第七项    文件名

引用计数：    目录  目录下一级子目录的数量
              文件   硬链接的数量

5.相关命令
ls -a   显示所有文件（包括隐藏文件）
ls –al 以长格式显示所有文件
ls -h   以常用单位显示文件大小
ls -d   只显示目录，不显示目录下的子文件
ls -i    显示文件的inode号
ls -l多的别名 ll













7.13
Linux 常用命令
________________________________________
文件与目录操作命令
操作系统 管理的主要对象 文件和目录 （硬件：CPU 硬盘 光盘 ）
目录操作命令
树状结构
1.切换目录命令 cd 
（1）	命令名称：cd
命令英文原意：change directory
命令所在路径：shell内置命令
执行权限：所有用户
（2）	相对路径：参照当前所在目录，进行查找。一定要先确定所在目录。
root]# cd  ../usr/local/src
绝对路径：cd  /usr/local/src  从根目录开始指定，一级一级开始找。在任何目录下，都能进入指定位置
cd                   切换到家目录
cd  /usr/local/src      绝对路径 切换方式
cd  ~                切换到家目录
cd  -                 回到上一次工作目录
cd  /root              切换到家目录
cd  ../usr/local/src 相对路径切换方式
cd  .. 切换到上一级目录 .. 上一级目录
cd  . 切换到当前目录 . 当前目录 
2.显示当前工作目录 pwd
命令名称:pwd
命令英文愿意：print working directory
命令所在路径：/bin/pwd
执行权限：所有用户
3.建立目录
命令名称：mkdir
命令英文原意：make directories
命令所在路径：/bin/mkdir
执行权限：所有用户

mkdir test 
mkdir -p 11/22/33/44/55 
4.删除目录
rmdir  目录   只能删除
命令英文：remove empty directories
命令所在路径:/bin/rmdir
执行权限：所有用户

  
rmdir test 
rm -rf 11 -r 删除目录 -f 强制
文件操作命令
1.建立空文件 
touch 文件名
命令名称：touch
命令所在路径
执行权限：所有用户
touch test.txt 
touch a.sh 
修改时间
touch install.log 修改为当前时间
touch -t 201701110333 a.sh 修改文件时间
删除命令
rm a.sh 提示是否删除 = rm -i a.sh 
2.
查看文件内容命令
命令名称：cat
命令所在路径：/bin/cat
执行权限：所有用户
cat install.log 查看全部文件内容 
cat -n install.log 查看同时显示行号 （适合查看内容少的文件）
3.命令名称：more
  命令所在路径：/bin/cat
  执行权限：所有用户
more install.log 分页显示文件内容 空格 向下翻页 b 向上 q 退出
4.less
   命令名称：more
   命令所在路径：/bin/more
   执行权限：所有用户
5.head
  命令名称：head
  命令所在路径：/usr/bin/head
  执行权限：所有用户
less install.log 分页显示文件内容 方向键 空格 b q PgUp PgDn 
head install.log 默认显示文件前10行
head -n 20 install.log 查看前20行 head -20 install.log 
6.tail –n 行数 文件名  显示文件尾
       -f    监听文件尾，不退出。适合监听实时文件
名称：tail
命令所在路径：/usr/bin/tail
执行权限：所有用户

tail install.log 默认显示文件后10行
tail -n 20 install.log 查看文件后20行 tail -20 install.log
ls -l > a.sh
tail -f a.sh 动态查看文件内容 （实时查看文件）
ls >> a.sh 
文件和目录都能操作的命令
 1. 
复制
命令名称：cp
英文原意：copy
路径：/bin/copy

cp a.sh b.sh 同一目录复制文件 
cp a.sh test/ 复制文件到目录
cp -r test t1 复制目录 -r
cp -a test t2 复制目录 -a 相当于 -pdr 
2.剪切和改名
命令英文原意：move
路径：/bin/move
执行权限：所有用户


改名 mv a.sh y.sh 
剪切 mv y.sh test 剪切到目录

3.命令解释器    shell    /bin/bash linux标准shell
内部（内置）命令 shell 自带 cd exit (退出系统) = ctrl + d history
外部命令 后期开发 ls rm mkdir 

4.区分命令类型
type cd 
type exit
type history
type mkdir 

5.链接文件    难点
ln 
命令名称：ln
命令英文原意：link
命令所在路径：/bin/ln
执行权限：所有用户

硬链接特征
1.	拥有相同的i节点和存储block块，可以看做是同一个文件
2.	可通过i节点识别
3.	不能跨分区
4.	不能针对目录使用
        硬链接不能链接目录
        硬链接不能跨分区
软连接特征：
     1.类似windows快捷方式
     2.软连接拥有自己的I节点和block块，但是数据块中只保存源文件的文件名和i节点号，并没有实际的文件数据
     3.lrwxrwxrwx   1  软链接
        软链接文件权限都为rwxrwxrwx
     4.修改任意文件，另一个都变
     5.删除原文件，软链接不能使用
硬链接
ln b.sh a.link 
软链接
ln -s b.sh a.lnk
ln -s /root/b.sh /tmp/d.sh 跨目录建立链接文件 （绝对路径）
权限管理
-rw-r--r-- root root  0 08-11 01:45 a.sh
权限位
第一位：  代表文件类型
-	  普通文件
d    目录文件
l    链接文件
b    块设备文件
c    字符设备文件
s    套接字
p    管道

第一位 - 普通文件 
第二三四位 属主(文件/目录所有者) u rw- 6
第五六七位 属组 g r-- 4
第八九十位 其它人 o r-- 4
r 可读 w 可写 x 可执行 - 无权限 
4 2 1 0
777 000
系统默认建立的普通文件的权限 -rw-r--r-- 644
系统默认建立的目录的权限 drwxr-xr-x 755
软链接文件的权限 lrwxrwxrwx 777
修改权限
touch t.sh  
ls -l t.sh 

chmod
命令名称：chmod
命令英文原意： change the permission mode of a file
命令所在路径：/bin/chmod
执行权限；所有用户

chmod u+x t.sh 添加执行权限 给属主 +
ls -l t.sh 
chmod g+x,o+x t.sh 同时给属组和其它人添加执行权限
ls -l t.sh
chmod u-x,g-x,o-x t.sh 去除所有执行权限 - 
chmod  a+x   t.sh     all   全部添加执行权限
chmod  a-x   t.sh       全部去除执行权限
chmod   +x   t.sh       全部添加执行权限
chmod   -x   t.sh       全部去除执行权限
ls  -l   t.sh
chmod u=rwx t.sh 赋予权限的方法 =
ls -l 
chmod u=x t.sh 
ls -l 
chmod u=rwx,g=rwx,o=rwx t.sh 
chmod a=rwx t.sh 全部同时赋值
755 系统默认目录 644 系统默认建立文件 777 软链接文件权限
chmod 755 t.sh
chmod 644 t.sh
chmod 777 t.sh
chmod 000 t.sh
权限意义
对文件的含义 系统默认644 -rw-r--r--
r cat more less head tail
w nano vi echo 
x --------- 
对目录的含义 系统默认755 drwxr-xr-x 
r 查看目录下文件名 ls 
w 对目录里面的文件操作权限命令 touch mkdir rm mv cp 
x cd 进入

权限意义：
权限对文件的意义
r ：读取文件内容  cat more head tail
w：编辑、新增、修改文件内容   vi  echo
   但是不包含删除文件
x：可执行
/tmp/11/22/abc

权限对目录的含义
   r:可以查询目录下的文件名
   w;具有修改目录结构的权限，如新文件和目录，删除此目录下文件和目录
重命名此目录下文件和目录，剪切    touch  rm mv cp
   x：可以进入目录   cd











7.14
4   属主和属组命令 
            chown 
            命令名称：chown 
            命令英文原意：change file ownership 
            命令所在路径：/bin/chown 
            执行权限：所有用户 

            chown  用户名 文件名             改变文件属主 

            chown  user1 aa    user1 必须存在 

            chown  user1:user1 aa  改变属主同时改变属组 

            useradd 用户名        添加用户 
            passwd  用户名            设定用户密码                  10 遍 

            chgrp 属组名 文件名              改变属组 
            命令名称：chgrp 
            命令英文原意：change file group ownership 
            命令所在路径：/bin/chgrp 
            执行权限：所有用户 

        5   文件和目录默认权限 
            umask 
            命令名称：umask 
            命令英文原意：the user file-creation mask 

----------------------- Page 10-----------------------

         命令所在路径：Shell 内置命令 
          执行权限：所有用户 

         0022 

          文件： 666         022     644 
              -wr-wr-wr-       减去  -----w--w-       等于 -wr--r--r- 

              666   033 
              -wr-wr-wr-       减去  -----wx-wx        等于  644 

          目录：777      022        755 

         umask          查看系统umask 值                 -S （大）以字母显示权限 
         umask    0002  临时修改umask 值 

四 帮助命令 
     1   man    命令名              查看命令的帮助 
         命令名称：man 
         命令英文原意：manual 
         命令所在路径：/usr/bin/man 
         执行权限：所有用户 

         man    5  passwd        查看配置文件的帮助 

man   -f  命令  或 whatis          命令 
#查看命令拥有哪个级别的帮助 

man   -k   命令  或 apropos          命令 
#查看和命令相关的所有帮助 

----------------------- Page 11-----------------------

         2   help  内部命令                查看内部命令帮助 
             命令名称：help 
             命令所在路径：Shell 内置命令 
             执行权限：所有用户 

         3   命令 --help             查看命令的常见选项 

         4   info  命令 
             回车：  进入子帮助页面（带有*号标记） 
             u             进入上层页面 
             n             进入下一个帮助小节 
             p             进入上一个帮助小节 
             q             退出 

常用命令（二） 

    一 查找命令 

         1   which   命令名               查找命令的命令，能看到相关别名 
             命令名称：which 
             命令所在路径：/usr/bin/which 
             执行权限：所有用户 

         2   whereis  命令名          查找命令的命令，同时看到帮助文档位置 
             命令名称：whereis 
             命令所在路径：/usr/bin/whereis 
             执行权限：所有用户 

         3   locate    文件名             按照文件名查找               按照数据库查找， 
             命令名称：locate 
             命令所在路径：/usr/bin/locate 
             执行权限：所有用户 

             updatedb         强制更新数据库 

             /var/lib/mlocate          #locate 命令所搜索的后台数据库 

             /etc/updatedb.conf        配置文件，用于定义locate 命令 
PRUNE_BIND_MOUNTS = "yes“ 
#开启搜索限制 
PRUNEFS = 
#搜索时，不搜索的文件系统 
PRUNENAMES = 

----------------------- Page 12-----------------------

#搜索时，不搜索的文件类型 
PRUNEPATHS = 
#搜索时，不搜索的路径 

        4   find            搜索命令 
            命令名称：find 
            命令所在路径：/usr/bin/find 
            执行权限：所有用户 

            按照文件名查找 
            find 查找位置 -name        文件名 
            find / -name  aabbcc           按照文件名查找 

            按照时间查找 
            -ctime          按照文件状态修改时间（天）                  change 
            -mtime          按照文件数据修改时间                     modify 
            -atime          按照访问时间                     access 
            find / -ctime +4 
                       -4 
                       4 

            按照用户 
            -uid 数字         按照用户属主ID 查找文件。 
            -gid 数字         按照属组组ID 查找文件 
            -user 用户名       按照属主用户名查找文件 
            -group 组名       按照属组组名查找文件 
            -nouser     找没有属主的文件 

            find / -nouser 

            按照文件权限 
            -name           按照文件名 
            -size       按照文件大小。+50k：大于50k，-50k：小于50k，50k：等于 
50k 
            find /  -size +50k 
            -type 类型        按照文件类型 。f：普通 d：目录                  l：链接 
            -perm 755       按照权限查找 
            find . -perm  644 

            -inum           按照i 节点             ls  -i 
            find . inum  节点数 

            -iname          按照文件名查找，不区分大小写 

----------------------- Page 13-----------------------

            在查找出的结果中，直接进行命令操作 
            find /var/logs/ -mtime +10 -exec rm -rf {} \; 

            find . -inum 1140247 -exec ls -l {} \; 

            find . -size +5k -a -size 6k 

            还可以使用-ok，格式和-exec  一致，只是在执行-ok 包含的命令时，会提示用 
户是否执行 

        2   grep “字符串” 文件名             查找符合条件的字串行。 
            命令名称：grep 
            命令所在路径：/bin/grep 
            执行权限：所有用户 

            grep -i “root” /etc/passwd 
                -v      反向选择 
                -i      忽略大小写 

            |  管道符 
            cat install.log | grep lib 在显示文件的结果中，grep 搜索含有lib 的行 

            命令1    |  命令2      命令1 的结果，作为命令2            的执行条件 

补充： 
    netstat 查看系统网络状态 
        -t  查看tcp 协议端口 
        -u  查看udp 
        -l  监听 
        -n  以ip 和端口号显示，而不是主机名和协议名 



useradd chaoge 添加用户
passwd chaoge 设置密码
chown chaoge test.txt 修改属主
ll
chown :chaoge test.txt 修改属组
ll
chown chaoge:chaoge t.sh 同时修改属主和属组
ll
chgrp chaoge a.link 修改文件属组
ll
文件和目录默认权限
644 755
umask 查看系统默认权限
umask -S 用户字符显示默认权限
umask 000 
touch mask.t
ll mask.t
umask 011 
touch mask.1
ll mask.1
umask 000
mkdir mask
ls -ld mask
umask 002
mkdir m1
ls -ld m1
umask 022
帮助命令
man ls
man 5 passwd 
man -f reboot
man -k ls
whatis ls
apropos ls
help 查看内置命令帮助
help cd
help exit
help umask 
帮助选项
命令 --help
ls --help 
帮助命令
info ls 
u n p q
常用命令 （二）
查找命令
which ls 查找命令的命令所在的位置 包括命令别名 
which umask 不能查找shell内置命令
which rm 
whereis ls 查看命令所在的位置 同时查看帮助文件的位置
locate 数据库查找功能
locate index.html
locate t.sh 包含相关字符
updatedb 强制更新数据库
find 搜索命令
find 查找路径 -name 文件名 -iname 不区分大小写
find /root -name t.sh
find / -name index.html 全盘查找index.html
stat t.sh 
-ctime -atime -mtime
find / -ctime +4 
find / -ctime -4
find / -ctime 4 
按照用户查找
-uid -gid 
-user -group 
find /root -user chaoge
find / -user chaoge
find /root -group chaoge
find / -group chaoge
find / -nouser 查找无主文件
按照文件大小查找 -size +50k -50k 50k M G
find / -size +50k
find / -size -50k
find / -size 50k
按照文件类型查找
find / -type f d l
按照权限查找 -perm
find / -perm 000 
按照i节点查找 -inum
ls -i 
find / -inum 655674
find /var/log/ -mtime +10 -exec rm -rf {} \;
在/var/log目录下删除10天前修改过的文件
find . -inum 3933535 -exec ls -l {} \;
find . -size +5k -a -size 6k 
查找命令 grep 查找文件内容
grep "root" install.log
grep -n "root" install.log -n 显示行号
grep -in "ROOT" install.log -i 不区分大小写
grep   -v "i686" install.log 反向查找 
管道符 
cat install.log | grep "root"
ls -l /etc | more 
netstat -an | grep ESTABLISHED | wc -l 统计建立的链接数






































2017.7.17
1.※为什么对文件有写入权限，而不能删除文件？
      答：因为文件的block块里存放的是数据内容，而它的名字和i节点浩=号是存放在上一级目录的block块里，只有对上一级目录有w权限，才能操作block块中的内容。

※硬链接
            root           /root/test            tmp








     在/root下创建一个文件test，创建test的硬链接到/tmp/t-hard,/root下的block块放置了test的文件名和i节点，通过i节点找到test的索引，从而访问test的数据
     同理，/tmp下放置了硬链接t-hard和它的i节点，由于硬链接和源文件的i节点一样，所以最终访问的数据和源文件一置
     ※所以源文件和硬链接任何一个改变，另一个也变
     ※因为i节点在不同分区是分别计算的，i节点可能相同，所以不能跨分区创建硬链接
     ※不能对 目录创建硬链接，因为要给目录创建硬链接，其下的子目录子文件等等都要创建硬链接


2.













 ※删除软连接，对源文件没有影响
 ※软连接给最大的权限不影响访问，最终要受到源文件test权限的限制
/tmp/t-hard、 /tmp/t-soft  /root/test 三个文件任意一个修改内容，其他两个内容也变，因它们最终访问的是同一个数据块

3.在目录下无法创建名称与目录同名的文件（无法区分）

4.rm –rf  /tmp/*   删除/tmp目录下的所有内容

5.ln –s /root/anaconda-ks.cfg      /tmp/
   -s   abc      /tmp      报错，不是绝对路径，无法访问数据块

6.修改文件永久权限
vim     /etc/profile                   四大环境变量之一

7.-rw-r—r--.

点“.“是用来限制root用户的

8.find和grep的区别

     find：在系统中查找符合条件的文件名，如果需要匹配，使用通配符。通配符是完全匹配
     grep：在文件当中搜索符合条件的字符串，如果需要匹配，使用正则表达式匹配，正则表达式是包含匹配
     通配符：是用于匹配文件名称的，是完全匹配
  *   任意内容
  ？  任意一个内容
  []  匹配任意一个括号中的内容
  正则表达式：用于匹配字符串，是包含匹配
  *   前一个字符重复0次到任意多次
  ？  前一个字符重复0次或一次
  []  匹配中括号内的任意一个内容

9. -  size 
   ‘b’   512-bytes
    ‘c’  for-bytes
     ‘wrpm’ for two-bytes

10. find  /  -nouser
   两种没有所有者的文件合理
（1）	外来文件
（2）	部分内核产生的文件  
11.netstat –an | grep ESTABLISHED| wc -1  统计数量

   ll  /etc/ | more   分屏查看
   ll  /etc/  | grep
   只要加了管道付，1命令的结果是保存在临时文件中，命令操作的是字符串
  
 12.压缩和解压缩
   1） zip    可压缩目录
       压：     zip  压缩后的包名  源文件
解：     uzip 压缩包    
       zip   -r   压缩目录
   2）gz  不会打包
       压：gzip   源文件   （源文件不保留   
           gzip   -r  源目录   不能压缩目录，压缩的目录下的所有内容         
       解：gzip         -d  压缩包
           gunzip    压缩包
           gunzip  -r   压缩包  解压目录

3）bz2  不能压缩目录
    压：bzip2    源文件
        bzip2    -k  源文件   保留源文件
    解：bzip2    -d  压缩包
4）tar  打包命令  不压缩
       tar   -cvf  打包文件名  源文件  打包
       tar   -cvf  aa.tar.  aa
       -c打包   -v显示打包过程   -f 指定生产后的文件名

   解打包;
        tar  -xvf  打包文件名   
        tar  -xvf   aa.tar
        -x   解打包



压缩同时打包
     tar   -zcvf  压缩文件名  源文件
      tar  -zcvf  aa.tar.gz    aa
    

tar   -zxvf   压缩文件名  解压缩同时解打包

tar   -jcvf  压缩文件名   源文件压缩同时打包
      tar  -jcvf  aa.tar.bz2     aa
      tar  -jxvf  aa.tar.bz2

查看不解包
    tar  -ztvf  aa.tar.gz  查看不解包
    tar  -jtvf  aa.tar.bz2
         -t    只查看    不解压


  指定解压缩文件位置  tar  -jxvf  aa.tar.bz2  -C  /tmp/abc

16.w  查看当前登陆用户
  tty  本地登陆
  pts  远程登录
   alt   F1-6  字符终端
   ctrl  alt  F7  （按住三秒）必须安装和启动

   pts/0  -  255  远程终端

          pkill  -9  t  pts/3      踢出用户
          who   查询登录用户
        17.last  列出登录系统的相关信息

            lastlog  显示所有用户最后一次登录时间   

        18.write  用户名  给在线用户写信   
           wall   给所有在线用户写信   
         没看的邮件保存在/var/spool/mail/root
         看过的邮件 ： ~/mail 

           mail
1	2  查看对应的邮件
h       列出邮件标题
q        退出
          
    
                     























7.18
1.ping —c 次数 ip  探测网络通畅
Ping –s  65536 ip 指定探测数据包大小          死亡之ping
虚拟机不同; 确定IP地址、防火墙，确定虚拟机网卡连接方式

2.ifconfig  
英文:interface configure
路径:/sbin/ifconfig
执行权限：root
      ifconfig  eth0 192.168.140.252   network 255.255.255.0  临时生效
eth0    eth0:0   第一块网卡的第一模拟网 卡
3.  /etc/services             所有系统常见端口
     端口数量; tcp  65535    udp  65535
     telnet   ip  端口  测试端口是否可以正常连接
     ctrl + ] ------  quit

     neystat  -tlun  查看本机所有监听端口
     -t tcp   -u  udp   -l  监听   -n  以ip和端口显示

4.cd  /etc/sysconfig/network – scripts/   网卡配置文件保存位置
  cp  ifcfg-eth0  ifcfg –eth0:0  主网卡模拟的第一块模拟网卡
     vi  ifcfg-eth0:0  Device名称要和网卡名称一样
      
     3306 mysqlduank
     3389 windows终端服务
     53   DNS端口
关机、重启命令
1.sync 数据同步，把内存中数据强制保存进硬盘
   1）shutdown  -h  now      没有特殊情况使用此命令
      shutdown   -h 5：30 定时关机
   2 ）init 0
3）halt
4）poweroff、
2.重启命令
   1）shutdown –r now
   2）reboot   /sbin/reboot   执行权限：root
   3）init 6
挂载命令
1.mount [-l]
   查询系统中已挂载的设备，-l会显示卷标名称
  mount –a
   依据配置文件/etc/fstab的内容，自动挂载
                  Linux开机自动挂载文件
  mount  [-t文件系统][-l卷标名][-o特殊选项]
         设备文件名  文件系统
2.光盘挂载
   /dev/sda1  第一个scsi硬盘的第一个分区
   /dev/cdrom  光盘       /dev/hdc  redhat 5

挂载前要插入光盘  
标准挂载  mount   -t  iso9660  /dev/sr0   /mnt/cdrom
  Mount  /dev/sr0    /mnt/cdrom
路径  umount  /mnt/cdrom
3.u盘挂载
   fdisk  标准分区命令
   fdisk  -l   查看U盘设备名

   mkdir   /mnt/usb
   mount  -t  vfat  /dev/sdb4  /mnt/usb/
   卸载
umount  /dev/sdb4
          -t  vfat————fat32 
              Fat-------fat16

Linux默认情况不识别NTFS格式，如果要使用，必须重新编译内核

Linux支持中文
1.是否安装了中文字体
2.你的操作界面必须支持中文显示 （远程工具，图形界面）

mount –t  vfat –o  iocharset=utf8  /dev/sdb4   /mnt/usb
挂载U盘，指定中文编码为UTF-8，否则无法识别中文

4.-o特殊选项  
   Defaults 定义默认值，相当于rw ，suid，dev，exec,auto,nouser,async
   Remount 重新挂载已经挂载的文件系统，一般用于指定修改特殊权限

 Linux的驱动：
   Linux的驱动是内核自带的，正常情况不需要安装
   只有内核中不包含新硬件，才需要手工安装驱动


     

    
    
                      




																										

	












7.19  vim编辑器
第三章 vim 编辑器 
        vi 编辑器 
    一 vi 编辑器简介 
  alias  vi=’vim’    修改别名（临时）   alias查询
  环境变量设置     重新登陆即可生效
 /etc/profile
~/.bashrc        vi ~/.bashrc  添加  alias vi=’vim’永久生效
Source  .bashrc  让需要重新登陆才能生效的环境变量配置文件直接生效
    vim          全屏幕纯文本编辑器




 
命令----》输入 a：追加 i：插入 o：打开 
命令----》末行   : 
 :w  保存 
 :q  不保存退出 
:wq 保存退出 
 !  强制                :q!       :wq! 
 :w  文件名                     另存为 

输入----末行 :

2      命令模式操作 
1）移动光标 
hjkl 
2）把光标移动到文件头或尾 
gg  移动到文件头 
shift+g G            移动到文件尾 
^             移动到行首 
$             移动到行尾 
:n            移动到第几行 

3）删除字母
x           删除单个字母 
nx          删除n 个字母 

4）删除整行剪切 
dd          删除单行 
:n1,n2d     删除指定范围的行
dG：        从光标所在行，删除到文件尾

ndd         删除多行  
p           粘贴 
P （大）    粘贴到光标前 

5）复制 
yy 
nyy 

6）撤销 
u           撤销 
ctrl+r      反撤销 

7）替换 
r           替换光标所在处的字符 
R           从光标所在处开始替换字符，按ESC 结束 

8)显示行号 
：set       nu 
:set        nonu 
Vi的配置文件
~/.vimrc   不存在手工建立
Vi打开，写入内容：set  nu
9)颜色开关 
 :syntax      off 
 :syntax      on 

10)查找                   掌握 
/查找内容                   向下查找 

n     下一个 
N     上一个
11）
：1,10s/old/new/g               替换1到10行的所有old 为new 
：%s/old/new/g                 替换整个文件的old 为new 
 g                              范围内所有old换为new
：1,5s/^/#/g                   注释1到5行
:1,5s/^#//g                    取消注释 
 :1,5s/^/\/\//g                 文件头加入// 

 11) 
:r  !命令             把命令输出结果写入光标所在行 
 :r  !date
三、vim 使用技巧 

    1、在vim 中导入其他文件内容或命令结果 
    1）导入其他文件内容 
    在命令模式下： 
    :r 文件名 

    2）在vim 中执行系统命令 
    :!命令 

    3）导入命令结果 
    :r !命令 
2、设定快捷键 
    :map 快捷键快捷键执行的命令 

例如： 
    :map ^P I#<ESC> 
    #当输入ctrl+p快捷键时，执行在行首加入#注释 
    #^P 不能手工输入，需要执行ctrl+V+P来定义，或ctrl+V ，然后ctrl+P 

    : map  ^B ^x 
    #当输入ctrl+B快捷键时，把光标移动到行首，然后删除一个字母。用于取消注释 

    3、替换 
    :ab 源字符 替换为字符 
    :ab mymail shenchao@lampbrother.net
如果需要永久生效，可以写入vim 配置文件        ~/.vimrc  

  4.上下分屏   vi –o  abc  test
               先ctrl   w     下箭头  上箭头切换
    左右分屏
vi  O  abc  tes
               Ctrl   w   左右箭头切换


常用快捷键
   Ctrl  c   强制终止    ctrl  a  光标移动到行首
   Ctrl  l   清屏
   Ctrl  u   从光标清除到行首
   Ctrl  y   粘贴
   Ctrl  a   光标移动到行尾

   Ctrl  z   放入后台

   ps  aux  查进程

软件包安装 
一 软件包分类 
 1、软件包分类 
源码包
        二进制包 

                脚本安装包 
2、源码包 
    1）源码包什么样 
[root@localhost ~]# vim  hello.c 
#include <stdio.h> 
int main (void) 
{ 
        printf ("hello world\n"); 
} 

[root@localhost~]#rpm –ivh /mnt/cdrom/Packages/gcc-4.4.6-4.e16.i686.rpm

[root@localhost ~]# gcc -c hello.c 
#-c 生成“.o”头文件。这里会生成hello.o头文件，但是不会生成执行文件 
[root@localhost ~]# gcc -o hello hello.o
#-o 生成执行文件，并制定执行文件名。这里生成的hello就是可执行文件 
[root@localhost ~]# ./hello 
hello world 
#执行hello文件 

    2）源码包特点 
 源码包的优点是： 
           开源，如果有足够的能力，可以修改源代码 
         可以自由选择所需的功能 
         软件是编译安装，所以更加适合自己的系统，更加稳定也效率更高 
         卸载方便 
 源码包有缺点吗？ 
         安装过程步骤较多，尤其安装较大的软件集合时（如LAMP 环境搭建），容易 
            出现拼写错误 
         编译过程时间较长，安装比二进制安装时间长 
         因为是编译安装，安装过程中一旦报错新手很难解决
2、二进制包 
    1）分类 
     DPKG 包：是由Debian Linux 所开发出来的包管理机制，通过DPKG 包， Debian Linux 就可以进行软件包管理。主要应用在Debian 和unbuntu 中。 
     RPM 包：是由Red Hat 公司所开发的包管理系统。功能强大，安装、升级、查询和卸载都非常简单和方便。目前很多Linux 都在使用这种包管理方式，包 括Fedora、CentOS、SuSE 等。我们学习的是CentOS 6.3，所以我们将要学习RPM 包管理系统 
    2）特点 
    RPM 包的优点： 
         包管理系统简单，只通过几个命令就可以实现包的安装、升级、查询和卸载 
         安装速度比源码包安装快的多 
    RPM 包的缺点: 
         经过编译，不再可以看到源代码 
         功能选择不如源码包灵活 
         依赖性。有时我们会发现需要安装软件包a 时需要先安装b 和c，而安装b  时需要安装d 和e。这是需要先安装d 和e，再安装b 和c，最后才能安装a包。比如说，我买了个漂亮的灯具，打算安装到我们家客厅，可是在安装灯具之前我们家客厅总要有顶棚吧，顶棚总要是做好了防水和刷好油漆了吧， 这个装修和安装软件其实类似总要有一定的顺序的。可是有时依赖性会非常 繁琐 
 3）RPM包依赖 
  a---->b---->c       树形依赖 

 a---b----c---a  环形依赖 

  模块依赖        www.rpmfind.net 
(rpm-ivh /mnt/CentOS/mysql-connector-odbc-3.51.26r1127-1.el5.i386.rpm )
二、 rpm安装 
1   包命名 
httpd-2.2.15-15.el6.centos.1.      rpm 
httpd   软件包名 
2.2.15  软件版本 
15      软件发布的次数 
el6     软件发行商。el6是RedHat 公司发布，适合RHEL6.x （Red Hat Enterprise Linux） 
        和CentOS6.x 下使用 
i686    适合的硬件平台。RPM 包可以在不同的硬件平台安装，选择适合不同CPU 的软件版 本，可以最大化的发挥CPU 性能，所以出现了所谓的i386 （386 以上计算机都可以 安装）、i586 （586 以上的计算机都可以安装）、i686 （奔腾II 以上计算机都可以 安装，目前所有的CPU 都是奔腾II 以上，所以这个软件版本居多）、x86_64 （64 位CPU 可以安装）和noarch （没有硬件限制）等文件名了。 
rpm     rpm 包的扩展名。我们说过Linux 下文件不是靠扩展名区分文件类型，也就是Linux 中扩展名没有任何含义。可是这里怎么又出现了扩展名呢？原因很简单，如果我不 把RPM 的扩展名叫做“.rpm”，管理员很难知道这是一个RPM 包，当然也就无法正 确安装了。也就是说如果RPM 包不用“.rpm”作为扩展名，系统可以正确识别没有 问题，可是管理员很难识别这是个什么样的软件。 

 2   依赖性 
3   安装 
 1）默认安装位置 
 RPM 包默认安装路径 
  /etc/                             配置文件安装目录 
/usr/bin/                         可执行的命令安装目录 
 /usr/lib/                         程序所使用的函数库保存位置
/usr/share/doc/                   基本的软件使用手册保存位置 
/usr/share/man/                   帮助文件保存位置
2）安装命令 
2、RPM 包安装 
    1)安装命令 
rpm  –ivh 包全名 
#注意一定是包全名。如果跟包全名的命令要注意路径，因为软件包在光盘当中 
选项： 
    -i      install安装（install） 
    -v      显示更详细的信息（verbose） 
    -h      打印#显示安装进度（hash） 
--nodeps  不检测依赖性安装。软件时会检测依赖性，确定所需的底层软  件是否安装。如果没有安装则会报错。如果我不管依赖性，想强行安装，可以使用这个选项。注意：这样不检测依赖性安装的软件基本是不能使用的，所以不建议这样做
 --replacefiles替换文件安装。如果安装软件包，可是包中部分文件已经 存在，那么正常安装时候，会报错“某个文件已经存在”从而导致软件无法 安装，使用这个选项可以忽视这个报错，而覆盖安装 
 --replacepkgs     替换软件包安装。如果软件包已经安装，此选项可以把软件包重复安装一遍。 
 --force    强制安装。不管是否已经安装，都重新安装。就是—replacefiles  和—replacepkgs 的综合。 
 --test  测试安装。不会实际安装，只是检测一下依赖性。 
 --prefix    指定安装路径。为安装软件指定安装路径，而不使用默认安装路径。注意：如果指定了安装路径，软件没有安装到系统默认路径中的话，系  统会找不到这些安装的软件，需要进行手工配置才能被系统识别。所以rpm 包我们一般都采用默认路径安装。 
 





2017.7.20
2）服务启动 
 [root@localhost ~]# service 服务名 start|stop|restart|status 
参数： 
    start：      启动服务 
    stop：       停止服务 
    restart：    重启服务 
    status：  查看服务状态 
 4、RPM 包升级 
[root@localhost ~]#  rpm  –Uvh 包全名 
选项： 
    -U（大写）升级安装，如果没有安装过，系统直接安装。如果安装过的版本较旧，则升级到新版本（upgrade） 
[root@localhost ~]#  rpm  –Fvh 包全名 
选项： 
-F （大写） 升级安装，如果没有安装过，则不会安装。必须安装有较旧版本，才能升级（freshen）
5、卸载 
    rpm  -e  包名 
 --nodeps不检查依赖性
6、查询 
    rpm  -q  包名               查询包是否安装 
 rpm  -qa  | grep  httpd     显示所有安装包 
rpm  -qi  包名       查询包的信息            -p  未安装包 
 rpm  -qip  包全名           查询没有安装包的信息 
rpm  -ql  包名              查询包中文件的安装位置 
rpm  -qf 系统文件名         查询系统文件属于哪个包 
rpm –qR 包名               查询软件包所依赖的软件
rpm -qRp 包全名             查询没有安装的包的依赖性 
  7、验证 
1）基本命令 
[root@localhost ~]# rpm  –Va 
选项： 
    -Va 校验本机已经安装的所有软件包 
[root@localhost ~]# rpm  –V 已安装的包名 
选项： 
    -V  校验指定RPM 包中的文件 （verify） 

 [root@localhost ~]# rpm  –Vf 系统文件名
选项： 
    -Vf 校验某个系统文件是否被修改 
 2）验证举例 
[root@localhost ~]# rpm -V httpd 
S.5....T.           c         /etc/httpd/conf/httpd.conf 
验证内容        文件类型        文件名 

出现了提示信息，我们来解释下最前面共有8个信息内容，是表示验证内容的。文件名前面的 c 是表示这是个配置文件 （configuration）。最后是文件名。那么验证内容中的8 个信息的具体内容如下： 
S     文件大小是否改变 
M     文件的类型或文件的权限（rwx）是否被改变
5     文件MD5 校验和是否改变（可以看成文件内容是否改变） 
D     设备的中，从代码是否改变 
L     文件路径是否改变 
U     文件的属主（所有者）是否改变 
G     文件的属组是否改变 
T     文件的修改时间是否改变 

apache配置文件的文件类型是c，那么还有哪些文件类型呢？ 
c     配置文件（config file） 
d     普通文档（documentation） 
 g    “鬼”文件（ghost file），很少见，就是该文件不应该被这个RPM 包包 含 
l     授权文件（license file） 
r     描述文件（read me） 

8、数字证书 
 刚刚的校验方法只能对已经安装的RPM 包中的文件进行校验，但是如果RPM 包本身就被 动过手脚，那么校验就不能解决问题了。我们就必须使用数字证书验证了。 
数字证书有如下特点： 
    首先必须找到原厂的公钥文件，然后进行安装 
    再安装RPM 包是，会去提取RPM 包中的证书信息，然后和本机安装的原厂证书进行验证 
    如果验证通过，则允许安装；如果验证不通过，则不允许安装并警告 
1）数字证书位置 
那么数字证书在哪里呢？其实在CentOS 6.3 的第一张光盘中就有，当然它默认也会放在系 统中。 
[root@localhost ~]# ll /mnt/cdrom/RPM-GPG-KEY-CentOS-6 
-r--r--r-- 2 root root 1706 7 月 2 04:21 /mnt/cdrom/RPM-GPG-KEY-CentOS-6 
#光盘中的数字证书位置 

[root@localhost ~]# ll /etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-6 
-rw-r--r--. 1 root root 1706 6月 26 17:29 /etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-6 
#系统中的数字证书位置 
2）数字证书导入 
 [root@localhost ~]# rpm --import /etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-6 
选项： 
    --import    导入数字证书 
    我们如何查询系统中安装好的数字证书呢？命令如下： 
[root@localhost ~]# rpm -qa | grep gpg-pubkey 
gpg-pubkey-c105b9de-4e0fd3a3 
8、RPM包中文件的提取 
1）cpio命令 
 cpio 命令主要有三种基本模式：“-o”模式指的是copy-out 模式，就是把数据备份到文件库中；“-i”模式指的是copy-in模式，就是把数据从文件库中恢复；“-p”模式指的是复制模式，就是不把数据备份到cpio库中，而是直接复制为其他文件。命令如下： 
[root@localhost ~]# cpio -o[vcB] > [文件|设备] 
#备份 
选项： 
    -o：copy-out模式，备份  
    -v：显示备份过程 
    -c：使用较新的portable format 存储方式 
    -B：设定输入输出块为5120bytes，而不是模式的512butes 
[root@localhost ~]# cpio -i[vcdu] < [文件|设备] 
#还原 
选项： 
    -i：copy-in模式，还原 
    -v：显示还原过程 
    -c：使用较新的portable format 存储方式 
    -d：还原时自动新建目录 
    -u：自动使用较新的文件覆盖较旧的文件 
[root@localhost ~]# cpio -p 目标目录 
    举几个例子吧，先来看看使用cpio备份数据的方法，命令如下： 
例子：利用find命令找到文件，备份 
[root@localhost ~]# find /etc -print | cpio -ocvB > /root/etc.cpio 
#利用find指定要备份/etc/目录，使用>导出到etc.cpio文件 
[root@localhost ~]# ll -h etc.cpio 
-rw-r--r--. 1 root root 21M 6月 5 12:29 etc.cpio 
#etc.cpio 文件生成 
    再来看看如何恢复cpio 的备份数据，命令如下： 
[root@localhost ~]# cpio -idvcu < /root/etc.cpio 
#还原etc 的备份 
#但是如果大家查看下当前目录/root，会发现没有生成etc 目录。这是因为备份是/etc 目录使用的是绝对路径，所以恢复的数据直接恢复到了/etc 系统目录中，而没有生成在/root/etc 中。 
在 CentOS5.x 的版本中，是可以利用上面的命令备份与恢复指定的文件。但是到 
CentOS6.x 当中，需要更加严谨。如果备份时使用绝对路径，则恢复的数据会直接到绝对路 
径指定的路径中，如果需要把数据恢复到当前目录中，则需要使用相对路径，例如： 
备份： 
[root@localhost ~]# cd /etc 
#进入/etc 目录 
[root@localhost ~]# find . -print | cpio -ocvB > /root/etc.cpio 
#利用find指定要备份/etc/目录，使用>导出到etc.cpio文件 

恢复： 
[root@localhost ~]# cd /root 
#回到/root 目录中 
[root@localhost ~]# mkdir etc_test 
#建立恢复测试目录 
[root@localhost ~]# cd etc_test
#进入测试目录，数据恢复到此 
[root@localhost etc_test]# cpio -idvcu < /root/etc.cpio 
#还原/etc 目录的数据，因为备份时使用的是相对路径，则会还原到/root/etc_test/目录下 

    最后来演示一下cpio命令的“-p”复制模式，命令如下： 
[root@localhost ~]# cd /tmp/ 
#进入/tmp 目录 
[root@localhost tmp]# rm -rf * 
#删除/tmp 目录中所有数据 










































0
[root@localhost tmp]# mkdir test 
#建立备份目录 
[root@localhost tmp]# find /boot/ -print | cpio -p /tmp/test 
#备份/boot/目录到/tmp/test/目录中 
[root@localhost tmp]# ls test/ 
boot 
#在/tmp/test/目录中备份出了boot 目录 
 2）提取RPM 包中文件 
[root@localhost ~]# rpm2cpio 包全名 | cpio -idv .文件绝对路径 
rpm2cpio        将rpm 包转换为cpio格式的命令 
cpio            是一个标准工具，它用于创建软件档案文件和从档案文件中提取文件 
举个例子，现在我假设把系统中的/bin/ls命令不小心误删除了，那么我可以修复回来吗？ 
这时有两种方法修复，要不就是使用—force  选项覆盖安装一遍 
coreutils-8.4-19.el6.i686包，要不就可以使用cpio命令提取出/bin/ls命令文件，再把 
它拷贝到对应位置就可以了。不过我是怎么知道/bin/ls  命令是属于 
coreutils-8.4-19.el6.i686这个软件包的呢？还记得-qf选项吗？命令如下： 
[root@localhost ~]# rpm -qf /bin/ls 
coreutils-8.4-19.el6.i686 

#查看ls文件属于哪个软件包 
    那么我们在讲RPM 包中文件提取，所以我们使用第二章方法，cpio命令提取出ls命令 
文件，然后拷贝到对应位置，命令如下： 
[root@localhost ~]# mv /bin/ls /root/ 
#把/bin/ls命令移动到/root 目录下，造成误删除的假象 
[root@localhost ~]# ls 
-bash: ls: command not found 
#这时执行ls命令，系统会报错“命令没有找到” 
[root@localhost ~]# rpm2cpio /mnt/cdrom/Packages/coreutils-8.4-19.el6.i686.rpm | 
cpio -idv  ./bin/ls 
./bin/ls 
24772 块 

#提取ls命令文件到当前目录下
[root@localhost ~]# cp /root/bin/ls  /bin/ 
#把提取出来的ls命令文件复制到/bin 目录下 
[root@localhost ~]# ls 
anaconda-ks.cfg  bin  inittab      install.log  install.log.syslog      ls 
#恭喜你，ls命令又可以正常使用了 
二 yum 
1、yum命令 

yum  -y  install  包名        安装        -y   自动回答yes 
yum  -y  remove  包名 
 yum  -y  update  包名 
yum  list                     查询所有可以安装的包 w
 yum list 包名             查询yum源服务器中是否包含某个软件包 
 yum search 关键字           搜索yum源服务器上所有和关键字相关的包 
  yum info samba             查询指定软件包的信息 
2、yum组管理命令 

查询可以安装的软件组 
[root@localhost ~]# yum grouplist 
#列出所有可用的软件组列表 

查询软件组内包含的软件 
[root@localhost ~]# yum groupinfo 软件组名 
#列出软件组中包含的软件 
例如： 
[root@localhost ~]# yum groupinfo "Web Server" 
#查询软件组"Web Server"中包含的软件 

安装软件组 
[root@localhost ~]# yum groupinstall 软件组名 
#安装指定软件组，组名可以由grouplist 查询出来 
例如： 
[root@localhost ~]# yum groupinstall "Web Server" 
#安装网页服务软件组 
卸载软件组 
[root@localhost ~]# yum groupremove 软件组名 
#卸载指定软件组
3、搭建光盘yum源 
光盘作为yum源： 
 
 1   cd  /etc/yum.repos.d/ 

                mv  CentOS-Base.repo  CentOS-BS.repo.bak 
解释下yum源文件 

    [base]        容器名称，一定要放在[]中 
    name          容器说明，可以自己随便写 
    mirrorlist    镜像站点，这个可以注释掉 
    baseurl       我们的yum源服务器的地址。默认是CentOS 官方的yum源服务器，是可以使用的，如果你觉得慢可以改成你喜欢的yum源地址 
    enabled       此容器是否生效，如果不写或写成enable=1都是生效，写成 enable=0就是不生效 
    gpgcheck      如果是1是指RPM 的数字证书生效，如果是0 则不生效 
    gpgkey        数字证书的公钥文件保存位置。不用修改 
    2   mount /dev/hdc  /mnt/cdrom 
3   vi  /etc/yum.repos.d/CentOS-Media.repo 

        baseurl=file:///mnt/cdrom/         指定yum源位置 
        enabled=1                          yum源文件生效 
gpgcheck=0                         rpm验证不生效 

        pkill -9 yum-updatesd              如果yum报错正在升级，执行此命令，强制杀死升级 

进程 

        yum  -y  install  gcc       (gcc是c语言编译器，不装gcc，源码包不能安装) 
总结：
一、	手工安装命令
安装        rpm –ivh   包全名
升级        rpm –Uvh   包全名
            rpm  -Fvh   包全名
卸载        rpm  -e     包名
1）	查询是否安装    rpm  -q  包名               
rpm  -qa  | grep  httpd
2）	查询报信息      rpm  -qi  包名
                   rpm  -qip 包全名
3）	查询包安装位置  rpm  ql   包名
                rpm  qip  包全名
4）	查询系统文件属于哪个包
                rpm  -qf   系统文件名
5）	查询包的依赖    rpm  -qR   包名
验证            rpm  -V    包名
导入数字证书    rpm  -import  /mnt/cdrom/RPM-GPG-KEY-CentOs-6
提取rpm包中的文件
二、	yum在线安装
安装   yum  -y  install  
卸载   yum  -y  remove  包名 
升级   yum  -y  update  包名 
查询yum  list               查询所有可以安装的包 
pkill -9 yum-updatesd  如果报错正在升级，执行此命令，强制杀死升级进程


























2017.7.21
三 源码包安装 
   1.什么样的服务可以修改端口
       如果网络服务是给大量客户端提供访问的，不建议修改端口
       如果网络服务是给公司内部人使用，建议修改端口（ssh）
   2.源码包安装前，解决的问题：
     1）如何选择源码包还是安装包
     2）已经按安装了rpm包的Apache，是否可以再装一个源码包Apache？
       rpm包Apache安装在哪里？          默认位置（rpm –ql 全名）
       源码包Apache安装在哪里？          手工指定位置（/usr/local/apache2）
3）	能启动几个？
只能启动一个，因为80端口只有一个
所以只建议安装源码包Apache，我们这里只为教学
4）	源码包从哪里获取？
官网下载     httpd-2.2.9.tar.gz
2.源码包安装
 1）远程传输工具winscp传输apache到linux。 
                 x-shell   
                 rpm –ivh lrzsz-012……….
 2） 安装 
            a）解压 
            b）cd  解压目录 
            b） 查看安装文档 
                INSTALL     README 
            c）编译前准备
./configure  --prefix=/usr/local/apache2 
            d)编译            
            make （依靠Makefile文件执行）
            make  clean    清除临时文件和缓存文件（。configure  make报错，只是产生临时文件
     make  clear
           e）编译安装 
            make  install 
                注意error  warning等错误报警 
            如果报错，会向/usr/local/apache2写入数据，此时既要make clean，也要直接删除安装目录
           f） 启动 
            /usr/local/apache2/bin/apachectl  start 
     3.RPM包和源码包Apache的不同：安装位置的不同
       1）启动
          a．RPM包启动
             service httpd start|stop|restart|status
             /etc/rc.d/init.d/httpd  start
          b.源码包启动
             /usr/local/apache2/bin/apachectl   start
2)	配置文件
a./etc/httpd/conf/httpd.conf
b./usr/local/apache2/bin/apachectl   start
      3）网页文件位置
         a.rpm包
           /var/www/html/
         b.源码包
           /usr/local/apache2/htdocs
      4)日志位置
         a.rpm包
           /var/log/httpd
         b.源码包
           /usr/local/apache2/logs/
         如何让service的命令也识别源码包启动命令？
         ln –s  /usr/local/apache2/bin/apachectl  /etc/rc.d/init.d
         service   apachectl   start
    4.打入补丁 
    1）补丁的生成 
[root@localhost ~]# diff 选项 old new 
#比较old和new文件的不同 
选项： 
    -a      将任何文档当做文本文档处理 
    -b      忽略空格造成的不同 
    -B      忽略空白行造成的不同 
    -I      忽略大小写造成的不同 
    -N       当比较两个目录时，如果某个文件只在一个目录中，则在另一个目录中视作空文件 
    -r      当比较目录时，递归比较子目录 
    -u      使用同一的输出格式 
    举例 

[root@localhost ~]# mkdir test 
#建立测试目录 
[root@localhost ~]# cd test
#进入测试目录 
[root@localhost test]# vi old.txt 
our 
school 
is 
lampbrother 

#文件old.txt，为了一会输出便于比较，每行分开 

[root@localhost test]# vi new.txt 
our 
school 
is
lampbrother 
in 
Beijing 
#文件new.txt 
比较下两个文件的不同，并生成补丁文件“txt.patch”，命令如下： 
[root@localhost   test]#  diff  -Naur  /root/test/old.txt  /root/test/new.txt  > 
txt.patch 

#比较两个文件的不同，同时生成txt.patch补丁文件 
[root@localhost test]# vi txt.patch 
#查看下这个文件 
--- /root/test/old.txt  2012-11-23 05:51:14.347954373 +0800 
#前一个文件 
+++ /root/test/new.txt  2012-11-23 05:50:05.772988210 +0800 
#后一个文件 
@@ -2,3 +2,5 @@ 
 school 
 is 
 lampbrother 
+in 
+beijing 

#后一个文件比前一个文件多两行（+表示） 
    2）打入补丁 
[root@localhost test]# patch  –pn < 补丁文件 
#按照补丁文件进行更新 
选项： 
    -pn     n 为数字。代表按照补丁文件中的路径，指定更新文件的位置。 
     “-pn”不好理解，我们说明下。补丁文件是要打入旧文件的，但是你当前所在的目录 和补丁文件中的记录的目录是不一定匹配的，所以就需要“-pn”来同步两个目录。比如我当前是在“/root/test”目录中（我要打补丁的旧文件就在当前目录下），补丁 件中记录的文件目录为“/root/test/old.txt”，这时如果写入“-p1”（在补丁文件目录 中取消一级目录）那么补丁文件就会打入“/root/test/root/test/old.txt”文件中，这显然是不对的。那如果写入的是“-p2”（在补丁文件目录中取消二级目录）那么补丁文件打入的就是“/root/test/test/old.txt”,这显然也不对。如果写入的是“-p3”（在补丁文件目录中取消三级目录）那么补丁文件就是打入的“/root/test/old.txt”，我们的old.txt 文件就在这个目录下，所以就应该是“-p3”。 
那么我们更新下“old.txt”文件，命令如下： 
[root@localhost test]# patch -p3 < txt.patch 
patching file old.txt 

#给old.txt文件打补丁 

[root@localhost test]# cat old.txt 

#查看下old.txt 的内容吧。
our 
school 
is 
lampbrother 
in 
Beijing 

#多出来了in Beijing 两行 
5.脚本安装程序 
         webmin安装 

         ./setup.sh 

         安装位置 

         日志位置 

         perl安装位置 

         端口 

         管理员名 

         管理员密码 

         ssl：         不启用 

         开启启动 

    五 函数库管理 

     1、函数库分类 
  静态函数库 
    函数库文件一般以“*.a”扩展名结尾。这种函数库在被程序调用时会被 直接整合到程序当中 
    优点： 程序执行时，不需要再调用外部数据，可以直接执行 
    缺点： 因为把所有内容都整合到程序中，所以编译生成的文件会比较大 ,升级比较困难，需要把整个程序都从新编译 
 动态函数库 
       函数库文件通常以“*.so”扩展名结尾。这种函数库被程序调用时，并没有直接整合到程序当中，当程序需要用到函数库的功能时，再去读取函数 
库。在程序中只保存了函数库的指向。 
1、	函数库管理
1）安装函数库 
[root@localhost ~]# ldd -v 可执行文件名 
选项： 
    -v      显示详细版本信息 
    那么系统中的可执行程序到底调用了哪些函数库呢？可以查询到吗？当然可以了，命令 如下： 
[root@localhost ~]# ldd -v 可执行文件名 
选项： 
    -v      显示详细版本信息 
    比如我们查看下ls命令调用了哪些函数库呢？命令如下： 
[root@localhost ~]# ldd /bin/ls 
        linux-gate.so.1 =>  (0x00d56000) 
        libselinux.so.1 => /lib/libselinux.so.1 (0x00cc8000) 
        librt.so.1 => /lib/librt.so.1 (0x00cb8000) 
        libcap.so.2 => /lib/libcap.so.2 (0x00160000) 
        libacl.so.1 => /lib/libacl.so.1 (0x00140000) 
        libc.so.6 => /lib/libc.so.6 (0x00ab8000) 
        libdl.so.2 => /lib/libdl.so.2 (0x00ab0000) 
        /lib/ld-linux.so.2 (0x00a88000) 
        libpthread.so.0 => /lib/libpthread.so.0 (0x00c50000) 
        libattr.so.1 => /lib/libattr.so.1 (0x00158000) 
    那么我们新安装了一个函数库，如何让它被系统识别呢？其实软件如果是正常安装，是不需要手工调整函数库的，它们都会被正常安装。但是万一没有安装正确，需要手工安装呢？ 
那也很简单，只要把函数库放入指定位置，一般我们都放在“/usr/lib”或“/lib”中，然后把函数库所在目录写入“/etc/ld.so.conf”文件。注意是把函数库所在目录名写入，而不是函数库的文件名。比如： 
[root@localhost ~]# cp *.so /usr/lib/ 
#把函数库拷贝入/usr/lib 目录 
[root@localhost ~]# vi /etc/ld.so.conf 
#修改函数库配置文件 
include ld.so.conf.d/*.conf 
/usr/lib 
#写入函数库所在目录（其实/usr/lib 目录默认已经被识别） 
    然后使用ldconfig 命令重新读取/etc/ld.so.conf 文件，把新函数库读入缓存就可， 
命令如下： 
[root@localhost ~]# ldconfig 
#从/etc/ld.so.conf 中把函数库读入缓存 
[root@localhost ~]# ldconfig -p 
#列出系统缓存中所有识别的函数库
补充： 
    date    查看系统时间 
    date  -s  20130220      设定日期 
    date  -s  09:30:00      设定时间 
    du  -sh  目录名        统计目录大小 
        -s  和 

        -h  习惯单位 

自测题 
    一、单选题 
    1、执行命令rpm -Vf /bin/ls，得到如下结果： 
   .M...... /bin/ls 
   问，此信息代表什么含义？     d
A. 表示文件大小被改动过。 
B. 表示文件创建时间被改动过。 
C. 表示文件的所有者被改动过。 
D. 表示文件的权限或文件类型被改动过。 

    2、以下哪条命令可以用于查询，系统中已经安装的软件包yum，安装了哪些文件在系      d
统中？ 
A. rpm -qi yum 
B. rpm -qf yum 
C. rpm -ql yum 
D. rpm -qa  | grep yum 

 3、以下哪条命令可以用于查询系统中命令chmod 所属的软件包？ b
A. rpm -qa | grep chmod 
B. rpm -qf /bin/chmod 
C. rpm -qi chmod 
D. rpm -ql /bin/chmod 

    4、以下关于yum 命令的说法哪个是错误的？  d
A. yum 可以解决软件包依赖关系 
B. yum 可以方便的实现软件包升级 
C. yum 也是通过RPM 包安装软件 
D. yum 不可以更改yum 源 

    二、操作题 
1、查询/etc/rc.d/init.d/sendmail 文件隶属于哪个RPM 包，并校验其是否被更改过 

2、卸载squid软件包，挂载安装光盘使用rpm 命令重新安装squid
3、查看系统安装包samba软件的信息及安装了哪些文件在系统中 

4、指定安装光盘为yum源，并安装gcc 

5、练习安装源代码包proftpd （下载地址http://www.proftpd.org/） 

6、练习脚本安装webmin 

7、升级软件包ntp 

8、执行命令“chmod 777 /usr/sbin/visudo”、“rm /etc/sudoers”后校验sudo软件包， 
查看结果后恢复sudo软件包原有权限设置及文






















7.24          用户和用户组管理 
一 用户相关文件 
1   /etc/passwd     用户信息文件 
root:x:0:0:root:/root:/bin/bash 
第一列：用户名 
第二列：密码位 
第三列：用户ID       0      超级用户UID。如果用户UID 为0，代表这个账号是管理员账号。那Linux 中如何把普通用户升级成为管理员呢？就是把其他用户的UID 修改为0就可以了，这点和Windows 是不同的。不过不建议建立多个管理员账号。 
1-499     系统用户（伪用户）UID。这些UID账号是系统保留给系统用户的UID，也就是说UID 是1-499 范围内的用户是不能登录系统的，而是用来运行系统或服务的。其中1-99 是系统保留的账号，系统自动创建。100-499 是预留给用户创建系统账号的。 
500-60000     普通用户UID。建立的普通用户UID 从500开始，最大到65535。 这些用户足够使用了，但是如果不够也不用害怕，2.6.x 内核以后的 Linux 系统用户UID 已经可以支持232 这么多了。 
第四列：组ID         GID 添加用户时，如果不指定用户所属的初始组，那么会建立和 用户名相同的组 
第五列：用户说明 
第六列：用户家目录 ~ 
第七列：登录shell         /bin/bash 
如何把普通用户变成超级用户：把用户UID 改为0 
2   /etc/shadow     影子文件 
root:$6$9w5Td6lg$bgpsy3olsq9WwWvS5Sst2W3ZiJpuCGDY.4w4MRk3ob/i85fI38RH15wzVoomff9isV1PzdcXmixzhnMVhMxbv0:15775:0:99999:7::: 
第一列：  用户名    （不建议改用户名）
第二列：  加密密码 
我们也可以在密码前人为的加入“！”或“*”改变加密值让密码暂时使效使这个用户无法登陆，达到暂时禁止用户登录的效果。意所有伪用户的密码都是“！！”或“*”，代表没有密码是不能登录的。当然我新创建的用户如果不设定密码，它的密码项也是“！！”，代表这个用户没有密码，不能登录
第三列：        密码最近更改时间, 1970年1月1 日作为标准时间 
    时间戳转日期 
[root@localhost ~]# date -d "1970-01-01 15775 days" 
2013年 03 月 11 日星期一00:00:00 CST 
    日期转时间戳 
[root@localhost ~]# echo $(($(date --date="2013/03/11" +%s)/86400+1)) 
15775 
        第四列：        两次密码的修改间隔时间（和第3字段相比） 
        第五例：        密码有效期（和第3字段相比） 180天 
        第六列：        密码修改到期前的警告天数（和第5字段相比） 
        第七列：        密码过期后的宽限天数（和第5字段相比） 
                        默认值-1，代表不生效，到期还可以用，只有改为正值才生效
        第八列：        密码失效时间 
                    这里同样要写时间戳，也就是用1970年1月1 日进行时间换算。如果超过了失效时间，就算密码没有过期，用户也就失效无法使用了 
        第九列：        保留 
3   /etc/group      组信息文件 
        root:x:0 :root             （只能看到附加组）

        第一列：        组名 
        第二列：        组密码位 
        第三列：        GID 
        第四列：        此组中支持的其他用户.附加组是此组的用户 
※  初始组：每个用户初始组只能有一个，初始组只能有一个，一般都是和用户名相同 的组作为初始组 
    附加组：每个用户可以属于多个附加组。要把用户加入组，都是加入附加组 
 4 组密码文件/etc/gshadow 
如果我给用户组设定了组管理员，并给该用户组设定了组密码，组密码就保存在这个文件当中。组管理员就可以利用这个密码管理这个用户组了。 
 5   用户的家目录 
6   用户邮箱目录     这个邮箱在/var/spool/mail          目录当中，例如 lamp  用户的邮箱就是 
/var/spool/mail/lamp 文件 
7   用户模板目录 
        /etc/skel
二 用户管理命令 
1   添加用户 
useradd  用户名
1）手工删除用户 
 手工删除用户试验：手工删除，如果可以正常建立用户，证明用户删除干净。 
                /etc/passwd 
                /etc/shadow 
                /etc/group 
                /etc/gshadow 
                /home/user1 
                /var/spool/mail/user1   邮箱 

 2）手工指定选项添加用户 
 [root@localhost ~]# groupadd lamp1 

#先手工添加lamp1用户组，因为我一会要把lamp1用户的初始组指定过来，如果不事先建立，会报错用户组不存在 
[root@localhost ~]# useradd -u 550 -g lamp1 -G root -d /home/lamp1 \ 
-c "test user" -s /bin/bash lamp1 
#建立用户lamp1 的同时指定了UID （550），初始组（lamp1），附加组（root），家目录（/home/lamp1）， 
用户说明(test user)和用户登录shell （/bin/bash） 
[root@localhost ~]# grep "lamp1" /etc/passwd /etc/shadow /etc/group 
#同时查看三个文件 
/etc/passwd:lamp1:x:550:502:test user:/home/lamp1:/bin/bash 
#用户的UID、初始组、用户说明、家目录和登录shell都和命令手工指定的一致 
/etc/shadow:lamp1:!!:15710:0:99999:7::: 
#lamp1 用户还没有设定密码 
/etc/group:root:x:0:lamp1 
#lamp1 用户加入了root 组，root组是lamp1用户的附加组 
/etc/group:lamp1:x:502: 
#GID502 的组是lamp1组 
[root@localhost ~]# ll -d /home/lamp1/ 
drwx------ 3 lamp1 lamp1 4096 1 月  6 01:13 /home/lamp1/ 
#家目录也建立了啊。不需要手工建立家目录 

3）useradd 命令 
    useradd  选项 用户名 
        选项： 
        -u  550 指定UID 
        -g  组名  指定初始组 不要手工指定 
        -G  组名  指定附加组，把用户加入组，使用附加组 
        -c  说明  添加说明 
        -d  目录  手工指定家目录，目录不需要事先建立 
        -s  shell   /bin/bash. 
        useradd  -G  user1  aa  添加用户aa，指定附加组为user1 
4）useradd 默认值
useradd 添加用户时参考的默认值文件主要有两个，分别是/etc/default/useradd 和 
/etc/login.defs 
    a)/etc/default/useradd 
[root@localhost ~]# vi /etc/default/useradd 
# useradd defaults file 
GROUP=100 
HOME=/home 
INACTIVE=-1 
EXPIRE= 
SHELL=/bin/bash 
SKEL=/etc/skel 
CREATE_MAIL_SPOOL=yes 
挨个解释下： 
     GROUP=100 
这个选项是建立用户的默认组，也就是说添加每个用户时，用户的初始组就是GID 为 100 的这个用户组。目前我们采用的机制私有用户组机制。 
     HOME=/home 
 这个选项是用户的家目录的默认位置，所以所有的新建用户的家目录默认都在/home/下。 
     INACTIVE=-1 
 这个选项就是密码过期后的宽限天数，也就是/etc/shadow 文件的第七个字段。如果是天数，比如10代表密码过期后10天后失效；如果是0，代表密码过期后立即失效；如果是-1，则代表密码永远不会失效。这里默认值是-1，所以所有新建立的用户密码都不会失效。 
 EXPIRE= 
这个选项是密码失效时间，也就是/etc/shadow 文件的第八个字段。也就说用户到达这个日期后就会直接失效。当然这里也是使用时间戳来表示日期的。默认值是空，所以所有新建用户没有失效时间，永久有效。 
 SHELL=/bin/bash 
这个选项是用户的默认shell 的。/bin/bash 是Linux 的标志shell，所以所有新建立的用户默认都具备shell赋予的权限。 
SKEL=/etc/skel 
   这个选项就是定义用户的模板目录的位置，/etc/skel/目录中的文件都会复制到新建用户的家目录当中。 
     CREATE_MAIL_SPOOL=yes 
    这个选项定义是否给新建用户建立邮箱，默认是创建，也就是说所有的新建用户系统都会新建一个邮箱，放在/var/spool/mail/下和用户名相同。 
    b）/etc/login.defs 
[root@localhost ~]# vi /etc/login.defs 
#这个文件有些注释，把注释删除掉，文件内容就变成下面这个样子了 
MAIL_DIR        /var/spool/mail 
PASS_MAX_DAYS   99999 
PASS_MIN_DAYS   0
PASS_MIN_LEN    5 
PASS_WARN_AGE   7 

UID_MIN                   500 
UID_MAX                 60000 

GID_MIN                   500 
GID_MAX                 60000 

CREATE_HOME     yes 

UMASK           077 

USERGROUPS_ENAB yes 

ENCRYPT_METHOD SHA512 
我们一行一行解释下文件内容： 
     MAIL_DIR      /var/spool/mail 
这行指定了新建用户的默认邮箱位置。比如 lamp 用户的邮箱是就是 
/var/spool/mail/lamp。 
 PASS_MAX_DAYS     99999 
 这行指定的是密码的有效期，也就是/etc/shadow 文件的第五字段。代表多少天之后必须修改密码，默认值是99999。 
 PASS_MIN_DAYS     0 
 这行指定的是两次密码的修改间隔时间，也就是/etc/shadow 文件的第四字段。代表第一次修改密码之后，几天后才能再次修改密码。默认值是0。 
 PASS_MIN_LEN      5 
 这行代表密码的最小长度，默认不小于5位。但是我们现在用户登录时验证已经被PAM 
模块取代，所以这个选项并不生效。 
 PASS_WARN_AGE     7 
 这行代表密码修改到期前的警告天数，也就是/etc/shadow 文件的第六字段。代表密码 
到底有效期前多少天开始进行警告提醒，默认值是7天。 
     UID_MIN       500 
     UID_MAX       60000 
这两行代表创建用户时，最小UID 和最大的UID 的范围。我们2.6.x 内核开始，Linux用户的UID 最大可以支持232 这么多，但是真正使用时最大范围是60000。还要注意如果我手工指定了一个用户的UID 是550，那么下一个创建的用户的UID 就会从551 开始，哪怕 00-549之间的UID 没有使用（小于500 的UID 是给伪用户预留的）。 
     GID_MIN       500 
     GID_MAX       60000 
    这两行指定了GID 的最小值和最大值之间的范围。 
     CREATE_HOME       yes 
    这行指定建立用户时是否自动建立用户的家目录，默认是建立 
     UMASK         077
这行指定的是建立的用户家目录的默认权限，因为umask 值是077，所以新建的用户家目录的权限是700，umask 的具体作用和修改方法我们可以参考下一章权限设定章节。 
     USERGROUPS_ENAB       yes 
这行指定的是使用命令userdel 删除用户时，是否删除用户的初始组，默认是删除。 
     ENCRYPT_METHOD        SHA512 
    这行指定Linux 用户的密码使用SHA512 散列模式加密，这是新的密码加密模式，原先的Linux 只能用DES 或MD5 方式加密 
2   设定密码 
    passwd    用户名 
    passwd          改变root 密码（普通用户改密码不要加用户名） 
    passwd  root        改变root 密码 

    passwd  选项 用户名 
    选项： 
        --stdin         允许管道符输入密码 echo "123456" | passwd --stdin user2      用于脚本批量安装
        -l          锁定用户密码，用户不允许登录 
        -u          解锁
3   用户信息修改              修改已经存在的用户信息                    了解 
    usermod  -u  -G  -c  -d  -s  用户名 
    注意：不要修改已经存在的用户的初始组 

    usermod  -L(大)   用户名        锁定用户 
    usermod  -U(大)   用户名       解锁 

    usermod  -l  新名 旧名          用户改名 

4   删除用户 
    userdel  -r  用户名 
        -r  连带家目录一起删除 

5   添加组                 熟悉 
            groupadd  组名 

6   删除组                 熟悉 
            groupdel  组名        注意：必须是空组 

7   把已经存在的用户加入组 

            usermod  -G  组名 用户名 
            gpasswd  -a  用户名 组名            用户加入组
gpasswd  -d  用户名 组名            把用户从组中删除 
 三 用户相关命令 
        1   id  用户名         显示用户的UID，初始组，和附加组 

        2   su  -  用户名          切换用户身份 
                -   连带环境变量一起切换 

        3   改变有效组的命令 
            假设aa 用户即属于aa 组，也属于group1 组，如果有效组是aa 组，那么aa 
用户建立文件时，文件默认属组是aa 组。如果有效组是group1组，那么 
            aa 用户建立文件时，文件默认属组是group1组 

            aa 身份登录： 
            newgrp  group1         aa必须属于group1组，改变aa 的有效组为group1 
                                aa创建的新文件，默认属组伪group1，而不再是aa 

四、用户权限赋予 
        /test  目录，要求aa，bb，cc用户对此目录有rwx。其他人没有权限 

        groupadd  testgrp          建立组 
        gpasswd  -a  aa  testgrp       把aa，bb，cc加入组 
                bb 
                cc 
        chmod  770  /test          修改组权限 
        chgrp  testgrp  /test      修改属组 

自测题 
    一、单选题 
    1、你是一个Linux 服务器的管理员，现在你希望提高系统安全性，你要求系统中每个 
已经存在的普通用户的密码每隔90 天，必须修改一次。那么我们应该修改哪个配置文件？ 
A. /etc/passwd 
B. /etc/shadow 
C. /etc/default/useradd 
D. /etc/login.defs 

    2、如果我们想要让所有新建立的普通用户家目录的权限变为750，而不再是700。那么 
我们应该修改哪个配置文件？ 
A. /etc/passwd 
B. /etc/shadow 
C. /etc/default/useradd
D. /etc/login.defs 

    3、我们需要把已经存在的用户test加入用户组fgroup 组，那么我们一个使用以下哪 
个命令？ 
A. useradd -G fgroup test 
B. useradd -G test fgroup 
C. gpasswd -a test fgroup 
D. gpasswd -a fgroup test 

    4、/etc/shadow 配置文件不包含以下哪个字段： 
A. 密码有效期 
B. 密码过期后的宽限天数 
C. 加密的密码字串 
D. 用户ID号 

    二、操作题 
    1、添加用户组webadmin ，然后添加用户neil ，要求设置用户neil 的缺省组为 
webadmin 、指定其描述信息为“Market xiaoshenyang”，设置其密码为lampbrother ，在 
成功添加用户neil 后再将其加入用户组root 和sys 

    2、查看neil 用户的基本信息，并查看neil 用户都隶属于哪些用户组 

    3、设置用户neil 具有和管理员一样的权限 

    4、把用户neil 从用户组root 中删除，在Linux 中删除用户neil （不保留其宿主目 
录）










7.25                        权限管理
总结：
1.目录可用权限，只有
0	没有权限
5    基本权限
7    完全权限
2.权限溢出：执行权限对目录和文件的作用不同，只要赋予acl递归权限，目录的所有子文件也会有执行权限，这样就会造成权限溢出。
3.setfacl –m   u：bzr：rw   -R   /www
     针对当前目录和目录下已经存在的子目录和子文件生效
  setfacl –m  d：u：bzr：rw  -R   /www
     d  默认   针对当前目录下，以后新建立的子文件或子目录生效（模板）
4.sudo授权   给普通用户赋予部分超级用户才能执行的命令
             赋予的权限越简单，拥有的权限越大
             赋予的权限越复杂，用有的权限越小
一、ACL 权限 
1、ACL 概述
 
2、开启ACL 
[root@localhost ~]# dumpe2fs -h /dev/sda3 
#dumpe2fs命令是查询指定分区详细文件系统信息的命令 

选项： 
    -h  仅显示超级块中信息，而不显示磁盘块组的详细信息。 
...省略部分输出... 
Default mount options:    user_xattr acl 
...省略部分输出... 
    如果没有开启，手工开启分区的ACL 权限： 
[root@localhost ~]# mount   -o   remount,acl     / 
#重新挂载根分区，并挂载加入acl权限 
   也可以通过修改/etc/fstab 文件，永久开启ACL 权限： 
[root@localhost ~]# vi /etc/fstab 
UUID=c2ca6f57-b15c-43ea-bca0-f239083d8bd2  /  ext4    defaults,acl        1  1 
#加入acl 
[root@localhost ~]# mount -o remount / 
#重新挂载文件系统或重启动系统，使修改生效 
3、ACL 基本命令 
    getfacl  文件名        查询文件的acl权限 
    setfacl  选项 文件名             设定acl权限 
        -m          设定权限 
        -b          删除权限 
    setfacl  -m  u:用户名:权限  文件名
setfacl  -m  g:组名：权限 文件名 
    setfacl  -m u:aa:rwx  /test     给test 目录赋予aa 是读写执行的acl权限 
    setfacl -m u:cc:rx -R soft/     赋予递归acl权限，只能赋予目录 
                -R  递归 
    setfacl  -b  /test      删除acl权限 

    setfacl  -m d:u:aa:rwx -R /test    acl 默认权限。           注意：默认权限只能赋予目录 
注意：如果给目录赋予acl权限，两条命令都要输入 
  -R 递归 
  -m  u:用户名：权限            只对已经存在的文件生效 
  -m  d:u:用户名：权限              只对未来要新建的文件生效 

4、最大有效权限mask 
[root@localhost /]# setfacl -m m:rx project/
#设定mask权限为r-x。使用 “m:权限”格式 
[root@localhost /]# getfacl project/ 
# file: project/ 
# owner: root 
# group: tgroup 
user::rwx 
group::rwx                      #effective:r-x 
mask::r-x 
#mask权限变为了r-x 
other::---  
5、删除ACL 权限 
[root@localhost /]# setfacl -x u:st /project/ 
#删除指定用户和用户组的ACL权限
[root@localhost /]# setfacl -b project/
#会删除文件的所有的ACL权限 
二、sudo授权            给普通用户赋予部分管理员权限 

 /sbin/          在此目录下命令只有超级用户才能使用 
 /usr/sbin/
1.root 身份：
visudo      赋予普通用户权限命令，命令执行后和vi 一样使用 
root    ALL=(ALL)       ALL 
#用户名 被管理主机的地址= （可使用的身份）  授权命令（绝对路径） 
# %wheel        ALL=(ALL)      ALL 
#%组名  被管理主机的地址= （可使用的身份）  授权命令（绝对路径） 
 用户名/组名：代表root 给哪个用户或用户组赋予命令，注意组名前加“%” 用户可以用指定的命令管理指定IP地址的服务器。如果写ALL，代表可以管理任 何主机，如果写固定IP，代表用户可以管理指定的服务器。（这里真的很奇怪啊， 超哥一直认为这里的IP地址管理的是登录者来源的IP地址，查了很多资料也都是这样的。直到有一天超哥查看“man 5 sudoers”帮助，才发现大家原来都理解错误了，这里的IP指定的是用户可以管理哪个IP地址的服务器。那么如果你是一台独立的服务器，这里写ALL 和你服务器的IP地址，作用是一样的。而写入网段，只有对NIS 服务这样用户和密码集中管理的服务器才有意义）。如果我们这里写本机的IP地址，不代表只允许本机的用户使用指定命令，而代表指定的用户可以从任何IP地址来管理当前服务器。可使用身份：就是把来源用户切换成什么身份使用，（ALL）代表可以切换成任意 身份。这个字段可以省略 
授权命令：代表root 把什么命令授权给普通用户。默认是ALL，代表任何命令， 
这个当然不行。如果需要给那个命令授权，写入命令名即可，不过需要注意一定要 命令写成绝对路径 
2、举例 
1 举个例子，比如授权用户lamp可以重启服务器，则由root 用户添加如下行： 
[root@localhost ~]# visudo 
lamp        ALL= /sbin/shutdown  –r now 
[lamp@localhost ~]$ sudo -l 
#查看可用的授权 
2)  再举个例子，授权一个用户管理你的Web 服务器，不用自己插手是不是很爽，以后修改设置更新网页什么都不用管，一定Happy 死了，Look： 首先要分析授权用户管理Apache 至少要实现哪些基本授权： 
 1、可以使用Apache 管理脚本 
 2、可以修改Apache 配置文件 
3、可以更新网页内容 
假设Aapche 管理脚本程序为/etc/rc.d/init.d/httpd 。 
为满足条件一，用visudo进行授权： 
[root@localhost ~]# visudo 
lamp        192.168.0.156=/etc/rc.d/init.d/httpd reload,\ 
/etc/rc.d/init.d/httpd configtest 
授权用户lamp可以连接192.168.0.156上的Apache 服务器，通过Apache 管理脚本重新读取配置文件让更改的设置生效 （reload）和可以检测Apache 配置文件语法错误（configtest），但不允许其执行关闭（stop）、重启（restart）等操作。（“\”的意思是一行没有完成，下面的内容和上一行是同一行。） 
为满足条件二，同样使用visudo授权： 
[root@localhost ~]# visudo 
lamp        192.168.0.156=/binvi /etc/httpd/conf/httpd.conf 
 授权用户lamp可以用root 身份使用vi 编辑Apache 配置文件。 
 以上两种sudo 的设置，要特别注意，很多朋友使用sudo会犯两个错误：第一，授权命令没有细化到选项和参数；第二，认为只能授权管理员执行的命令。 
条件三则比较简单，假设网页存放目录为/var/www/html ，则只需要授权lamp对此目录具有写权限或者索性更改目录所有者为lamp 即可。如果需要，还可以设置lamp可以通过FTP等文件共享服务更新网页。 
3）授权aa 用户可以添加其他普通用户 
aa  ALL=/usr/sbin/useradd      赋予aa 添加用户权限.命令必须写入绝对路径  aa  ALL=/usr/bin/passwd    赋予改密码权限，取消对root 的密码修改 
   aa  ALL=/usr/bin/passwd [A-Za-z]*,  !/usr/bin/passwd "",  !/usr/bin/passwd root 
aa 身份 
sudo  /usr/sbin/useradd  ee    普通用户使用sudo命令执行超级用户命 
令


7.26
三、文件特殊权限SetUID、SetGID、Sticky BIT 
 
1、	SetUID 
 	1）SetUID是什么 
SetUID 的功能可以这样理解： 
	只有可以执行的二进制程序才能设定SUID权限 
	命令执行者要对该程序拥有x（执行）权限 
	命令执行者在执行该程序时获得该程序文件属主的身份（在执行程序的过程中灵魂附体为文件的属主） 
	SetUID 权限只在该程序执行过程中有效，也就是说身份改变只在程序执行过程中有效 
 
2、	举例 
[root@localhost ~]# ll /etc/passwd 
-rw-r--r-- 1 root root 1728 1月  19 04:20 /etc/passwd 
[root@localhost ~]# ll /etc/shadow 
---------- 1 root root 1373 1月  19 04:21 /etc/shadow 
 因为 
[root@localhost ~]# ll /usr/bin/passwd  
-rwsr-xr-x 1 root root 25980 2月  22 2012 /usr/bin/passwd 
 /usr/bin/passwd 命令拥有特殊权限 SetUID ，也就是在属主的权限位的执行权限上是 s。可以这样来理解它：当一个具有执行权限的文件设置 SetUID 权限后，用户执行这个文件时将以文件所有者的身份执行。/usr/bin/passwd 命令具有 SetUID 权限，所有者为 root（Linux 中的命令默认所有者都是 root），也就是说当普通用户使用 passwd 更改自己密码的时候，那一瞬间突然灵魂附体了，实际是在用 passwd 命令所有者 root 的身份在执行 passwd 命令， root 当然可以将密码写入/etc/shadow 文件（不要忘记 root 这个家伙是 superman 什么事都可以干），所以普通用户也可以修改/etc/shadow 文件，命令执行完成后该身份也随之消失 
    如果取消SetUID权限，则普通用户就不能修改自己的密码了 
 
3）	危险的 SetUID 
[root@localhost ~]# chmod u+s /usr/bin/vim 
[root@localhost ~]# ll /usr/bin/vim 
-rwsr-xr-x 1 root root 1847752 4月   5 2012 /usr/bin/vim 
 
4）	有几点建议：  
	关键目录应严格控制写权限。比如“/”、“/usr”等； 
	用户的密码设置要严格遵守密码三原则； 
	对系统中默认应该具有 SetUID 权限的文件作一列表，定时检查有没有这之外的文件被设置了 SetUID 权限。 
 
 	5）检测SetUID的脚本 
[root@localhost ~]# vi suidcheck.sh 
#!/bin/bash 
# Author: shenchao （E-mail: shenchao@lampbrother.net） 
 
find / -perm -4000 -o -perm -2000 > /tmp/setuid.check 
#搜索系统中所有拥有SUID和SGID的文件，并保存到临时目录中。 for i in $(cat /tmp/setuid.check) 
#做循环，每次循环取出临时文件中的文件名 do 
        grep $i /root/suid.list > /dev/null 
  #比对这个文件名是否在模板文件中 
                if [ "$?" != "0" ] 
 	 	  #如果在，不报错 
                then                         echo "$i isn't in listfile! " >> /root/suid_log_$(date +%F) 
 	 	 	 	  #如果文件名不再模板文件中，则报错。并把报错报错到日志中 
                fi done 
rm -rf /tmp/setuid.check 
#删除临时文件 
 
[root@localhost ~]# chmod u+s /bin/vi 
#手工给vi加入SUID权限 
[root@localhost ~]# ./suidcheck.sh 
#执行检测脚本 
[root@localhost ~]# cat suid_log_2013-01-20  /bin/vi isn't in listfile! 
#报错了，vi不再模板文件中。代表vi被修改了SUID权限 
 
 	2、SetGID 
 	1）针对文件的作用 
 	SGID即可以针对文件生效，也可以针对目录生效，这和SUID明显不同。如果针对文件，
SGID的含义如下： 
	只有可执行的二进制程序才能设置SGID权限 
	命令执行者要对该程序拥有x（执行）权限 
	命令执行在执行程序的时候，组身份升级为该程序文件的属组 
	SetGID 权限同样只在该程序执行过程中有效，也就是说组身份改变只在程序执行过程中有效 
 	 
[root@localhost ~]# ll /var/lib/mlocate/mlocate.db  
-rw-r----- 1 root slocate 1838850 1月  20 04:29 /var/lib/mlocate/mlocate.db 
 大家发现属主权限是r、w，属组权限是r，但是其他人权限是0： 
[root@localhost ~]# ll /usr/bin/locate  
-rwx--s--x 1 root slocate 35612 8月  24 2010 /usr/bin/locate 
 当普通用户lamp执行locate命令时，会发生如下事情： 
	/usr/bin/locate是可执行二进制程序，可以赋予SGID 
	执行用户lamp对/usr/bin/locate命令拥有执行权限 
	 执行/usr/bin/locate 命令时，组身份会升级为 slocate 组，而 slocate 组对 /var/lib/mlocate/mlocate.db数据库拥有r权限，所以普通用户可以使用locate 命令查询mlocate.db数据库 
	命令结束，lamp用户的组身份返回为lamp组 
 
 	2）针对目录的作用如果SGID针对目录设置，含义如下： 
	普通用户必须对此目录拥有r和x权限，才能进入此目录 
	普通用户在此目录中的有效组会变成此目录的属组 
	若普通用户对此目录拥有w权限时，新建的文件的默认属组是这个目录的属组  这样写的实在太难看明白了，举个例子： 
[root@localhost ~]# cd /tmp/ 
#进入临时目录做此实验。因为临时目录才允许普通用户修改 
[root@localhost tmp]# mkdir dtest 
#建立测试目录 
[root@localhost tmp]# chmod g+s dtest 
#给测试目录赋予SGID 
[root@localhost tmp]# ll -d dtest/ drwxr-sr-x 2 root root 4096 1月  20 06:04 dtest/ 
#SGID已经生效 
[root@localhost tmp]# chmod 777 dtest/ 
#给测试目录权限，让普通用户可以写 
[root@localhost tmp]# su – lamp 
#切换成普通用户lamp 
[lamp@localhost ~]$ cd /tmp/dtest/ 
#普通用户进入测试目录 
[lamp@localhost dtest]$ touch abc 
#普通用户建立abc文件 
[lamp@localhost dtest]$ ll 
总用量 0 
-rw-rw-r-- 1 lamp root 0 1月  20 06:07 abc 
#abc文件的默认属组不再是lamp用户组，而变成了dtest组的属组root 
 
 	3、文件特殊权限之Sticky BIT 
 	Sticky BIT粘着位，也简称为SBIT。SBIT目前仅针对目录有效，它的作用如下： 
	粘着位目前只对目录有效 
	普通用户对该目录拥有w和x权限，即普通用户可以在此目录拥有写入权限 
	如果没有粘着位，因为普通用户拥有w权限，所以可以删除此目录下所有文件，包括其他用户建立的文件。一但赋予了粘着位，除了root可以删除所有文件，普通用户就算拥有w权限，也只能删除自己建立的文件，但是不能删除其他用户建立的文件。 
 
 	4、设定文件特殊权限  特殊权限这样来表示： 
	4代表SUID 
	2代表SGID 
	1代表SBIT 
[root@localhost ~]# chmod 4755 ftest  
#赋予SUID权限 
[root@localhost ~]# chmod 2755 ftest  
#赋予SGID权限 
[root@localhost ~]# mkdir dtest 
[root@localhost ~]# chmod 1755 dtest/ 
#SBIT只对目录有效，所以建立测试目录，并赋予SBIT 
 
四、文件系统属性chattr权限 
1、	命令格式 
[root@localhost ~]# chattr [+-=] [选项] 文件或目录名选项： 
 	+: 增加权限 
 	-: 删除权限 
 =: 等于某权限 i: 如果对文件设置i属性，那么不允许对文件进行删除、改名，也不能添加和修改数  据；如果对目录设置i属性，那么只能修改目录下文件的数据，但不允许建立和删  除文件。   
a: 如果对文件设置a属性，那么只能在文件中增加数据，但是不能删除也不能修改数   据；如果对目录设置a属性，那么只允许在目录中建立和修改文件，但是不允许删   除 
e: Linux中绝大多数的文件都默认拥有e属性。表示该文件是使用ext文件系统进行  存储的，而且不能使用“chattr -e”命令取消e属性。 
 
2、	查看文件系统属性lsattr 
[root@localhost ~]# lsattr 选项 文件名选项： 
 	-a  显示所有文件和目录 
 	-d 若目标是目录，仅列出目录本身的属性，而不是子文件的 
 
 
3、	举例 
例1： 
#给文件赋予i属性 
[root@localhost ~]# touch ftest 
#建立测试文件 
[root@localhost ~]# chattr +i ftest  [root@localhost ~]# rm -rf ftest  rm: 无法删除"ftest": 不允许的操作 
#赋予i属性后，root也不能删除 
[root@localhost ~]# echo 111 >> ftest  
-bash: ftest: 权限不够 
#也不能修改文件的数据 
 
#给目录赋予i属性 
[root@localhost ~]# mkdir dtest 
#建立测试目录 
[root@localhost dtest]# touch dtest/abc 
#再建立一个测试文件abc 
[root@localhost ~]# chattr +i dtest/ 
#给目录赋予i属性 
[root@localhost ~]# cd dtest/ [root@localhost dtest]# touch bcd touch: 无法创建"bcd": 权限不够 
#dtest目录不能新建文件 
[root@localhost dtest]# echo 11 >> abc 
[root@localhost dtest]# cat abc 11 
#但是可以修改文件内容 
[root@localhost dtest]# rm -rf abc rm: 无法删除"abc": 权限不够 
#不能删除 
 
例2： 
[root@localhost ~]# mkdir -p /back/log 
#建立备份目录 
[root@localhost ~]# chattr +a /back/log/ 
#赋予a属性 
[root@localhost ~]# cp /var/log/messages /back/log/ 
#可以复制文件和新建文件到指定目录 
[root@localhost ~]# rm -rf /back/log/messages  rm: 无法删除"/back/log/messages": 不允许的操作 
#但是不允许删除 
 
自测题     
 一、单选题 
 	1、 普通用户可以使用命令sudo的哪个选项查看被授权的命令？ 
A.	-l 
B.	-a 
C.	-m 
D.	-s 
 
 	2、 当一个被授予 SetUID 的命令被普通用户执行时，真正执行命令的有效用户是？ 
A.	root 
B.	命令的所有者 
C.	普通用户 
D.	nobody 用户 
 
 	3、 删除指定用户的ACL权限，应该使用以下哪个选项？ 
A.	-b 
B.	-m 
C.	-x 
D.	-d 
 
 	4、 假设系统默认权限umask值是022，那么建立普通文件时，它的默认权限是： 
A.	755 
B.	644 
C.	666 
D.	777 
 
 
 
 二、操作题 
1、	添加用户 helen ，设置命令 vi（/usr/bin/vim）具有 SetUID 权限，切换到用户 helen用vi编辑/etc/shadow把david用户密码删除，尝试用david本地登录查看效果 
 
2、	添加用户david和helen ，并在Linux中设置只有david可以执行su命令切换为 root（用对文件所属组授权的方式实现） 
 
3、	授权用户helen可以管理apache服务器 
 
4、	使用ACL授权helen对系统目录/var具有读写权限，david具有读写执行权限 
 
5、	用root用户登录Linux ，创建目录/test ，在/test目录下创建文件newfile ，授予/test目录所有用户都有rwx权限，创建普通用户testuser ，切换到testuser执行“rm /test/newfile”是否可以执行；切换回root授予/test目录粘着位SBIT权限，再切换到 testuser执行“rm /test/newfile”是否可以执行？ 
 
 






























 第七章  文件系统管理 
 
一、	硬盘结构 
1、	硬盘的逻辑结构 
  
 每个扇区的大小事固定的，为512Byte。扇区也是磁盘的最小存贮单位。 
  
 硬盘的大小是使用“磁头数×柱面数×扇区数×每个扇区的大小”这样的公式来计算的。其中磁头数（Heads）表示硬盘总共有几个磁头，也可以理解成为硬盘有几个盘面，然后乘以二；柱面数（Cylinders）表示硬盘每一面盘片有几条磁道；扇区数（Sectors）表示每条磁道上有几个扇区；每个扇区的大小一般是512Byte。 
 
2、	硬盘接口 
 
3、	固态硬盘 
  
		固态硬盘和机械硬盘对比 		
对比项目 	固态硬盘 	机械硬盘 
容量 	较小 	大 
读写速度 	极快 	一般 
写入次数 	5000次-10万次 	没有限制 
工作噪音 	极低 	有 
工作温度 	极低 	较高 
防震 	很好 	怕震动 
重量 	低 	高 
价格 	高 	低 
 
二、	文件系统 
	super block（超级块）：记录整个文件系统的信息，包括block与inode的总量，已经使用的inode和block的数量，未使用的inode和block的数量，block 与inode的大小，文件系统的挂载时间，最近一次的写入时间，最近一次的磁盘检验时间等。 
	date block（数据块，也称作block）：用来实际保存数据的（柜子的隔断），block 的大小（1KB、2KB或4KB）和数量在格式化后就已经决定，不能改变，除非重新格式化（制作柜子的时候，隔断大小就已经决定，不能更改，除非重新制作柜子）。每个blcok只能保存一个文件的数据，要是文件数据小于一个block块，那么这个 block的剩余空间不能被其他文件是要；要是文件数据大于一个block块，则占用多个 block 块。Windows 中磁盘碎片整理工具的原理就是把一个文件占用的多个 block块尽量整理到一起，这样可以加快读写速度。 
	inode（i节点，柜子门上的标签）：用来记录文件的权限（r、w、x），文件的所有者和属组，文件的大小，文件的状态改变时间（ctime），文件的最近一次读取时间（atime），文件的最近一次修改时间（mtime），文件的数据真正保存的block编号。
每个文件需要占用一个inode。 
 
三、	常用的硬盘管理命令 
1、	df命令 
[root@localhost ~]# df –ahT 
#-a 显示特殊文件系统，这些文件系统几乎都是保存在内存中的。如/proc，因为是挂载在内存中，所以占用量都是0 
#-h 单位不再只用KB，而是换算成习惯单位 
#-T 多出了文件系统类型一列 
 
2、	du命令 
[root@localhost ~]# du [选项] [目录或文件名] 选项： 
 	-a 显示每个子文件的磁盘占用量。默认只统计子目录的磁盘占用量 
 	-h 使用习惯单位显示磁盘占用量，如KB，MB或GB等  	-s 统计总占用量，而不列出子目录和子文件的占用量 
 du 与df的区别：lsof | grep deleted”查看被删除的文件，然后一个进程一个进程的手工kill也是可以的 
 
3、	fsck文件系统修复命令 
[root@localhost ~]# fsck –y /dev/sdb1 
#自动修复 
 
4、	显示磁盘状态dump2fs 
[root@localhost ~]# dumpe2fs /dev/sda3  dumpe2fs 1.41.12 (17-May-2010) 
Filesystem volume name:   <none> 	 	 卷标名 
Last mounted on:          /  	 	 	 挂载点 
Filesystem UUID:          c2ca6f57-b15c-43ea-bca0-f239083d8bd2 UUID 
Filesystem magic number:  0xEF53 
Filesystem revision #:    1 (dynamic) 
Filesystem features:      has_journal ext_attr resize_inode dir_index filetype needs_recovery extent flex_bg spars 
e_super large_file huge_file uninit_bg dir_nlink extra_isize 
Filesystem flags:         signed_directory_hash  
Default mount options:    user_xattr acl 挂载参数 
Filesystem state:         clean  	 	 文件系统状态，正常 
Errors behavior:          Continue 
Filesystem OS type:       Linux 
Inode count:              1826816  	 inode总数 
Block count:              7300864  	 块总素 
Reserved block count:     365043 
Free blocks:              6634637 
Free inodes:              1753533 
First block:              0 
Block size:               4096  	 	 块大小 
Fragment size:            4096 Reserved GDT blocks:      1022 
Blocks per group:         32768 
Fragments per group:      32768 
Inodes per group:         8192 
Inode blocks per group:   512 
Flex block group size:    16 
Filesystem created:       Mon Nov 12 22:30:41 2012 
Last mount time:          Tue Apr  9 23:53:29 2013 
Last write time:          Mon Nov 12 22:45:55 2012 
Mount count:              3 
Maximum mount count:      -1 
Last checked:             Mon Nov 12 22:30:41 2012 
Check interval:           0 (<none>) 
Lifetime writes:          3199 MB 
Reserved blocks uid:      0 (user root) 
Reserved blocks gid:      0 (group root) 
First inode:              11 
Inode size:               256  	 	 inode的大小 
…省略部分输出… 
 
Group 0: (Blocks 0-32767) [ITABLE_ZEROED] 第一个数据组的内容   校验和 0xcb85,8179个未使用的inode 
  主 superblock at 0, Group descriptors at 1-2   保留的GDT块位于 3-1024 
  Block bitmap at 1025 (+1025), Inode bitmap at 1041 (+1041) 
  Inode表位于 1057-1568 (+1057) 
  23513 free blocks, 8179 free inodes, 2 directories, 8179个未使用的inodes   可用块数: 9255-32767   可用inode数: 14-8192 
…省略部分输出… 
 
5、	查看文件的详细时间  	stat  文件名 	 	 查看文件的详细时间 
例如 
[root@localhost ~]# stat test.sh 
  File: `test.sh'                             
 	#文件名 
  Size: 427             Blocks: 8          IO Block: 4096   regular file 
 	#文件大小  占用块  	 系统分区块大小 
Device: fd00h/64768d    Inode: 23724038    Links: 1 
 	#存放文件的设备 inode号  硬链接数 
Access: (0755/-rwxr-xr-x)  Uid: (    0/    root)   Gid: (  0/  root) 
 权限 	 	 属主 	 	 	    属组 
Access: 2011-10-29 22:27:45.000000000 +0800 
Modify: 2011-09-14 18:02:00.000000000 +0800 
Change: 2011-10-25 22:21:44.000000000 +0800 
 	 	 	access  访问时间 
 	 	 	modify  	数据修改时间 
 	 	 	change  	状态修改时间 
 
 	6、判断文件类型 
 	file  文件名 	 	 	判断文件类型 
 	type  命令名 	 	 	判断命令类型 
 
四、fdisk命令手工分区 
1	fdisk  -l  
 	 查看系统所有硬盘及分区 
 
2	fdisk  /dev/sdb 进行磁盘分区（分区还没有分区号） 
 
		fdisk交互指令说明 	
命令 	说明 
a 	设置可引导标记 
b 	编辑bsd磁盘标签 
c 	设置DOS操作系统兼容标记 
d 	删除一个分区 
l 	显示已知的文件系统类型。82为Linux swap分区，83为Linux分区 
m 	显示帮助菜单 
n 	新建分区 
o 	建立空白DOS分区表 
p 	显示分区列表 
q 	不保存退出 
s 	新建空白SUN磁盘标签 
t 	改变一个分区的系统ID 
u 	改变显示记录单位 
v 	验证分区表 
w 	保存退出 
x 	附加功能（仅专家） 
 
  n---p主----1分区号----1起始柱面-----分区大小+100M-----w   n---e扩展---2分区号---124起始柱面----1024柱面（所有剩余空间都分配给扩展分区） 
 	 	n---l逻辑---不用指定分区号---124起始柱面----+100M(指定大小)-----w 
 
 有时因为系统的分区表正忙，则需要重新启动系统之后才能使新的分区表生效。 
Command (m for help): w  	 	 	 	 	 保存退出 
The partition table has been altered! 
 
Calling ioctl() to re-read partition table. 
 
WARNING: Re-reading the partition table failed with error 16:  
 
 
Device or resource busy. 
The kernel still uses the old table. 
The new table will be used at the next reboot. 要求重启动，才能格式化 Syncing disks. 
 
3	partprobe  强制重读所有分区文件，重新挂载分区文件内所有分区。这不是分区必须命令，如果没有提示重启，可以不执行，也可以重启系统 
 （Warning: Unable to open /dev/hdc read-write (Read-only file system).  
/dev/hdc has been opened read-only. 
 光盘只读挂载，不是错误，不用紧张） 
 如果这个命令不存在请安装parted-2.1-18.el6.i686这个软件包 
 
4	格式化  建立文件系统 	 	ext3是linux默认文件系统 
 	 	mkfs  -t  ext4  /dev/sdb1  	 	mkfs  -t  ext4  /dev/sdb5 
 	mkfs命令非常简单易用，不过是不能调整分区的默认参数的（比如块大小是4096），这些默认参数除非特殊情况，否则不需要调整，如果想要调整就需要使用mke2fs命令进行重新格式化，命令格式如下： 
[root@localhost ~]# mke2fs [选项] 分区设备文件名 
选项： 
 	-t 文件系统： 指定格式化成哪个文件系统，如ext2，ext3，ext4 
 	-b 字节：  指定block块的大小 
 	-i 字节：  指定“字节/inode”的比例，也就是多少个字节分配一个inode 
 	-j： 	 	 建立带有ext3日志功能的文件系统 
 	-L 卷标名：  给文件系统设置卷标名，就不使用e2label命令设定了 
 	 举个例子： 
[root@localhost ~]# mke2fs -t ext4  -b 2048  /dev/sdb6  
#格式化分区，并指定block的大小为2048       
 
5	建立挂载点 
 	 	 	 
 	mkdir  /disk1-----------------/dev/sdb1  把sdb1打算挂载到/disk1目录中  	mkdir  /disk5----------------/dev/sdb5 
 
6	挂载 
 	mount  /dev/sdb1  /disk1  	mount  /dev/sdb5  /disk5 
 
7	查看  	 	 	mount  查看所有已经挂载的分区和光盘  	 	fdisk  -l 查看系统分区 
 	 	 	df  查看分区占用百分比 
 
8	自动挂载 
 	 	 修改分区自动挂载文件 
 
 vi /etc/fstab    注意：此文件直接参与系统启动，如果修改错误，系统启动报错   
 	/dev/sdb1               /disk1                  ext3    defaults        1 2  	 	 第一列： 设备文件名  	 	 第二列  挂载点  	 	 第三列  文件系统  	 	 第四列  挂载选项 
 	 	 第五列  	1 是否可以被备份  	0不备份  	1 每天备份 2 不定期备份 
 	 	 第六列  	2 是否检测磁盘fsck 0不检测  	1启动时检测 2 启动后检测 
 
 也可以使用UUID进行挂载，UUID（硬盘通用唯一识别码，可以理解为硬盘的 ID） 
	这个字段在CentOS 5.5的系统当中是写入分区的卷标名或分区设备文件名的，现在变成了硬盘的 UUID。这样做的好处是当硬盘增加了新的分区，或者分区的顺序改变，再或者内核升级后，任然能够保证分区能够正确的加载，而不至于造成启动障碍 
	那么每个分区的 UUID 到底是什么呢？我们讲过的 dumpe2fs 命令是可以查看到的，命令如下： 
[root@localhost ~]# dumpe2fs /dev/sdb5 
 或 
[root@localhost ~]# ls -l /dev/disk/by-uuid/ 
 
 
 	 	9 重启测试 
 	 或 mount  -a 重新挂载所有内容，用它进行测试 
 
五、	/etc/fstab/文件修复 
 我们重新启动系统吧。苍天啊，大地啊，哪位神仙姐姐显灵了啊，真的报错了，如图
9-16所示： 
  图 9-16 系统启动报错 
 先别哭天抹泪了，仔细看看，他提示你输入root密码啊，好像还有戏啊，我们输入密码试试，如图9-17所示： 
  
图 9-17 root 登陆 
 啊！我们又看到了系统提示符，赶快把/etc/fstab 文件修改回来吧。晕，报错了，如图9-18所示： 
  
9-18 修改/etc/fstab 报错 
 别慌，分析下原因提示是没有写权限，那么只要把/分区重新挂载下，挂载为读写权限不就可以修改了吗？命令如下 
[root@localhost ~]# mount -o remount,rw / 
 再去修改/etc/fstab文件，把它改回来就可以正常启动了啊。 
 
六、	parted命令分区我们Linux系统中有两种常见的分区表MBR分区表（主引导记录分区表）和GPT分区表（GUID分区表），其中： 
	MBR 分区表：支持的最大分区是 2TB（1TB=1024GB）；最多支持 4 个主分区，或 3 个主分区1个扩展分区 
	GPT分区表：支持最大18EB的分区（1EB=1024PB=1024*1024TB）；最多支持128个分区，其中1个系统保留分区，127个用户自定义分区 
 不过parted命令也有点小问题，就是命令自身分区的时候只能格式化成ext2文件系统，不支持ext3文件系统，那就更不用说ext4文件系统了（截止到CentOS 6.3还是这样，这里只是指不能用parted命令把分区格式化成ext4文件系统，但是parted命令还是可以识别ext4文件系统的）。不过这没有太多的影响，因为我们可以先分区再用mkfs进行格式化嘛！ 
 
 
 
 二）建立分区 
1、 查看分区 
(parted) print  	 	 	 	 
#输入print指令                                                             
Model: VMware, VMware Virtual S (scsi)   硬盘参数，是虚拟机啊 
Disk /dev/sdb: 21.5GB  	 	 	 	 	 硬盘大小 
Sector size (logical/physical): 512B/512B  扇区大小 
Partition Table: msdos  	 	 	 	 	 分区表类型，就是MBR分区表 
 
Number  Start   End     Size    Type      File system  标志 
1	32.3kB  5379MB  5379MB  primary 
2	5379MB  21.5GB  16.1GB  extended 
5	5379MB  7534MB  2155MB  logical   ext4 
6	7534MB  9689MB  2155MB  logical   ext4 
#看到了我们使用fdisk分的区，其中1分区没有格式化，2分区是扩展分区不能格式化 
 使用print可以查看分区表信息，包括硬盘参数，硬盘大小，扇区大小，分区表类型和分区信息。分区信息总共七列，分别是： 
	Number：分区号 
	Start：分区起始位置，这里不再像fdisk用柱面表示，而是使用Byte更加直观 
	End：分区结束位置 
	Size：分区大小 
	Type：分区类型 
	File system：文件系统类型。我不是说parted不支持ext4文件系统吗？注意，我一直都是说parted不能直接把分区直接格式化成ext4文件系统，但是它是可以识别的。 
	标志：Flags，就是分区的标记 
 
 	2、修改成GPT分区表 
(parted) mklabel gpt         
#修改分区表命令                                               
警告: 正在使用 /dev/sdb 上的分区。    由于/dev/sdb分区已经挂载，所以有警告  	 	                                注意如果强制修改，原有分区及数据会消失忽略/Ignore/放弃/Cancel? ignore  	  输入ignore忽略报错 
警告: The existing disk label on /dev/sdb will be destroyed and all data on this disk will be lost. Do you want to continue? 
是/Yes/否/No? yes                     输入yes                                      警告: WARNING: the kernel failed to re-read the partition table on /dev/sdb (设备或资源忙).  As a result, it may not reflect all of your changes until after reboot. 	  下次重启后，才能生效 
 
(parted) print                        查看下分区表吧                                     
Model: VMware, VMware Virtual S (scsi) 
Disk /dev/sdb: 21.5GB 
Sector size (logical/physical): 512B/512B 
Partition Table: gpt 	 	  	  分区表已经变成GPT 
 
Number  Start  End  Size  File system  Name  标志 
 	 	 	 	 	 	 	 	   所有的分区都消失了 
修改了分区表，如果这块硬盘已经有分区了，那么原有分区和分区中的数据都会消失，而且需要重启系统才会生效。 
 还有我们转换分区表的目的是为了支持大于2TB的分区，如果分区并没有大于2TB，那么这步是可以不执行的。 
注意：一定要把/etc/fstab文件中和原有分区的内容删除掉，才能重启动。要不系统启动       就一定会报错的。 
 
3、	建立分区  因为修改过了分区表，所以/dev/sdb 中的所有数据都消失了，所以我们可以重新对这块硬盘分区了。不过建立分区时，默认文件系统就只能建立成ext2了，命令如下： 
(parted) mkpart 
#输入创建分区命令，后面不要参数，全部靠交互指定分区名称？  []? disk1           	 分区名称，我起名叫disk1  文件系统类型？  [ext2]?         	 文件系统类型，直接回车，使用默认ext2 起始点？ 1MB                    	 分区从1MB开始     
结束点？ 5GB 	 	 	 	    	 分区到5GB结束 #分区完成 
(parted) print                  查看下吧       
Model: VMware, VMware Virtual S (scsi) 
Disk /dev/sdb: 21.5GB 
Sector size (logical/physical): 512B/512B 
Partition Table: gpt 
 
Number  Start   End     Size    File system  Name  标志 
1      1049kB  5000MB  4999MB               disk1  	 分区1已经出现 
 不知道大家注意到了吗？我们现在的print查看的分区，和第一次查看MBR分区表的分区时有些不一样了，少了Type这个字段，也就是分区类型的字段，多了Name分区名字段。分区类型是标识主分区、扩展分区和逻辑分区的，不过这种标识只在MBR分区表中使用，我们现在已经变成了GPT分区表了，所以就不再有Type类型了。也就说折磨我们很久的主分区、扩展分区和逻辑分区的概念不再有用了，阿门！ 
 	 
4、	建立文件系统  分区分完了，我们还需要格式化。不过我们已经知道如果使用parted交互命令格式化的话，只能格式化成ext2文件系统。我们这里是要演示下parted命令的格式化方法，所以就格式化成ext2吧，命令如下： 
(parted) mkfs    
#格式化命令（很奇怪也是mkfs，但是这只是parted的交互命令）                                               WARNING: you are attempting to use parted to operate on (mkfs) a file system. parted's file system manipulation code is not as robust as what you'll find in dedicated, file-system-specific packages like e2fsprogs.  We recommend you use parted only to manipulate partition tables, whenever possible. Support for performing most operations on most types of file systems will be removed in an upcoming release. 
警告: The existing file system will be destroyed and all data on the partition will be lost. Do you want to continue? 
是/Yes/否/No? yes             警告你格式化数据会丢失，没关系，已经丢失过了                  
分区编号？ 1                                                               
文件系统类型？  [ext2]?        	 指定文件系统类型，写别的也没有用，直接回车    
                                           
(parted) print                  格式化完成，查看下                                        
Model: VMware, VMware Virtual S (scsi) 
Disk /dev/sdb: 21.5GB 
Sector size (logical/physical): 512B/512B 
Partition Table: gpt 
 
Number  Start   End     Size    File system  Name   标志 
 1      1049kB  5000MB  4999MB  ext2         disk1  	 拥有了文件系统 
 如果要格式化成ext4文件系统，请mkfs命令帮忙吧（注意不是parted交互命令中的 mkfs，而是系统命令mkfs）！ 
 
5、	调整分区大小  	parted命令还有一大优势，就是可以调整分区的大小（windows中也可以实现，不过要不需要转换成动态磁盘，要不需要依赖第三方工具，如硬盘分区魔术师）。起始Linux中LVM 和RAID是可以支持分区调整的，不过这两种方法也可以看成是动态磁盘方法，我们在下一个章节中介绍。使用parted命令调整分区要更加简单。 
	注意：parted调整已经挂载使用的分区时，是不会影响分区中的数据的，也就是说数据不       会丢失。但是一定要先卸载分区，再调整分区大小，否则数据是会出现问题的。还有       要调整大小的分区必须已经建立了文件系统（格式化），否则会报错 	 
 命令如下： 
(parted) resize 
分区编号？ 1                         指定要修改的分区编号  起始点？  [1049kB]? 1MB              分区起始位置   结束点？  [5000MB]? 6GB              分区结束位置    
(parted) print                       查看下                                        
Model: VMware, VMware Virtual S (scsi) 
Disk /dev/sdb: 21.5GB 
Sector size (logical/physical): 512B/512B 
Partition Table: gpt 
 
Number  Start   End     Size    File system  Name   标志 
 1      1049kB  6000MB  5999MB  ext2         disk1           分区大小改变 
 
6、	删除分区 
(parted) rm  
#删除分区命令                                                               分区编号？ 1                          指定分区号                                      
(parted) print                        查看下                                      
Model: VMware, VMware Virtual S (scsi) 
Disk /dev/sdb: 21.5GB 
Sector size (logical/physical): 512B/512B 
Partition Table: gpt 
 
Number  Start  End  Size  File system  Name  标志 	 	 	 	分区消失 
 还有件事要注意，parted 中所有的操作都是立即生效，没有保存生效的概念。这点和 fdisk交互命令明显不同，所以所做的所有操作大家要倍加小心。 
 那么到底使用fdisk进行分区？还是parted命令呢？这个完全看个人习惯，我们更加习惯fdisk命令。 
 
七、分配swap分区 
 
1、	分区，并修改为swap分区ID 
[root@localhost ~]# fdisk /dev/sdb 
#拿/dev/sdb分区 
Command (m for help): t  	 	 	 	 修改分区的系统ID 
Selected partition 1 	 	 	   只有一个分区，所以不用选择分区了 
Hex code (type L to list codes): 82  g	 改为swap的ID 
Changed system type of partition 1 to 82 (Linux swap / Solaris) 
 
2、	格式化 
[root@localhost ~]# mkswap /dev/sdb1  
Setting up swapspace version 1, size = 522076 KiB no label, UUID=c3351dc3-f403-419a-9666-c24615e170fb 
 	9.8.3 使用swap分区  在使用swap分区之前，我们先来说说free命令，命令如下： 
[root@localhost ~]# free  
             total       used       free     shared    buffers     cached Mem:       1030796     130792     900004          0      15292      55420 
-/+ buffers/cache:      60080     970716 Swap:      2047992          0    2047992 
 
[root@localhost ~]# swapon 分区设备文件名 
 
例： 
[root@localhost ~]# swapon /dev/sdb1 
 让swap分区开机之后自动挂载 
/dev/sdb1        	 	swap                    swap    defaults        0 0 
#加入新swap分区的相关内容，我这里是直接使用的分区的设备文件名，大家当然也可以 #使用UUID号了。 
 
自测题     
 	  一、操作题 
1、	查看根分区空间使用情况；统计/usr/local目录的大小；查看文件/etc/fstab的时间属性。 
 
2、	我们在虚拟机中添加一块新的10G的硬盘，并划分其中的8GB空间给/soft目录。这个目录给用户组tgroup使用，其他用户不能具有任何权限，并保证这个分区在Linux启动时自动挂载。 
 
3、	继续使用刚刚在虚拟机中新添加的硬盘，再划分一个512M的swap分区，并设置为
Linux启动时自动挂载分区。 
 
 
 

 
 















7.28\
高级文件系统管理   

总结：限制普通用户在指定分区上使用的硬盘空间和文件个数
     用户配额和组配额
     磁盘空间限制和文件个数限制
     软限制和硬限制
     宽限时间   默认7天
SELinux   CIA和Redhat
     关闭：  vi /etc/selinux/config
             Selinux=enforcing 改为Selinux=disabled
      reboot
      DEBUG   调试
      
一、磁盘配额 
1、	磁盘配额概念 
    限制普通用户在指定分区上使用的硬盘空间和文件个数
2、	磁盘配额条件 
	内核必须支持磁盘配额 
[root@localhost ~]# grep CONFIG_QUOTA /boot/config-2.6.32-279.el6.i686 
CONFIG_QUOTA=y 
CONFIG_QUOTA_NETLINK_INTERFACE=y 
# CONFIG_QUOTA_DEBUG is not set 
CONFIG_QUOTA_TREE=y 
CONFIG_QUOTACTL=y 
	系统中必须安装了quota工具，我们的Linux默认是安装了quota工具的，查看命令如下 
[root@localhost ~]# rpm -qa | grep quota quota-3.17-16.el6.i686 
 要支持磁盘配额的分区必须开启磁盘配额功能，这个功能需要手工开启，不再是默认就开启的 
 
3、	概念 
1）	用户配额和组配额 
2）	磁盘容量限制和文件个数限制 
3）	软限制和硬限制 
用户配额用的较多，组配额利用“先到先得”原则，如果一个用户把配额全部使用，组中的其他的用户就没空间可用了
4）	宽限时间  如果用户的空间占用数处于软限制和硬限制之间，统会在用户登陆时警告用户磁盘将满，，这个时间就是宽限时间，默认是7天。如果达到了宽限时间，用户的磁盘占用量还超过软限制，那么软限制就会升级为硬限制。 
 
4、	磁盘配额规划 
 我们开始磁盘配额实验，首先我们来规划下我们的实验： 
	磁盘配额是限制的普通用户在分区上使用磁盘空间和文件个数的，所以我们需要指定一个分区。那么我们手工建立一个5GB的/dev/sdb1分区，把它挂载到/disk目录当中。 
	还有我们需要建立被限制的用户和用户组。那么我们假设需要限制 lamp1、lamp2 和lamp3用户，这三个用户属于brother用户组。 
	其中brother组磁盘容量硬限制为500MB，软限制450MB，文件个数不做限制。lamp1 用户为了便于测试，磁盘容量硬限制为50MB，软限制为40MB，文件个数硬限制限制为10个，软限制为8个。lamp2和lamp3用户磁盘容量硬限制为250MB，软限制为200MB，文件个数不做限制。 
	大家发现 lamp1、lamp2 和 lamp3 用户加起来的磁盘容量限制为 550MB，超过了 brother组的磁盘容量限制500MB。这样的话，某个用户可能达不到自己的用户限制，而达到组限制时就不能再写入数据了。也就是说，如果用户限制和组限制同时存在，那么哪个限制更小，哪个限制优先生效。 
	系统宽限时间我们改为8天。 
 
5、	磁盘配额步骤 
1）	分500MB的/dev/sdb1分区，并将它挂载到/disk目录当中 
 
2）	建立需要做限制的用户和用户组 
[root@localhost ~]# groupadd brother 
[root@localhost ~]# useradd -G brother lamp1 
[root@localhost ~]# useradd -G brother lamp2 
[root@localhost ~]# useradd -G brother lamp3 
[root@localhost ~]# passwd lamp1 [root@localhost ~]# passwd lamp2 
[root@localhost ~]# passwd lamp3 
 
3）	、在分区上开启磁盘配额功能 
[root@localhost ~]# mount -o remount,usrquota,grpquota /disk 
#重新挂载/disk分区，并加入用户和用户组的磁盘配额功能 
 
 我们要想永久生效，则需要修改/etc/fstab文件，改成： 
[root@localhost ~]# vi /etc/fstab 
/dev/sdb1    /disk       ext4    defaults,usrquota,grpquota      0 0 
…省略部分输出… 
[root@localhost ~]# mount –o remount /disk 
#修改配置文件如果想要生效，必须重启系统，否则也需要把分区重新挂载一遍。 
 
4）	、建立磁盘配额的配置文件   
[root@localhost ~]# quotacheck [选项] [分区名] 选项： 
 	-a：扫描/etc/mtab文件中所有启用磁盘配额功能的分区。如果加入此参数，命令后面  	 就不需要加入分区名了 
 	-c：不管原有的配置文件，重新扫描并建立新的配置文件 
 	-u：建立用户配额的配置文件，也就是生成aquota.user文件 
 	-g：建立组配额的配置文件，会生成aquota.group文件 
 	-v：显示扫描过程 
 	-m：强制以读写的方式扫描文件系统，和-M类似。一般扫描根分区时使用。 
 	-f：强制扫描文件系统，并写入新的配置文件。一般扫描新添加的硬盘分区时使用 
 
[root@localhost ~]# quotacheck -avug 
 需要关闭SELinux，否则会报错 
 
[root@localhost ~]# ll /disk/ 
总用量 24 
-rw------- 1 root root  6144 4月  17 01:08 aquota.group 
-rw------- 1 root root  6144 4月  17 01:08 aquota.user 
#/disk目录中两个配额配置文件已经建立 
 
 如果需要给根分区开启配额功能，需要： 
[root@localhost ~]# vi /etc/fstab 
UUID=c2ca6f57-b15c-43ea-bca0-f239083d8bd2 / ext4 defaults,usrquota,grpquota        1 1 
#开启/分区的配额功能 
[root@localhost ~]# mount -o remount / 
#重新挂载/分区 
[root@localhost ~]# quotacheck -avugm 
 如果我们自动扫描/分区建立配额配置文件时，因为/分区已经挂载成读写系统，而 quotacheck 需要把分区先挂载成只读分区，然后建立配置文件，最后再挂载回来，所以不能直接在/分区建立配置文件。这时就需要使用-m强制以读写方式扫描文件系统了 
 
 	5）、 设置用户和组的配额限制 
[root@localhost ~]# edquota [选项] [用户名或组名] 选项： 
 	-u 用户名： 设定用户配额 
 	-g 组名： 设定组配额 
 	-t： 	 设定宽限时间 
 	-p： 	 复制配额限制。如果已经设定好某个用户的配额限制，其他用户的配额限  	 	 	 制如果和这个用户相同，那么可以直接复制配额限制，而不用都手工指定
 我们给lamp1用户设定的配额限制是：磁盘空间软限制是40MB，硬限制是50MB；文件个数的软限制是8个，硬限制是10个（稍微小一点，一会测试时方便测试）。命令如下： 
[root@localhost ~]# edquota -u lamp1 
#edquota命令进入之后，就是标准的vi操作方法 
Disk quotas for user lamp1 (uid 500): 
#磁盘配额是设定用户lamp1（UID是500） 
  Filesystem          blocks       soft       hard     inodes     soft     hard 
  /dev/sdb1             0          0          0          0        0        0 
#分区名     已占用容量  软限制  硬限制 已占用文件数  软限制   硬限制 
 	 
 	Disk quotas for user lamp1 (uid 500): 
  Filesystem         blocks       soft       hard     inodes     soft     hard 
  /dev/sdb1             0      40000       50000          0        8        10 
#不用对齐，是七列就行 
 
 再给lamp2用户配置限额，lamp2用户要求是空间软限制250MB，硬限制250MB，文件个数不做限制： 
[root@localhost ~]# edquota -u lamp2 
Disk quotas for user lamp2 (uid 501): 
  Filesystem         blocks       soft       hard     inodes     soft     hard   /dev/sdb1      0          250000          300000          0        0        0 
 接下来给brother组配置限额，brother组要求是空间软限制是450MB，硬限制500MB，文件个数不做限制： 
[root@localhost ~]# edquota -g brother 
Disk quotas for group brother (gid 500): 
  Filesystem         blocks       soft       hard     inodes     soft     hard 
  /dev/sdb1      0          450000          500000          0        0        0 
 
6）	、 配额复制  	lamp3用户的配额值和lamp2用户完全一样，我们就可以使用lamp2用户作为模板进行复制。这样我们如果需要建立大量的配额值一致的用户时，就会非常方便，不用一个个手工建立了。复制命令如下： 
[root@localhost ~]# edquota -p lamp2 -u lamp3 
#命令  -p  源用户  -u  目标用户 
 
7）	、修改宽限时间  我们要求把宽限时间改为8天，修改命令如下： 
[root@localhost ~]# edquota –t 
Grace period before enforcing soft limits for users: 
Time units may be: days, hours, minutes, or seconds 
  Filesystem             Block grace period     Inode grace period 
  /dev/sdb1                     8days                  8days 
#分区名     容量的宽限时间   个数的宽限时间 
 
8）	、启动和关闭配额  配额的配置完成，接下来只需要启动配额就大功告成了，启动命令如下： 
[root@localhost ~]# quotaon [选项] [分区名] 
选项： 
 	-a：依据/etc/mtab文件启动所有的配额分区。如果不加-a，后面就一定要指定分区名 
 	-u：启动用户配额 
 	-g：启动组配额 
 	-v：显示启动过程的信息 
 
[root@localhost ~]# quotaon -vug /disk/  
/dev/sdb1 [/disk]: group quotas turned on 
/dev/sdb1 [/disk]: user quotas turned on 
#启动/disk分区的配额 
 
[root@localhost ~]# quotaon –avug 
#这条命令也可以 
 关闭配额的命令如下： 
[root@localhost ~]# quotaoff [选项] [分区名] 
选项 
 	-a：依据/etc/mtab文件关闭所有的配额分区。如果不加-a，后面就一定要指定分区名 
 	-u：关闭用户配额 
 	-g：关闭组配额 
 
[root@localhost ~]# quotaoff –a 
#依据/etc/mtab文件关闭配额分区 
 
 	6、磁盘配额查询 
	quota查询用户或用户组配额： 
[root@localhost ~]# quota [选项] [用户名或组名] 
选项： 
 	-u 用户名： 查询用户配额  	-g 组名： 查询组配额 
 	-v： 	 显示详细信息 
 	-s： 	 以习惯单位显示容量大小，如M，G 
 
[root@localhost ~]# quota -uvs lamp1 
 
	repquota查询文件系统配额 
[root@localhost ~]# repquota [选项] [分区名] 
选项： 
 	-a： 依据/etc/mtab文件查询配额。如果不加-a选项，就一定要加分区名 
 	-u： 查询用户配额 
 	-g： 查询组配额 
 	-v： 显示详细信息 
 	-s： 以习惯单位显示容量大小 
 
[root@localhost ~]# repquota –augvs 
 
7、	测试 
[lamp1@localhost disk]$ dd if=/dev/zero of=/disk/testfile bs=1M count=60 
#建立testfile文件，指定大小60MB 
 
8、	非交互设定用户磁盘配额 
[root@localhost ~]# setquota -u 用户名 容量软限制 容量硬限制 个数软限制  \ 
个数硬限制 分区名 
[root@localhost ~]# useradd lamp4 
[root@localhost ~]# passwd lamp4 
#建立用户 
[root@localhost ~]# setquota -u lamp4 10000 20000 5 8 /disk 
#设定用户在/disk分区的容量软限制为10MB，硬限制20MB。文件个数软限制5个，硬限制#8个。 
 这个命令在写脚本批量设置时更加方便。当然写脚本时也可以先建立一个模板的用户，设定好磁盘配额，再进行配额复制，也是可以的。 
 
二、LVM逻辑卷管理 
1、	简介 
 	LVM是Logical Volume Manager的简称，中文就是逻辑卷管理。 
  
图10-1 LVM示意图 
	物理卷（PV，Physical Volume）：就是真正的物理硬盘或分区。  
	卷组（VG，Volume Group）：将多个物理卷合起来就组成了卷组，组成同一个卷组的物理卷可以是同一个硬盘的不同分区，也可以是不同硬盘上的不同分区。我们可以把卷组想象为一个逻辑硬盘。 
	逻辑卷（LV，Logical Volume）：卷组是一个逻辑硬盘，硬盘必须分区之后才能使用，这个分区我们称作逻辑卷。逻辑卷可以格式化和写入数据。我们可以把逻辑卷想象成为分区。 
	物理扩展（PE，Physical Extend）：PE 是用来保存数据的最小单元，我们的数据实际上都是写入PE当中，PE的大小是可以配置的，默认是4KB。PE和基本文件系统中的block数据块非常类似。 
 
2、	建立LVM的步骤： 
	首先需要把物理硬盘分成分区，当然也可以是整块物理硬盘。 
	然后把物理分区建立成为物理卷（PV），也可以直接把整块硬盘都建立为物理卷。 
	接下来把物理卷整合成为卷组（VG）。卷组就已经可以动态的调整大小了，可以把物理分区加入卷组，也可以把物理分区从卷组中删除。 
	最后就是把卷组再划分成为逻辑卷（LV），当然逻辑卷也是可以直接调整大小的。
我们说逻辑卷可以想象成为分区，所以也需要格式化和挂载。 
 
3、	物理卷管理 
1）	、硬盘分区 
 创建方式就是使用fdisk交互命令，不过需要注意的是分区的系统ID不再是Linux默认的分区ID号83了，而要改成LVM的ID号8e。 
 
2）	、建立物理卷 
[root@localhost ~]# pvcreate [设备文件名] 
 建立物理卷时，我们说即可以把整块硬盘都建立成物理卷，也可以把某个分区建立成物理卷。如果要把整块硬盘都建立成物理卷，命令如下 
[root@localhost ~]# pvcreate /dev/sdb  在我们的使用中，是要把分区建立成为物理卷，所以执行以下命令： 
[root@localhost ~]# pvcreate /dev/sdb5 
 
3）	查看物理卷 
[root@localhost ~]# pvscan  
  PV /dev/sdb5                      lvm2 [1.01 GiB] 
  PV /dev/sdb6                      lvm2 [1.01 GiB] 
  PV /dev/sdb7                      lvm2 [1.01 GiB] 
  Total: 3 [3.03 GiB] / in use: 0 [0   ] / in no VG: 3 [3.03 GiB] 
 我们可以看到在我的系统中，/dev/sdb5-7 这三个分区是物理卷。最后一行的意思是：总共3个物理卷[大小] / 使用了0个卷[大小] / 空闲3个卷[大小]。 
 第二个查询命令是pvdisplay，它可以查看到更详细的物理卷状态，命令如下： 
[root@localhost ~]# pvdisplay  
  "/dev/sdb5" is a new physical volume of "1.01 GiB" 
  --- NEW Physical volume --- 
  PV Name               /dev/sdb5 PV名 
  VG Name                	 	 属于的VG名，还没有分配，所以空白 
  PV Size               1.01 GiB PV的大小 
  Allocatable           NO  	 是否已经分配 
  PE Size               0    	 PE大小，因为还没有分配，所以PE大小也没有指定 
  Total PE              0  	 PE总数 
  Free PE               0  	 空闲PE数 
  Allocated PE          0  	 可分配的PE数 
  PV UUID               CEsVz3-f0sD-e1w0-wkHZ-iaLq-O6aV-xtQNTB PV的UUID 
 
 	4）删除物理卷 
[root@localhost ~]# pvremove /dev/sdb7 
 
 	4、卷组管理 
 	1）建立卷组 
[root@localhost ~]# vgcreate [选项] 卷组名 物理卷名 
选项： 
 	-s PE大小：指定PE的大小，单位可以是MB,GB,TB等。如果不写默认PE大小事4MB 
 我们又三个物理卷/dev/sdb5-7，我们先把/dev/sdb5 和/dev/sdb6 加入卷组，留着
/dev/sdb7一会实验调整卷组大小，命令如下： 
[root@localhost ~]# vgcreate -s 8MB scvg /dev/sdb5 /dev/sdb6 
  Volume group "scvg" successfully created 
 
2）	、查看卷组查看卷组的命令同样是两个，vgscan 主要是查看系统中是否有卷组，而 vgdisplay 则是查看卷组的详细状态的。命令如下： 
[root@localhost ~]# vgscan  
  Reading all physical volumes.  This may take a while... 
  Found volume group "scvg" using metadata type lvm2 
#scvg的卷组确实存在 
 
[root@localhost ~]# vgdisplay  
  --- Volume group --- 
  VG Name               scvg 	 	 	 卷组名 
  System ID              
  Format                lvm2 
  Metadata Areas        2   Metadata Sequence No  1 
  VG Access             read/write  	 卷组访问状态 
  VG Status             resizable  	 卷组状态 
  MAX LV                0  	 	 	 最大逻辑卷数 
  Cur LV                0   Open LV               0 
  Max PV                0  	 	 	 最大物理卷数 
  Cur PV                2  	 	 	 当前物理卷数 
  Act PV                2 
  VG Size               2.02 GiB 	 	 卷组大小 
  PE Size               8.00 MiB 	 	 PE大小 
  Total PE              258  	 	 	 PE总数 
  Alloc PE / Size       0 / 0    	 	 已用PE数量/大小 
  Free  PE / Size       258 / 2.02 GiB  空闲PE数量/大小 
  VG UUID               Fs0dPf-LV7H-0Ir3-rthA-3UxC-LX5c-FLFriJ 
 
3）	、增加卷组容量 
[root@localhost ~]# vgextend scvg /dev/sdb7    Volume group "scvg" successfully extended 
#把/dev/sdb7物理卷也加入scvg卷组 
[root@localhost ~]# vgdisplay  
  --- Volume group --- 
  VG Name               scvg   System ID              
  Format                lvm2 
  Metadata Areas        3   Metadata Sequence No  2 
  VG Access             read/write 
  VG Status             resizable 
  MAX LV                0 
  Cur LV                0   Open LV               0   Max PV                0 
  Cur PV                3 
  Act PV                3 
  VG Size               3.02 GiB 	 	 卷组容量增加 
  PE Size               8.00 MiB 
  Total PE              387  	 	 	 PE总数增加 
  Alloc PE / Size       0 / 0    
  Free  PE / Size       387 / 3.02 GiB 
  VG UUID               Fs0dPf-LV7H-0Ir3-rthA-3UxC-LX5c-FLFriJ 
 
4）	、减小卷组容量 
[root@localhost ~]# vgreduce scvg /dev/sdb7  
  Removed "/dev/sdb7" from volume group "scvg" 
#在卷组中删除/dev/sdb7物理卷 
 
[root@localhost ~]# vgreduce -a 
#删除所有的未使用物理卷 
 
5）	、删除卷组 
[root@localhost ~]#  vgremove scvg 
  Volume group "scvg" successfully removed 
 卷组删除之后，才能删除删除物理卷。还要注意的是scvg卷组还没有添加任何的逻辑卷，那如果拥有了逻辑卷，记得先删除逻辑卷再删除卷组。还记得我刚说的吗？删除就是安装的反过程，每一步都不能跳过。 
 
 	5、逻辑卷管理  	1）、建立逻辑卷 
[root@localhost ~]# lvcreate [选项] [-n 逻辑卷名] 卷组名选项： 
 	-L 容量：指定逻辑卷大小，单位MB，GB，TB等 
 	-l 个数：按照PE个数指定逻辑卷大小，这个参数需要换算容量，太麻烦 
 	-n 逻辑卷名：指定逻辑卷名 
 那我们就建立一个1.5GB的lamplv逻辑卷吧，建立命令如下： 
[root@localhost ~]# lvcreate -L 1.5G -n lamplv scvg   Logical volume "lamplv" created 
#在scvg卷组中建立1.5GB的lamplv逻辑卷 
 建立完逻辑卷之后，还要格式化和挂载之后逻辑卷才能正常使用。格式化和挂载命令和操作普通分区时是一样的，不过需要注意的是逻辑卷的设备文件名是/dev/卷组名/逻辑卷名，如我们的lamplv的设备文件名就是“/dev/scvg/lamplv”,具体命令如下： 
[root@localhost ~]# mkfs -t ext4 /dev/scvg/lamplv 
#格式化 
[root@localhost ~]# mkdir /disklvm 
[root@localhost ~]# mount /dev/scvg/lamplv /disklvm/ 
#建立挂载点，并挂载 
[root@localhost ~]# mount  
…省略部分输出… 
/dev/mapper/scvg-lamplv on /disklvm type ext4 (rw) 
#已经挂载了 
 当然如果需要开机自动挂载，也要修改/etc/fstab文件。 
 
 	2）、查看逻辑卷同样的查看命令是两个，第一个命令lvscan只能看到系统中是否拥有逻辑卷，命令如下： 
[root@localhost ~]# lvscan  
  ACTIVE            '/dev/scvg/lamplv' [1.50 GiB] inherit 
#能够看到激活的逻辑卷，大小事1.5GB 
 第二个命令是lvdisplay可以看到逻辑卷的详细信息，命令如下： 
[root@localhost ~]# lvdisplay  
  --- Logical volume --- 
  LV Path                /dev/scvg/lamplv  逻辑卷设备文件名 
  LV Name                lamplv  	 	 	 逻辑卷名 
  VG Name                scvg  	 	 	 所属的卷组名 
  LV UUID                2kyKmn-Nupd-CldB-8ngY-NsI3-b8hV-QeUuna 
  LV Write Access        read/write 
  LV Creation host, time localhost, 2013-04-18 03:36:39 +0800 
  LV Status              available 
  # open                 1 
  LV Size                1.50 GiB  	 	 逻辑卷大小 
  Current LE             192 
  Segments               2 
  Allocation             inherit 
  Read ahead sectors     auto 
  - currently set to     256 
  Block device           253:0 
 
 	3）调整逻辑卷大小 
[root@localhost ~]# lvresize [选项] 逻辑卷设备文件名选项： 
 	-L 容量：安装容量调整大小，单位KB，GB,TB等。使用+代表增加空间，-号代表减少  	 	 	 空间。如果直接写容量，代表设定逻辑卷大小为指定大小。 
 	-l 个数：按照PE个数调整逻辑卷大小 
 我们先在/disklvm中建立点文件，一会调整完大小，我们看看数据是否会丢失： 
[root@localhost ~]# cd /disklvm/ 
[root@localhost disklvm]# touch testf [root@localhost disklvm]# mkdir testd [root@localhost disklvm]# ls lost+found  testd  testf 
 我们刚刚的lamplv的大小事1.5GB，我们的scvg中还有1.5GB的空闲空间，那么增加
我们的lamplv逻辑卷的大小到2.5GB吧： 
[root@localhost disklvm]# lvresize -L 2.5G /dev/scvg/lamplv  
  Extending logical volume lamplv to 2.50 GiB   Logical volume lamplv successfully resized 
#增加lamplv逻辑卷的大小到2.5GB 
#当然命令也可以这样写 [root@localhost disklvm]# lvresize -L +1G /dev/scvg/lamplv 
 
[root@localhost disklvm]# lvdisplay  
  --- Logical volume --- 
  LV Path                /dev/scvg/lamplv 
  LV Name                lamplv 
  VG Name                scvg 
  LV UUID                2kyKmn-Nupd-CldB-8ngY-NsI3-b8hV-QeUuna 
  LV Write Access        read/write 
  LV Creation host, time localhost, 2013-04-18 03:36:39 +0800 
  LV Status              available 
  # open                 1 
  LV Size                2.50 GiB  	 大小改变了 
  Current LE             320 
  Segments               3 
  Allocation             inherit 
  Read ahead sectors     auto 
  - currently set to     256 
  Block device           253:0 
 逻辑卷的大小已经改变了，但是好像有些问题啊： 
[root@localhost disklvm]# df -h /disklvm/ 
文件系统              容量  已用  可用 已用%% 挂载点 
/dev/mapper/scvg-lamplv  1.5G   35M  1.4G   3% /disklvm  
 怎么/disklvm 分区的大小还是 1.5GB 啊？刚刚只是逻辑卷的大小改变了，如果需要让分区使用这个新逻辑卷，我们还要使用resize2fs命令来调整分区的大小。不过这里就体现了LVM的优势，我们不需要卸载分区，直接就能调整分区的大小。resize2fs命令如下： 
[root@localhost ~]# resize2fs [选项] [设备文件名] [调整的大小] 选项： 
 	-f： 强制调整  设备文件名：指定调整哪个分区的大小 
 调整的大小：指定把分区调整到多大，要加M，G等单位。如果不加大小，会使用整个  	 	 	 分区 
 那么我们已经把逻辑卷调整到了2.5GB，这时我们就需要把整个逻辑卷都加入/disklvm 分区，命令如下： 
[root@localhost ~]# resize2fs /dev/scvg/lamplv  resize2fs 1.41.12 (17-May-2010) 
Filesystem at /dev/scvg/lamplv is mounted on /disklvm; on-line resizing required old desc_blocks = 1, new_desc_blocks = 1 
Performing an on-line resize of /dev/scvg/lamplv to 655360 (4k) blocks. 
The filesystem on /dev/scvg/lamplv is now 655360 blocks long. 
#已经调整了分区大小 
 
[root@localhost ~]# df -h /disklvm/ 
文件系统              容量  已用  可用 已用%% 挂载点 
/dev/mapper/scvg-lamplv  2.5G   35M  2.4G   2% /disklvm 
#分区大小已经是2.5GB了 
[root@localhost ~]# ls /disklvm/ lost+found  testd  testf 
#而且数据并没有丢失 
 
 	4）删除逻辑卷 
[root@localhost ~]# lvremove 逻辑卷设备文件名 
 我们删除lamplv这个逻辑卷，记得删除时要先卸载。命令如下： 
[root@localhost ~]# umount /dev/scvg/lamplv  
[root@localhost ~]# lvremove /dev/scvg/lamplv  
 
三、RAID磁盘整列 
 
1、	简介 
1）	、RAID 0 
 	RAID 0也叫Stripe或Striping（带区卷） 
2）	、RAID 1 
 	RAID 1也叫Mirror或Mirroring（镜像卷），由两块硬盘组成 
3）	、RAID 10或RAID 01 
 如果我们先用两块硬盘组成RAID 1，再用两块硬盘组成另一个RAID 1，最后把这两个
RAID 1组成RAID 0，这种RAID方法我们就称作RAID 10。那先组成RAID 0，再组成RAID 1 的方法我们就称作RAID 01。 
4）	、RAID 5 
 	RAID 5最少需要三块硬盘组成，当然硬盘的大小也应当一致。 
 
2、	命令模式设置RAID 5 
1）	、建立三个2GB的分区和一个2GB的备份分区 
 
2）	、建立RAID 5 
[root@localhost ~]# mdadm [模式] [RAID设备文件名] [选项] 模式： 
 	Assemble：加入一个已经存在的阵列 
 	Build：创建一个没有超级块的阵列 
 	Create：创建一个阵列，每个设备具有超级块 
 	Manage：管理阵列，如添加设备和删除损坏设备 
 	Misc：允许单独对阵列中的设备进行操作，如停止阵列 
 	Follow or Monitor：监控RAID状态  	Grow：改变RAID的容量或阵列中的数目选项： 
 	-s，--scan：扫描配置文件或/proc/mdstat文件，发现丢失的信息 
 	-D，--detail：查看磁盘阵列详细信息 
 	-C，--create:建立新的磁盘阵列，就是调用Create模式。 
 	-a，--auto=yes：采用标准格式建立磁盘阵列 
 	-n，--raid-devices=数字：使用几个硬盘或分区组成RAID 
 	-l，--level=级别：创建RAID的级别，可以是0,1,5 
 	-x，--spare-devices=数字：使用几个硬盘或分区组成备份设备 
 	-a，--add 设备文件名：在已经存在的RAID中加入设备 
 	-r，--remove 设备文件名名：在已经存在的RAID中移除设备 
 	-f，--fail 设备文件名：把某个组成RAID的设备设置为错误状态 
 	-S，--stop：停止RAID设备 
 	-A，--assemble：按照配置文件加载RAID 
 我们准备创建的是RAID 5，那么使用以下命令创建： 
[root@localhost ~]# mdadm --create --auto=yes /dev/md0 --level=5  \ 
--raid-devices=3 --spare-devices=1 /dev/sdb5 /dev/sdb6 /dev/sdb7 /dev/sdb8   
 
 查看一下新建立的/dev/md0吧，命令如下： 
[root@localhost ~]# mdadm --detail /dev/md0 
/dev/md0:  	 	 	 	 	 	 	 	 设备文件名 
        Version : 1.2 
  Creation Time : Tue Apr 23 23:13:48 2013  创建时间 
     Raid Level : raid5  	 	 	 	 	 RAID级别 
     Array Size : 4206592 (4.01 GiB 4.31 GB) RAID总容量 
  Used Dev Size : 2103296 (2.01 GiB 2.15 GB) 每个分区的容量 
   Raid Devices : 3  	 	 	 	 	 	 组成RAID的设备数 
  Total Devices : 4  	 	 	 	 	 	 总设备数 
    Persistence : Superblock is persistent  
    Update Time : Tue Apr 23 23:14:52 2013 
          State : clean  
 Active Devices : 3  	 	 	 	 	 	 激活的设备数 
Working Devices : 4  	 	 	 	 	 	 可用的设备数  	 
 Failed Devices : 0  	 	 	 	 	 	 错误的设备数 
  Spare Devices : 1  	 	 	 	 	 	 备份设备数 
 
         Layout : left-symmetric 
     Chunk Size : 512K 
 
           Name : localhost.localdomain:0  (local to host localhost.localdomain) 
           UUID : 15026b78:126a4930:89d8cf54:5bcb7e95 
         Events : 18 
 
    Number   Major   Minor   RaidDevice State 
0	8       21        0      active sync   /dev/sdb5 
1	8       22        1      active sync   /dev/sdb6 
       4       8       23        2      active sync   /dev/sdb7 
 #三个激活的分区 
 
       3       8       24        -      spare   /dev/sdb8 
 #分别的分区 
 
 查看 RAID 设备除了可以使用命令 mdadm –D 或 mdadm –detail 之外，也可以查看 /proc/mdstat文件，这个文件中也保存了RAID的相关信息。命令如下： 
[root@localhost ~]# cat /proc/mdstat  Personalities : [raid6] [raid5] [raid4]  
md0 : active raid5 sdb9[4](S) sdb5[0] sdb8[3] sdb6[1] 
#raid名    级别  组成RAID的分区，[数字]是此分区在RAID中顺序， 
#(S)代表备份分区 
      4206592 blocks super 1.2 level 5, 512k chunk, algorithm 2 [3/3] [UUU] 
# 总block数    等级是5   区块大小 阵列算法  [组成设备数/正常设备数] unused devices: <none> 
 
3）	格式化与挂载RAID 
[root@localhost ~]# mkfs -t ext4 /dev/md0 
 挂载命令如下： 
[root@localhost ~]# mkdir /raid 
#建立挂载点 
[root@localhost ~]# mount /dev/md0 /raid/ 
#挂载/dev/md0 
[root@localhost ~]# mount  
…省略部分输出… 
/dev/md0 on /raid type ext4 (rw) 
#查看下，已经正常挂载 
 
4）	、生成mdadm配置文件  在 CentOS 6.x中，mdadm 的配置文件并不存在，需要手工建立，这时我们使用以下命
令建立/etc/mdadm.conf配置文件： 
[root@localhost ~]# echo Device /dev/sdb[5-8] >> /etc/mdadm.conf  
#建立/etc/mdadm.conf配置文件名，并把组成RAID的分区的设备文件名写入 
#注意如果有多个Raid，要把所有组成Raid的设备都放入配置文件，否则Raid设备重启后会丢失 
#比如组成Raid 10，就既要把分区设备文件名放入此文件，也要把组成Raid 0的Raid1设备文件名放入 
[root@localhost ~]# mdadm -Ds >>  /etc/mdadm.conf 
#查询和扫描RAID信息，并追加进/etc/mdadm.conf文件 
[root@localhost ~]# cat /etc/mdadm.conf  
Device /dev/sdb5 /dev/sdb6 /dev/sdb7 /dev/sdb8 
ARRAY 	/dev/md0 	metadata=1.2 	spares=1 	name=localhost.localdomain:0 UUID=dd821fe5:8597b126:460a3afd:857c7989 
#查看文件内容 
 
5）	、设置开机自动挂载  自动挂载也是修改/etc/fstab配置文件，命令如下： 
[root@localhost ~]# vi /etc/fstab 
/dev/md0                /raid                   ext4    defaults        1 2 
#加入此行 
 如果要重新启动，一定要在这步完成之后再进行，否则会出现报错。 
 
6）	、启动或停止RAID 
 	RAID设备生效后，不用手工启动或停止。但是我们如果需要卸载RAID设备，那么就必须手工停止RAID，这里我们学习下启动或停止RAID的方法，先看看停止命令： 
[root@localhost ~]# mdadm –S /dev/md0 
#停止/dev/md0设备 
 当然如果是要删除RAID，则要非常小心，要把所有和RAID相关的内容全部删除，才能保证系统不报错，需要进行的步骤如下： 
[root@localhost ~]# umount /dev/md0 
#卸载RAID 
[root@localhost ~]# vi /etc/fstab 
/dev/md0                /raid                   ext4    defaults        1 2 
#删除此行 
[root@localhost ~]# mdadm -S /dev/md0  mdadm: stopped /dev/md0 
#停止RAID 
[root@localhost ~]# vi /etc/mdadm.conf 
ARRAY 	/dev/md0 	metadata=1.2 	spares=1 	name=localhost.localdomain:0 UUID=dd821fe5:8597b126:460a3afd:857c7989 
#删除或者注释此行 
 那如果我仅仅只是停止，而不是删除，就没有这么麻烦了，只要先卸载，再停止即可。
那停止完成之后，怎么再启动呢？启动RAID命令如下： 
[root@localhost ~]# mdadm -As /dev/md0 mdadm: /dev/md0 has been started with 3 drives and 1 spare. 
#启动/dev/md0 
 
[root@localhost ~]# mount /dev/md0 /raid/ 
#启动RAID后，记得挂载 
 
 	7）、模拟分区出现故障  我们的RAID虽然配置完成了，但是它到底生效了吗？我们模拟磁盘报错，看看备份分区是否可以会自动顶替错误分区。mdadm有一个选项-f，这个选项的作用就是把一个硬盘或分区变成错误状态，用来模拟RAID报错。命令如下： 
[root@localhost ~]# mdadm /dev/md0 -f /dev/sdb7 mdadm: set /dev/sdb7 faulty in /dev/md0 
#模拟/dev/sdb7分区报错 
[root@localhost ~]# mdadm -D /dev/md0 /dev/md0: 
…省略部分输出… 
Active Devices : 2 
Working Devices : 3 
 Failed Devices : 1  	 	 	 	 	 一个设备报错了 
  Spare Devices : 1 
 
…省略部分输出… 
    Number   Major   Minor   RaidDevice State 
0	8       21        0      active sync   /dev/sdb5 
1	8       22        1      active sync   /dev/sdb6 
3	8       24        2      spare rebuilding   /dev/sdb8 
 #/dev/sdb8分区正在准备修复 
4	8       23        -      faulty spare   /dev/sdb7 
 #/dev/sdb7已经报错了 
 要想看到上面的效果，查看时要快一点，要不可能就修复完成了。因为有备份分区的存在，所以分区损坏了，是不用管理员手工参与的。如果修复完成，再查看就会出现下面的情况： 
[root@localhost ~]# mdadm -D /dev/md0 
    Number   Major   Minor   RaidDevice State 
0	8       21        0      active sync   /dev/sdb5 
1	8       22        1      active sync   /dev/sdb6 
3	8       24        2      active sync   /dev/sdb8 
 
4	8       23        -      faulty spare   /dev/sdb7 
 备份分区/dev/sdb8已经激活，但是/dev/sdb7是失效了。 
 
8）	、移除错误分区  既然分区已经报错了，我们就把/dev/sdb7 从RAID中删除，如果这是硬盘，就可以进行更换硬盘的处理了。移除命令如下： 
[root@localhost ~]# mdadm /dev/md0  --remove /dev/sdb7 mdadm: hot removed /dev/sdb7 from /dev/md0 
 
9）	、添加新的备份分区  既然分区已经报错，那么我们还需要再加入一个新的备份分区，以备下次硬盘或分区出现问题。那既然要加入新的备份分区，当然还需要再划分出一个2GB的分区出来，命令如下： 
[root@localhost ~]# fdisk –l 
Disk /dev/sdb: 21.5 GB, 21474836480 bytes 
255 heads, 63 sectors/track, 2610 cylinders 
Units = cylinders of 16065 * 512 = 8225280 bytes 
Sector size (logical/physical): 512 bytes / 512 bytes 
I/O size (minimum/optimal): 512 bytes / 512 bytes 
Disk identifier: 0x151a68a9 
 
   Device Boot      Start         End      Blocks   Id  System 
/dev/sdb1               1        2610    20964793+   5  Extended 
/dev/sdb5               1         262     2104452   83  Linux /dev/sdb6             263         524     2104483+  83  Linux /dev/sdb7             525         786     2104483+  83  Linux 
/dev/sdb8             787        1048     2104483+  83  Linux /dev/sdb9            1049        1310     2104483+  83  Linux 
 我们新建了/dev/sdb9分区，然后需要把它加入/dev/md0作为备份分区，命令如下： 
[root@localhost ~]# mdadm /dev/md0 --add /dev/sdb9  mdadm: added /dev/sdb9 
#把/dev/sdb9加入/dev/md0 
[root@localhost ~]# mdadm -D /dev/md0 
…省略部分输出… 
    Number   Major   Minor   RaidDevice State 
0	8       21        0      active sync   /dev/sdb5 
1	8       22        1      active sync   /dev/sdb6        3       8       24        2      active sync   /dev/sdb8  
       4       8       25        -      spare   /dev/sdb9 
#查询下，/dev/sdb9已经变成了备份分区 
 
 
 
 
自测题     
1、	继续使用上一章自测题中已经分配的/soft分区，设置用户Jackman在/soft分区只能使用500MB空间。 
 
2、	再添加一块10GB的硬盘，然后使用这个硬盘建立4个2GB的分区。使用这4个新分区组建raid 10。 
 
 
 
 
 
7.31高级文件系统管理
一、磁盘配额补充
1.查看每个分区inode的数量（每16kb的磁盘空间有一个inode）
tune2fs –l
dumpe2fs –h
2.rpm –q quota 
   查看磁盘配额相关命令是否安装？

3.创建实验用户组
用户：cj  bd   xz 
组：thot
注意：创建实验用户组时，组中的用户的所属组必须是这个实验组，这样的话，创建出来的文件的所属组才是thot，否则用户无法在目录中创建文件
4. mount -a 	#重新挂载/etc/fstab
mount -o 	#挂载特殊属性	acl usrquota grpquota noexec 
mount -o remount,acl  设备&挂载点

mount -o loop  光盘文件		挂载点 
#挂载本地光盘文件
mount –o loop amoeba.iso /media/
media] #cp –a*  /root/  
把当前目录media下的所有文件复制到/root/下

5.quotacheck   选项  分区名  
                -a
                -u
                  -v
                  -g
#针对所有分区的用户和组的配置文件要加选项-a，不写分区名
#针对某一个分区不在加—a，-ugv即可，此时需要指定磁盘分区名
   quotaon的使用方法也一样
6./dev/stdin  标准输入键盘 （键盘）
二、dd命令
dd：用指定大小的块拷贝一个文件。

if=文件名：输入文件名，缺省为标准输入。即指定源文件。< if=input file >
of=文件名：输出文件名，缺省为标准输出。即指定目的文件。< of=output file >
bs=bytes：同时设置读入/输出的块大小为bytes个字节。
count=blocks：仅拷贝blocks个块，块大小等于ibs指定的字节数。

二．dd应用实例

1.将本地的/dev/hdb整盘备份到/dev/hdd(按block块备份，MBR分区也一起备份
 dd if=/dev/hdb of=/dev/hdd

2.将/dev/hdb全盘数据备份到指定路径的image文件
 dd if=/dev/hdb of=/root/image

3.将备份文件恢复到指定盘
 dd if=/root/image of=/dev/hdb

4.备份/dev/hdb全盘数据，并利用gzip工具进行压缩，保存到指定路径
 dd if=/dev/hdb | gzip > /root/image.gz

5.将压缩的备份文件恢复到指定盘
 gzip -dc /root/image.gz | dd of=/dev/hdb

6.备份与恢复MBR

a.备份磁盘开始的512个字节大小的MBR信息到指定文件：
 dd if=/dev/hda of=/root/image count=1 bs=512
count=1指仅拷贝一个块；bs=512指块大小为512个字节。

 
#上述操作执行完成后，记得一定要重启reboot，否则，/dev下会找不到/dev/sdc1和/dev/sdc2
b.恢复：
dd if=/root/image of=/dev/had
将备份的MBR信息写到磁盘开始部分

7.拷贝内存内容到硬盘
 dd if=/dev/mem of=/root/mem.bin bs=1024 (指定块大小为1k)
  注：不常用，sync更常用

8.拷贝光盘内容到指定文件夹，并保存为cd.iso文件
 dd if=/dev/cdrom(hdc) of=/root/cd.iso

9.增加swap分区文件大小
第一步：创建一个大小为256M的文件：
 dd if=/dev/zero of=/swapfile bs=1024 count=262144

第二步：把这个文件变成swap文件：
 mkswap /swapfile

第三步：启用这个swap文件：
 swapon /swapfile

第四步：编辑/etc/fstab文件，使在每次开机时自动加载swap文件：
/swapfile swap swap default 0 0
 

10.销毁磁盘数据
 dd if=/dev/urandom of=/dev/hda1
注意：利用随机的数据填充硬盘，在某些必要的场合可以用来销毁数据。

11.测试硬盘的读写速度
 dd if=/dev/zero bs=1024 count=1000000 of=/root/1Gb.file

 dd if=/root/1Gb.file bs=64k | dd of=/dev/null

通过以上两个命令输出的命令执行时间，可以计算出硬盘的读、写速度。


/dev/zero，是一个输入设备，你可你用它来初始化文件。该设备无穷尽地提供0，可以使用任何你需要的数目——设备提供的要多的多。他可以用于向设备或文件写入字符串0。

/dev/null——它是空设备，也称为位桶（bit bucket）。任何写入它的输出都会被抛弃。如果不想让消息以标准输出显示或写入文件，那么可以将消息重定向到位桶。外号叫无底洞，你可以向它输出任何数据，它通吃，并且不会撑着！


12.确定硬盘的最佳块大小：
 dd if=/dev/zero bs=1024 count=1000000 of=/root/1Gb.file

 dd if=/dev/zero bs=2048 count=500000 of=/root/1Gb.file

 dd if=/dev/zero bs=4096 count=250000 of=/root/1Gb.file

 dd if=/dev/zero bs=8192 count=125000 of=/root/1Gb.file

通过比较以上命令输出中所显示的命令执行时间，即可确定系统最佳的块大小。

  
 #由此可见，当bs=4kb的时候，数据的存储效率最高

 
 三．LVM逻辑卷管理
LVM（Logical Volume Manager）逻辑卷管理，它是Linux环境下对磁盘分区进行管理的一种机制。
	普通的磁盘分区管理方式在分区划分好之后就无法改变其大小，当一个逻辑分区存放不下某个文件时，解决的方法通常是使用符号链接，或者使用调整分区大小的工具，但这只是暂时解决办法，没有从根本上解决问题。
	简单来说LVM就是将物理磁盘融合成一个或几个大的虚拟磁盘存储池，按照我们的需求去存储池划分空间来使用，由于是虚拟的存储池，所以划分空间时可以自由的调整大小，如下图：

LVM的组成部分

	物理卷（PV，Physical Volume）：由磁盘或分区转化而成
	卷组（VG，Volume Group）：将多个物理卷组合在一起组成了卷组，组成同一个卷组的可以是同一个硬盘的不同分区，也可以是不同硬盘上的不同分区，我们通常把卷组理解为一块硬盘。
	逻辑卷（LV，Logical Volume）：把卷组理解为硬盘的话，那么我们的逻辑卷则是硬盘上的分区，逻辑卷可以进行格式化，存储数据。
	物理扩展（PE，Physical Extend）：PE卷组的最小存储单元，PE所在的位置是VG卷组，即硬盘上，那么我们可以把PE理解为硬盘上的扇区，默认是4KB，可自由配置。

创建LVM
	将物理磁盘分区，或整块磁盘分成一个区
	将物理磁盘上的分区建立成物理卷（PV）
	将创建好的物理卷组合成卷组（VG），通过添加或者删除一块物理卷，来实现卷组大小的调整。
	最后将卷组划分成逻辑卷（LV），逻辑卷也是可以随意调整大小的，逻辑卷相当于真正的分区，那么要使用必须进行格式化和挂载。
#在对/sdb进行全盘拷贝的时候，一定要记得重启，否则在创建物理卷的时候会报错：找不到设备/dev/sdc1 /dev/sc2
	 
 
	物理卷管理
a.	使用fdisk 来进行分区，分区的系统ID需要使用t选项修改为8e
b.	创建物理卷—pvcreate    /dev/sdb1
c.	查看物理卷—pvscan & pvdisplay   /dev/sdb1
d.	删除物理卷—pvremove
  

	卷组管理
a.	创建卷组—vgcreate
格式：vgcreate  选项  卷组名 物理卷名(可以写多个，空格分开)
-s	大小：指定VG的PE大小，即硬盘的扇区的大小
 
b.	查看卷组—vgscan & vgdisplay
 
c.	增加卷组容量--vgextend
格式：vgextend	卷组名	物理卷名
vgextend  avvg  /dev/sdc2
d.	减小卷组容量--vgreduce
格式：vgreduce	卷组名	物理卷名
 
vgreduce –a 卷组
#删除指定卷组内所有空的物理卷

 
	注：因为逻辑卷相当于是分区，所以需要进行格式化和挂载才能使用，及自启动

 
 
 
a.	查看逻辑卷—lvscan & lvdisplay
 

b.	增加逻辑卷容量--lvextend
		注：修改lv及文件系统的大小，必须先将lv及文件系统卸载（umount）
	eg.
	lvextend -L +10G /dev/testvg/testlv		#先增加lv的大小
	resize2fs -f /dev/testvg/testlv 30G		#再修改文件系统的大小
   # +10G是指在原有逻辑卷的基础上，增加10G，
    30G是指增加到30G
		
c.	减小逻辑卷容量—lvreduce
	注：减少lv空间的操作是有风险的，操作之前一定要做好备份，以免数据丢失。
	eg.
	e2fsck -f /dev/vg/lv					#检查文件系统
	resize2fs /dev/vg/lv newsize			#减少文件系统大小
	lvreduce -L newsize /dev/vg/lv			#减少lv大小
 


 
 
8.2
1.主机名命名：遵循“地区-应用-编号”
2.安装系统前创建LVM，将操作系统装在LVM上
步骤: 
(1)	选择三块盘/dev/sda /dev/sdb /dev/sdc 
(2)	将sda分200MB给/boot,其余sda2创建LVM，sdb、sdc都创建LVM 
(3)	生成卷组，sda2单独生成一个卷组vg_root，用于存放操作系统，将sdb1、sdc1创建成一个卷组，vg_data，用于存放数据 
(4)	创建swap分区，vg_root中创建，名称lv_swap，大小2G
(5)	选择vg_root剩余空间创建/分区
(6)	默认在/dev/sda中安装引导chengxu
安装完成hou
（6）	从vg_data中划分逻辑卷  lv_html  lv_log  lv_sql 
（7）	格式化
（8）	挂载，创建挂载点/html  /log  /sql  (写/etc/fstab文件) 
 
4.	防火墙：工作在网络边缘的网络机制
查看规则：iptables  -L
临时关闭：iptables –F
永久关闭：setup
5.	selinux
查看规则：getenforce
临时关闭：iptables –F (0 permissive  1 enforcing)
永久关闭：sed –I ’7s/enforcing/disabled/’ /etc/selinux/config

RAID磁盘阵列
定义：独立磁盘构成的具有冗余能力的阵列

磁盘阵列分类：一是外接式磁盘阵列柜、二是内接式磁盘阵列卡，三是利用软件来仿真

 1.通过把多个磁盘组织在一起作为一个逻辑卷提供磁盘跨越功能
2.通过把数据分成多个数据块（Block）并行写入/读出多个磁盘以提高访问磁盘的速度
3.通过镜像或校验操作提供容错能力

RAID磁盘阵列主要为了保证硬件损坏的情况下业务不会终止，无法防止误操作

	RAID磁盘阵列简介

	RAID 0：没有奇偶校验的条带
RAID 0提高存储性能的原理是把连续的数据分散到多个磁盘上存取，这样，系统有数据请求就可以被多个磁盘并行的执行，每个磁盘执行属于它自己的那部分数据请求

	RAID 1：独立磁盘冗余阵列
RAID 1通过磁盘数据镜像实现数据冗余，在成对的独立磁盘上产生互为备份的数据。当原始数据繁忙时，可直接从镜像拷贝中读取数据，因此RAID 1可以提高读取性能。

	RAID 10：镜象阵列条带
Raid 10是一个Raid 1与Raid0的组合体，它是利用奇偶校验实现条带集镜像，所以它继承了Raid0的快速和Raid1的安全。

	RAID5：分布式奇偶校验的独立磁盘结构
RAID 5 是一种存储性能、数据安全和存储成本兼顾的存储解决方案。 RAID 5可以理解为是RAID 0和RAID 1的折中方案。

	Raid 5 阵列搭建流程
a.	准备物理磁盘
b.	创建raid5阵列
mdadm -Cv 阵列名称(md*) -l5 -n3  磁盘	  -x1 磁盘
		-C：create
		-v：显示详细信息
eg.
		mdadm -Cv /dev/md0 -l5 -n3 /dev/sdb1 /dev/sdb2 /dev/sdb3 -x1 /dev/sdb5

记得要格式化并挂载才能使用，还有自动挂载
c.	查看raid5阵列信息
mdadm –D	设备名
d.	生成raid5阵列配置文件
 
e.	模拟raid5阵列磁盘损坏
mdadm  /dev/md0  –f  /dev/sdb3
#标记阵列中某磁盘损坏，并查看磁盘状态
f.	移除故障磁盘，添加新磁盘
mdadm  /dev/md0  --remove  /dev/sdb3
#移除故障磁盘
mdadm /dev/md0 --add /dev/sdb6
#添加新的磁盘，恢复正常热备


 












8.3  shell基础
1.语言的特点：
  （1）计算能力
  （2）函数
  （3）流程控制
   html超文本标识语法
2.Shell 概念               shell














                内核
3.rpm包相当于把安装目录打包压缩
   cpio备份要指明相对路径和绝对路径



Shell是系统的用户界面，提供了用户与内核进行交互操作的一种接口。接收用户输入的命令并把它送入内核去执行。
	实际上Shell是一个命令解释器，它解释由用户输入的命令并且把它们送到内核。（转化成机器码）
不仅如此，Shell有自己的编程语言用于对命令的编辑，它允许用户编写由shell命令组成的程序。Shel编程语言具有普通编程语言的很多特点，比如它也有循环结构和分支控制结构等，用这种编程语言编写的Shell程序与其他应用程序具有同样的效果。
Shell 的分类
	Linux中的shell有多种类型，其中最常用的几种是Bourne shell（sh）、C shell（csh）和Korn shell（ksh）。三种shell各有优缺点。
Bourne shell是UNⅨ最初使用的shell，并且在每种UNⅨ上都可以使用。Bourne shell在shell编程方面相当优秀，但在处理与用户的交互方面做得不如其他几种shell。
Linux操作系统缺省的shell是Bourne Again shell，它是Bourne shell的扩展，简称Bash，与Bourne shell完全向后兼容，并且在Bourne shell的基础上增加、增强了很多特性。Bash放在/bin/bash中，它有许多特色，可以提供如命令补全、命令编辑和命令历史表等功能，它还包含了很多C shell和Korn shell中的优点，有灵活和强大的编程接口，同时又有很友好的用户界面。
C shell是一种比Bourne shell更适于编程的shell，它的语法与C语言很相似。Linux为喜欢使用C shell的人提供了Tcsh。Tcsh是C shell的一个扩展版本。Tcsh包括命令行编辑、可编程单词补全、拼写校正、历史命令替换、作业控制和类似C语言的语法，它不仅和Bash shell是提示符兼容，而且还提供比Bash shell更多的提示符参数。
Korn shell集合了C shell和Bourne shell的优点并且和Bourne shell完全兼容。Linux系统提供了pdksh（ksh的扩展），它支持任务控制，可以在命令行上挂起、后台执行、唤醒或终止程序。
查询Linux中支持的shell类型：
 
shell的执行方式
echo  [选项]  [输出内容]
	-e	支持反斜线控制的字符转换
	-n	取消输出后行尾的换行符号
echo  –e  ：支持反斜线支持的控制转换 
 

输出“\a”本身，并发出警告声？
删除“\b”前的字符，然后输出结果？
使用 \t 制表符 和 \n 换行，实现特殊格式？
按照八进制和十六进制的ASCII编码输出？
 

	显示颜色
\e[ ; m …… \e[；m
“\e[1”代表颜色输入开始；“\e[0m” 代表颜色输入结束；固定格式！

文字颜色：30=黑色，31=红色，32=绿色，33=黄色，34=蓝色，35=洋红，36=青色，37=白色，39=结束
底纹颜色：40=黑色，41=红色，42=绿色，43=黄色，44=蓝色，45=洋红，46=青色，47=白色，49=结束

	特殊的控制显示
	\e[0m 关闭所有属性 
	\e[1m 设置高亮度 
	\e[4m 下划线 
	\e[5m 闪烁
	\e[7m 反显 
	\e[8m 消隐

shell 脚本

创建shell脚本文件，一般以 .sh 结尾
shell 脚本作为一种脚本文件，如何运行？
	添加x 执行权限（相对或绝对路径执行）
	用bash或source命令，调用脚本文件

Bash 的基本功能

	历史命令
	历史命令的查看
	命令：history  [选项]
		-c	清空历史命令
		-w	把缓存中的历史命令保存到历史命令配置文件

	历史命令的调用
	调用之前使用过的历史命令有以下几种办法：
	使用上、下光标键调用
	使用“！n”，重复执行第n条历史命令
	使用“！！”，重复执行上一条命令
	使用“！字符”，重复执行最近一条以此字符开头的命令

	命令与文件名的补全
Bash放在/bin/bash中，它有许多特色，可以提供如命令补全、命令编辑和命令历史表等功能

	命令别名
	命令：alias 别名=’原命令 [选项]’
	两个配置文件：
		单个用户：~/.bashrc
		所有用户：/etc/bashrc
		注：别名命令的优先级更高

	不同类型的命令执行的顺序：
NO.1 用绝对路径或相对的方式执行命令
NO.2 别名命令
NO.3 bash 内置命令
NO.4 根据环境变量定义的目录查询找到的命令

Bash 常用快捷键	

		 
		
输入输出重定向

	bash的标准输入输出
		

设备	设备文件名	文件描述符	类型
键盘	/dev/stdin	0	标准输入
显示器	/dev/stdout	1	标准正确输出
显示器	/dev/stderr	2	标准错误输出

	输出重定向
		 
	输入重定向	
		命令：wc  [选项]  [文件名]
			-c	统计字数（字符）
			-w	统计单词数（字符串）
			-l	统计行数

















8.3
补充：
	
Linux中常见的注释格式：
		#				注： 有些配置文件中的注释必须顶格注释
		//
		；
		/* aaa */
		<!--  aaa  -->
	
	\ 将特殊符号的含义取消，变成普通符号
	  将带有别名的命令取消，使用命令的原始含义
	
一、多命令顺序执行
1. 多命令顺序执行
		 
echo $?  通过查看返回值确认上一条命令是否执行成功！
	命令：grep  [选项] “关键词” 文件名 		#行提取命令
		-A 数字：列出符合条件的行，并将连续列出后续n行
		-B 数字：列出符合条件的行，并将连续列出前面n行
		-c	：统计包含字符串的行一共几行！
		-i	：忽略大小写
		-n	：输出行号
		-v	：反向查找（取反）
2.	xargs是实现“将标准输出	`作为命令的参数”
		eg：
		echo "--help" | cat
		echo "--help" | xargs cat
3.通配符
		 
	eg：匹配开头不是数字的 ^[^0-9]
二：bash中的其他特殊符号
 
[ ] 数值判断时，只能进行是否相等的判断，大于小于等不能使用此格式！
	[ "$a" == "34" ]	√
	[ "$a" > "34" ]		X			（ > < >= <= 都不能在这个格式中使用）
	

bash是可以手动开启的，每bash一下就是开启一个shell ，相应的就会有			父shell 和 子 shell
pstree 查看进程树
（） 中执行命令时，新开启shell 进行
{ } 执行命令时，就在本shell中进行
三、bash的变量与运算符		
1.定义变量的规范：
	变量名称可以由字母、数字和下划线组成，但是不能以数字开头，变量中间不能有空格。如果变量名是“2name”则是错误的。
	在Bash中，变量的默认类型都是字符串型，如果要进行数值运算，则必修指定变量类型为数值型。
 
	变量用等号连接值，等号左右两侧不能有空格。
 
	变量的值如果有空格，需要使用单引号或双引号包括。如：“test="hello world!"”。其中双引号括起来的内容“$”、“\”和反引号都拥有特殊含义，而单引号括起来的内容都是普通字符。

	双引号“ ”括起来的 $  \  `` 都有特殊含：

	单引号括起来的都是普通字符

在变量的值中，可以使用“\”转义符。
	如果需要增加变量的值，那么可以进行变量值的叠加。不过变量需要用双引号包含 "$变量名" 或用 ${变量名} 包含变量名。
		 
	如果是把命令的结果作为变量值赋予变量，则需要使用反引号或$()包含命令。
	环境变量名建议大写，易于区分
 
二：变量的分类
	set 当前登录终端中所有已生效的变量（自定义、环境变量。。）
	env 只查看当前终端的环境变量
	set -u  ： 设置后再次调用不存在的变量时会提醒报错，不会执行命令
	unset 取消已设置的变量
1.用户自定义变量
这种变量是最常见的变量，由用户自由定义变量名和变量的值。
echo	$变量名
变量查看
2.	环境变量
		这种变量中主要保存的是和系统操作环境相关的数据，比如当前登录用户，用户的家目录，命令的提示符等。环境变量的变量名可以自由定义，但是一般对系统起作用的环境变量的变量名是系统预先设定好的。
位置参数变量
	这种变量主要是用来向脚本当中传递参数或数据的，变量名不能自定义，变量作用是固定的。
预定义变量
是Bash中已经定义好的变量，变量名不能自定义，变量作用也是固定的。

		
（1）环境变量设置
export	AGE=18
#export 声明的是环境变量
（2）PATH变量：系统查找命令的路径
 
PATH变量的值是用“：”分割的路径，这些路径就是系统查找命令的路径。也就是说当我们输入了一个程序名，如果没有写入路径，系统就会到PATH变量定义的路径中去寻找，是否有可以执行的程序。如果找到则执行，否则会报“命令没有发现”的错误。
我们可以考虑把自己写的脚本放入这些目录，实现直接调用（当命令使用）
 
或者：
我们修改PATH变量的值，而不是把程序脚本复制到/bin/目录中，以后所有写入这个目录的脚本都可以直接执行。
 
上边写的这些变量的定义啊，叠加啊，修改啊，什么的都是临时的。
（3）PS1变量：命令提示符设置
PS1是用来定义命令行的提示符的，可以安装我们自己的需求来定义自己	喜欢的提示符。PS1可以支持以下这些选项：
	\d：显示日期，格式为“星期月日”
	\H：显示完整的主机名。如默认主机名“localhost.localdomain” 
	\h：显示简写主机名。如默认主机名“localhost” 
	\t：显示24小时制时间，格式为“HH:MM:SS” 
	\T：显示12小时制时间，格式为“HH:MM:SS” 
	\A：显示24小时制时间，格式为“HH:MM” 
	\@：显示12小时制时间，格式为“HH:MM am/pm” 
	\u：显示当前用户名
	\v：显示Bash的版本信息
	\w：显示当前所在目录的完整名称
	\W：显示当前所在目录的最后一个目录
	\#：执行的第几个命令
	\$：提示符。如果是root提示符为“#”，如果是普通用户提示符为“$” 
想要使用这些必须先知道定义的规范，来看下官方的PS1：
 
定义ps1的值时需要注意单引号，否则不生效
 
随便玩，玩坏了记得改回来！
 

8.4
补充：
	默认语系变量（通过加载配置文件生成的）
	当前语系变量（临时设置的export LANG=us）
	ssh 远程连接服务
	sshd_config	
		Banner=/etc/issue.net
	issue 	issue.net		mote
（4）LANG语系变量
LANG定义的是Linux 的主语系环境变量：
 
这是因为我们Linux安装时，选择的是中文安装，所以默认的主语系变量是“zh_CN.UTF-8”。那么Linux中到底支持多少语系呢？我们可以使用以下命令查询：
 
或者 用 wc –l 统计下一共支持多少！

我们当前是什么语系可以用locale 直接查询！
 

配置文件也能查询到我们的默认语系：
	 

这又是当前系统语系，又是默认语系，有没有快晕倒的感觉。解释下吧，我们可以这样理解，默认语系是下次重启之后系统所使用的语系，而当前系统语系是当前系统使用的语系。如果系统重启，会从默认语系配置文件/etc/sysconfig/i18n中读出语系，然后赋予变量LANG让这个语系生效。也就是说，LANG定义的语系只对当前系统生效，要想永久生效就要修改/etc/sysconfig/i18n文件了。
说到这里，我们需要解释下Linux中文支持的问题。是不是我们只要定义了语系为中文语系，如zh_CN.UTF-8就可以正确显示中文了呢？这要分情况，如果我们是在图形界面中，或者是使用远程连接工具（如SecureCRT），只要正确设置了语系，那么是可以正确显示中文的。当然远程连接工具也要配置正确的语系环境，具体配置方式可以参考Linux系统安装章节。
那么如果是纯字符界面（本地终端tty1  -tty6）是不能显示中文的，因为Linux的纯字符界面时不能显示中文这么复杂的编码的。如果我们非要在纯字符界面显示中文，那么只能安装中文插件，如zhcon等。

远程连接的显示：
 
字符终端的显示：
 	安装有图形界面的Linux，所以，那些乱码就是我的中文目录。

3.位置参数变量
		 
		
		 
		脚本1：
		 
		
		脚本2：
		 
	$*显示所有参数（作为整体接收）
	$@显示所有参数（分开接收）
	$#显示参数个数
				
4.预定义变量
		 
			
		 
	$? 错误数值是非0 的，正确的是0
	$$ 当前进程的PID
		 
		$! 最后一个后台执行的命令的进程
		 

5.接收键盘输入
		read  [选项]   [变量名]
			-p	“提示信息”：在read等待时输入的信息
			-t	秒数	：read等待的秒数
			-n	字符数：read最多能接收的字符数（达标即执行）
			-s	：隐藏输入信息
				
		 
		假如因为特殊选项不换行，可以结合 \n 控制转换符一起显示。
			
6.变量名定义：
	变量名可以自定义，如果不指定变量名，会把输入保存入默认变量REPLY 
	如果只提供了一个变量名，则整个输入行赋予该变量
	如果提供了一个以上的变量名，则输入行分为若干字，一个接一个地赋予各个变量，而命令行上的最后一个变量取得剩余的所有字

7.shell 的运算符
数值运算的方法
使用declare声明变量类型
命令：declare	[+/-] [选项]  变量
			-   : 给变量设定类型
			+	: 取消变量的类型
			-a	: 将变量声明成数组型
			-i	: 将变量声明成整数型
			-r	: 将变量声明成只读（变量值不能修改，也不能删除，更不能取消）
			-x	: 将变量声明成环境变量
			-p	: 显示指定变量的类型及内容

	（1）数组型
数组，其实是多个相同类型的元素组成的集合，用于解决复杂的数据统计和计算，我们在shell中基本不会涉及到太多的算法和计算，所以数组了解下就可以了。数组的名字即变量的名字是同一个变量名，我们在变量名后面加上编号来区分单个变量，数组变量又称下标变量。
 
注：数组的下标从0开始，调用数组的元素时要使用${数组[下标]}的格式

我们刚才貌似没有使用declare 声明
当我们使用“变量名[下标]” 这样的格式定义变量时，自动识别成数组
 

（2）整数型
之前我们曾经写过让两个数字相加的脚本，但是貌似结果不尽人意，那么我们现在将我们的变量声明成整数型再来试试。。。
 
shell种如果想进行数值运算，暂时只能先这样了。

（3）环境变量
我们可以用declare 将变量声明成环境变量，和我们的export是同样的效果。
declare –x 变量名	（环境变量的名字尽量大写）
写完后可以使用env命令查看下！
 

（4）只读变量
只要对变量设置了只读属性，这个变量只能进行调用，不能进行修改和删除，甚至不能进行取消只读选项。坑爹啊。。。
 
这个流氓，怎么办？。。。

（5）查询变量和取消变量属性
变量属性查询可以使用-p，会列出变量设置时使用的参数；变量属性的取消使用 + 来实现。
 

（6）使用expr 或 let 数值运算个工具
这两个是直接声明运算是数值运算，而不是通过声明变量的方式，所以相对简单，但是要注意格式：
 
expr 使用时需要注意的是，在运算符两边要有空格，否则不会正常运算。，
 
let 则相对简单易用，原理相同，格式略微变化：
 
let 还能进行自增增减，或者指定增加减少多少 ！
自增&自减
 
指定增减量
 
不管是expr 还是 let 都能实现数值运算，看个人使用习惯。

（7）使用“$((运算式))”或“$[运算式]”格式进行运算
同样两种格式都能实现数值运算，看个人喜欢，习惯。
 

以上三种数值运算方式选择哪一种都可以，在脚本中常见的是$((运算式))。

三、shell 常用运算符
		 
		运算符的优先级，就是当有多个运算符同时存在时，谁先进行数值计算，			但是有时也是有特殊情况的比如：
		
		加减乘除
		 、
		按照表格的优先级是乘除优先于加减，但是由于加减被（）调用，所以，括号的优		先级高于乘除。
		
		取模运算
		 
		取模运算和取余运算绝大部分是重叠的，但是一个是计算机术语，一个是数学概念，		区别在于取模运算对负数处理不太一样。
		
		逻辑与
		 

	变量的测试与内容置换(作为了解即可)
		 
		不解释，直接上实验，按照实验结果来总结：
		例1：x=${y-新值}
		 
		当没有：时，y不存在时x=新值，y为空时x=空，y有值时x=$y
		当有：时，y不存在时x=新值，y为空时x=新值，y有值时x=$y
		注：x=${y+新值}	与 x=${y-新值} 相反！

四、环境变量的配置
1.source	命令
刷新修改过的配置文件使其生效
 

2.环境变量配置文件
（1）登录系统时生效的环境变量配置文件
	/etc/profile
	/etc/profile.d/*.sh
	~/.bash_profile
	~/.bashrc
	/etc/bashrc

（2）文件的调用顺序是：
 
在用户登录过程先调用/etc/profile文件在这个环境变量配置文件中会定义这些默
（3）环境变量：
	USER变量：根据登录的用户，给这个变量赋值（就是让USER变量的值是当前用户）。
	LOGNAME变量：根据USER变量的值，给这个变量赋值。
	MAIL变量：根据登录的用户，定义用户的邮箱为/var/spool/mail/用户名。
	PATH变量：根据登录用户的UID是否为0，判断PATH变量是否包含/sbin、/usr/sbin和/usr/local/sbin这三个系统命令目录。
	HOSTNAME变量：更改主机名，给这个变量赋值。
	HISTSIZE变量：定义历史命令的保存条数。
	umask：定义umask默认权限掩码。注意/etc/profile文件中的umask权限是在“有用户登录过程（也就是输入了用户名和密码）”时才会生效。
	调用/etc/profile.d/*.sh文件，也就是调用/etc/profile.d/目录下所有以.sh结尾的文件。

（4）由/etc/profile文件调用/etc/profile.d/*.sh文件
	这个目录中所有以.sh结尾的文件都会被/etc/profile文件调用，这里最常用的就是lang.sh文件，而这个文件又会调用/etc/sysconfig/i18n文件。/etc/sysconfig/i18n这个文件眼熟吗？就是我们前面讲过的默认语系配置文件。

		由/etc/profile文件调用~/.bash_profile文件。 ~/.bash_profile文件就没有			那么复杂了，这个文件主要实现了两个功能：
	调用了~/.bashrc文件。
	在PATH变量后面加入了“:$HOME/bin”这个目录。那也就是说，如果我们在自己的家目录中建立bin目录，然后把自己的脚本放入“~/bin”目录，就可以直接执行脚本，而不用通过目录执行了。

		由~/.bash_profile文件调用~/.bashrc文件
		在~/.bashrc文件中主要实现了：
	定义默认别名，所以我们把自己定义的别名也放入了这个文件。
	调用/etc/bashrc

		由~/.bashrc调用了/etc/bashrc文件在/etc/bashrc文件中主要定义了这些内容：
	PS1变量：也就是用户的提示符，如果我们想要永久修改提示符，就要在这个文件中修改
	umask：定义umask默认权限。这个文件中定义的umask是针对“没有登录过程（也就是不需要输入用户名和密码时，比如从一个终端切换到另一个终端，或进入子Shell）”时生效的。如果是“有用户登录过程”，则是/etc/profile文件中的umask生效。
	PATH变量：会给PATH变量追加值，当然也是在“没有登录过程”时才生效。
	调用/etc/profile.d/*.sh文件，这也是在“没有用户登录过程”是才调用。在“有用户登录过程”时，/etc/profile.d/*.sh文件已经被/etc/profile文件调用过了。

这样这五个环境变量配置文件会被依次调用，那么如果是我们自己定义的环境变量应该放入哪个文件呢？如果你的修改是打算对所有用户生效的，那么可以放入/etc/profile环境变量配置文件；如果你的修改只是给自己使用的，那么可以放入~/.bash_profile或~/.bashrc这两个配置文件中的任一个。

可是如果我们误删除了这些环境变量，比如删除了/etc/bashrc文件，或删除了~/.bashrc文件，那么这些文件中配置就会失效（~/.bashrc文件会调用/etc/bashrc文件）。那么我们的提示符就会变成：
 

注销时生效的环境变量配置文件
	在用户退出登录时，只会调用一个环境变量配置文件，就是~/.bash_logout。这个文件默认没有写入任何内容，可是如果我们希望再退出登录时执行一些操作，比如清除历史命令，备份某些数据，就可以把命令写入这个文件。

其他配置文件
还有一些环节变量配置文件，最常见的就是~/bash_history文件，也就是历史命令保存文件。这个文件已经讲过了，这里我们只是把它归入环境变量配置文件小节而已。

（5）shell登录信息
/etc/issue
我们在登录tty1  -tty6这六个本地终端时，会有几行的欢迎界面。这些欢迎信息是保存在哪里的？可以修改吗？当然可以修改，这些欢迎信息是保存在/etc/issue文件中，我们查看下这个文件：
 
\r  \m  等是支持的转义符，查询可用man agetty
\d	：显示当前系统时间
\s	：显示操作系统名称
\l	：显示登录的终端号
\m	：显示硬件体系结构，如i386、i686等
\n	：显示主机名
\o	：显示域名
\r	：显示内核版本
\t	：显示当前系统时间
\u	：显示当前登录用户的序列号

/etc/issue.net
etc/issue是在本地终端登录是显示欢迎信息的，如果是远程登录（如ssh		远程登录，或telnet远程登录）需要显示欢迎信息，则需要配置			/etc/issue.net这个文件了。使用这个文件时由两点需要注意：
	首先，在/etc/issue文件中支持的转义符，在/etc/issue.net文件中不能使用。
	其次，ssh远程登录是否显示/etc/issue.net文件中的欢迎信息，是由ssh的配置文件决定的。

如果我们需要ssh远程登录可以查看/etc/issue.net的欢迎信息，那么首先需要修改ssh的配置文件/etc/ssh/sshd_config，加入如下内容：
 
然后定义/etc/issue.net 后就能显示欢迎信息了。

/etc/motd
/etc/motd文件中也是显示欢迎信息的，这个文件和/etc/issue及	/etc/issue.net文件的区别是：/etc/issue及/etc/issue.net是在用户登录之前显示欢迎信息，而/etc/motd是在用户输入用户名和密码，正确登录之后显示欢迎信息。在/etc/motd文件中的欢迎信息，不论是本地登	录，还是远程登录都可以显示。

定义bash快捷键
查看所有已存在的快捷键
 

修改快捷键
stty	关键词	快捷键

































8.7                  SHELL高级
一.正则表达式
   使用正则的命令 grep
   cut   awk  sed   三个文本处理命令+grep  四剑客

   都能和 | 所结合，可以将某命令的结果或者某变量的值  通过|进行再次操作（提取、替换、删除）

最后进行判断
1.基础正则表达式
元字符	作用
   *	前一个字符匹配0次或任意多次
   .	匹配除了换行符外任意一个字符
   ^	行首匹配
   $	行尾匹配
   [ ]	匹配中括号中任意一个字符，只匹配一个
   [^ ]	匹配除中括号中字符以外任意一个字符
   \	转义符
   \{n\}	表示前面的字符恰好出现n次
   \{n,\}	表示前面的字符出现不小于n次
   \{n,m\}	表示前面的字符最少出现n次，最多出现m次
             先匹配大的（即先匹配m）
 #用“^$”匹配空白行

2.扩展正则表达式
扩展元字符	作用
    +	前一个字符匹配一次或者任意多次
    ？	前一个字符匹配0次或1次
    |	匹配两个或者多个分支选择
   （）	匹配其整体为一个字符，即模式单元。可以理解为单个字符组成的大字符

3.练习
（1）匹配手机号
     匹配手机号
	a、1开头
b、手机号长度11位
	c、第二位：3、5、7、8		
				
模板			
18515459511
58515459511
12515459511
19515459511
a18515459511
*18515459511
18515459511a
18515459511*
185154*59511
185154595141
1851545511

grep "^1[3578][0-9]\{9\}$" shouji.sh

（2）匹配IP
	
		0.0.0.0  -- 255.255.255.255
		不算正常ip的(包含符号的)
		五位不算、单位超过255的、
		把正常范围内的ip匹配成功后再去掉下列ip
		最后去掉0.0.0.0   255.255.255.255  127.0.0.0

		0-255
			0-9			[0-9]
			10-99		[1-9][0-9]
			100-199		1[0-9][0-9]	
						1[013-9][0-9]			去掉127网段
						12[0-689]
			200-249		2[0-4][0-9]
			250-255		25[0-5]
			
		([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])
		
egrep "^([1-9]|[1-9][0-9]|1[013-9][0-9]|12[0-689]|2[0-4][0-9]|25[0-5])\.(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\.){2}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-4])$"
		

IP模板：
0.0.0.0
2.2.2.2
55.55.55.55
117.24.56.78
117..56.78
127.0.0.1
192.168.88.100
192.168.88.100.56
200.19.45.89
200.19.4_89
253.253.45.78
253.*.45.78
247.12.34.56
255.255.255.255
300.300.300.300
256.34.56.78
a256.34.56.78		
（3）匹配邮箱
     
  匹配邮箱 	liuchuan_jy@163.com
		
	@前的字符数：3-18
	可使用字母、数字、下划线，需以字母或数字开头
	最开头不能是符号 	紧挨着@的不能是符号（包含_）
	@后面紧挨着@的也不能是符号（包含_）
		
	.限制（.com  .net  .com.cn  .cn .org ）
		   邮箱测试模板 liuchuan@itxdl.com
liuchuanitxdl.com
_abc@163.com
123_@163.com
@163.com
123_123@.com
%^&*670376149@qq.com
liuchuan_jy@163.com
670376149@qq.com
670376149@@qq.com
yuncompute@sina.com.cn
liuchuan@lampbrother_.net
liuchuan_jy@163.@com
670376149@qq.coma*
670376149@@_qq.com
yuncompute@sina.com1.cn.
liuchuan@lampbrother.net.a	

egrep "^[a-zA-Z0-9][a-zA-Z0-9_]{1,16}[a-zA-Z0-9]@[a-zA-Z0-9]{1,}(\.com|\.net|\.com\.cn|\.cn|\.org)$" com.txt












































Shell 高级

正则表达式
	概述
在上一章说过正则表达式和通配符的区别（正则表达式用来在文件中匹配符合条件的字符串，通配符用来匹配符合条件的文件名）吗？其实这种区别只在Shell当中适用，因为用来在文件当中搜索字符串的命令，如grep、awk、sed等命令可以支持正则表达式，而在系统当中搜索文件的命令，如ls、find、cp这些命令不支持正则表达式，所以只能使用shell自己的通配符来进行匹配了。
	基础正则表达式
 
在/etc/bashrc中创建别名
alias  grep=‘grep --color=auto’
	 
	匹配练习
	* 前一个字符匹配0次或任意多次
如果正则表达式写成“aa*” 代表匹配至少包含有一个a的行

. 匹配换行符以外的任意一个字符
正则表达式“.”只能匹配一个字符，可以是任意字符

^ 匹配行首，$ 匹配行尾
#用“^$”匹配空白行

[  ] 会匹配中括号中指定任意一个字符，注意只能匹配一个字符。比如[ao]要不匹配一个a字符，要不匹配一个o字符

[0-9]  [a-z]  [A-Z]   类似这样的都可以，指定匹配的范围
[^0-9]匹配除了数字以外的任意一个字符
^[^a-zA-Z]这个代表啥呢？？

\ 转义符
#将特殊符号转义成普通符号，比如我们的 . 

\{n\} 表示前面的字符恰好出现n次
\{n,\} 表示其前面的字符出现不小于n次
\{n,m\} 匹配其前面的字符出现不小于n次，最多出现m次

	扩展正则表达式
熟悉正则表达式的童鞋应该很疑惑，在正则表达式中应该还可以支持一些元字符，比如“+”“ ？ ”“|”“（ ）”。 其 实Linux是支持这些元字符的，只是grep命令默认不支持而已。如果要想支持这些元字符，必须使用egrep命令或grep -E选项，所以我们又把这些元字符称作扩展元字符。
如果查询grep的帮助，对egrep的说明就是和grep -E选项一样的命令，所以我们可以把两个命令当做别名来对待。通过下面表格来看看Shell中支持的扩展元字符：
  

练习：
	1.	匹配手机号
	2.	匹配ip
	3.	匹配邮箱




字符截取和替换命令
cut	列提取命令
	cut	[选项]	文件名
	   -f		列号：提取第几列
-d	分隔符：按照指定的分割符进行分割
-c	字符范围：不依赖分割符来分割，而是通过字符范围进行字段提取（“-m”表示从第一个字符提取到第m个，“n-m”表示从第n提取到第m个字符，“n-”表示从第n个字符开始提取到结尾。）

手动创建文本，添加内容列之间用制表符分割
 
#假如用空格隔开，那么可能会别认定为是同一列。
我们可以使用-d 指定分割符号，比如/etc/passwd
 
#通过指定分割符的方式来确定如何额进行分割，我们把/etc/passwd按照：分割，截取第一个第七字段，就能统计哪些用户能登录系统，哪些不能登录。
cut 可以按照字符数进行截取，按照我们上面的格式写就OK了
 
8.8
grep、 cut 、 awk 、sed 三个文本处理命令	四剑客！
	
	
	cut 
		列提取命令，默认所支持的分割符为 制表符（tab）
		
		cut -f 2 xbz.txt	提取指定的第二列
	
		cut -d " " -f 2 df.txt  支持空格，但对于分割时多个空格的支持有限！
	
		cut -c 17-20 df.txt 	以指定范围的方式进行提取列（需要提前算好起始点，结束点）
	
		使用-d 指定 ： 作为分割符 截取/etc/passwd 文件中的第一列和第七列
	
		cut -d ":" -f 1,3,7 /etc/passwd
		
		echo "13%" | cut -d % -f 1			去13% 中的数字（取消%）
	
	
		grep -v ID xbz.txt | grep -v sans | cut -f 3	
		截取指定文本中第三行以后的第三列
	
	
	
	awk 列提取命令（行操作）\
	
		awk '条件1{动作1} 条件2{动作2;动作2.2}'  操作对象
		
		先检查是否存在BEGIN条件，先执行BEGIN条件后的动作，然后在处理文本信息
			BEGIN{FS=:}
		
		1.	先读取指定文件的第一行，根据第一行的参数位置，给位置参数变量赋值
		
			条件：
				$3>10 $3<10 >= <= == !=
				$3~/sc/ 	/sc/
				NR==3  	NR>=3
			
			动作：
				{printf $3"\t"$5"\n"}
		
			ID		NAME	AGE		SEX
			1		SANS	18		MAN
			2		PENG	19		MAN
			$1		$2		$3		$4
	
		2.	读取完成第一行后将后续行按照 第一行的 方式操作赋值，判断。
	
		3.	在进行文本处理时，若文件内的分割符不是指定的空格&制表符，可以使用
			BEGIN{FS=":"} 声明 ： 作为分割符
			
			awk 'BEGIN{FS=":"}{printf $3"\t"$7"\n"}' /etc/passwd
			#使用BEGIN{FS=:} 来声明分割符
			
			awk -F : '{printf $3"\t"$7"\n"}' /etc/passwd
			使用-F ：进行指定： 作为分割符
			
	
		$n~/xx/		在指定范围（指定列）内匹配是否包含xx	
		
		/XX/		在全文范围内匹配是否包含XX
		
		
		grep -v ID xbz.txt | awk '$4>=25{printf $2"\t"$4"\n"}'
		
		判断指定列是否大于25 大于25的列出其姓名和年龄
	
	
		sda1=$(df -h | awk '$1~/sda1/{printf $5"\n"}' | cut -d % -f 1)
	
		截取df -h 中sda1 磁盘的使用百分比的数值赋给 sda1 变量
	
		awk 中变量的定义：	a=10
		  变量的调用：	直接写变量名，不需要使用$调用！
	
	
		awk 'NR==2{age1=$4} NR==3{age2=$4} NR==4{age3=$4} NR==5{age4=$4;age=(age1+age2+age3+age4)/4;printf age"\n"}' xbz.txt
		
		计算部门四个人的平均年龄！（变量设置、变量调用）
	
	sed 
		
		sed -n 	只显示指定内容或修改了的内容 （2p第二行、2a|2i  2c  2s 2d）
		
		np  指定行
		na|ni	在指定行后面|指定行前面添加一行或多行（注意强制换行符）
		2c		替换掉指定的整行
		2d		删除指定行	3,5d
		2s /old/new/		替换掉指定行的指定字符串 3,5s /old/new/
	
		sed -i	将修改的内容写入到硬盘上（即修改源文件）
now，我们来截取下df –h 命令的结果！
cut 命令默认的分割符是制表符，即tab键，对于空格的支持比较差

awk命令
awk是一种编程语言，用于在linux/unix下对文本和数据进行处理。数据可以来自标准输入(stdin)、一个或多个文件，或其它命令的输出。
printf 格式化输出
print 和 printf 的主要区别在有 printf 是标准的格式化输出，必须手动指定换行和tab。
输出格式类型：
 
使用printf输出下我们的表格文件
 
printf输出下
printf  ‘ %s ’ $(cat bg.sh)
printf命令，如果不指定输出格式，则会把所有输出内容连在一起输出。其实文本的输出本身就是这样的，cat等文本输出命令之所以可以按照格式漂亮的输出，那是因为cat命令已经设定了输出格式。那么为了用printf输出合理的格式，应该这样做：
printf ‘%s\t%s\t%s\t%s\t\n‘  $(cat bg.sh)
 
我们要按照整数型和浮点型输出，则需要修改为：
printf ‘%i\t%s\t%8.2f\t%s\t\n‘  $(cat bg.sh | grep –v ID)
 

awk基本使用
	awk ‘条件1{动作1}  条件2{动作2} ……’ 文件名
	条件：一般使用关系表达式作为条件
		x>10	判断x变量是否大于10
		x==y	判断变量x是否等于变量y
		A ~ B	判断字符串A中是否包含能匹配B表达式的字符串
		A!~ B	判断字符串A中是否不包含能匹配B表达式的字符串
	动作：格式化输出
		 
		显示bg.sh 中的第二和第三列信息
		还记的cut 来截取df –h 的结果吗？用我们的awk试试吧！
		 

awk的条件
 
	BEGIN
BEGIN是awk的保留字，是一种特殊的条件类型。BEGIN的执行时机是“在awk程序一开始时，尚未读取任何数据之前执行”。一旦BEGIN后的动作执行一次，当awk开始从文件中读入数据，BEGIN的条件就不再成立，所以BEGIN定义的动作只能被执行一次。例如：
 
整个动作定义了两个动作，先打印“this is a transcript”，然后输出过滤后的2和4列
	END
	END也是awk保留字，不过刚好和BEGIN相反。END是在awk程序处理完所有数据，即将结束时执行。END后的动作只在程序结束时执行一次。例如
 其实就是和BEGIN正好相反！
	关系运算符
设定条件，符合条件的才会进行相应动作，不满足不运行
 设定条件为>=30岁的列出。
	awk是列提取命令，第一步的动作却是先读入第一行，整个执行步骤：
	如果有BEGIN条件，则先执行BEGIN定义动作
	如果没有BEGIN条件，则先读入第一行，把第一行的数据依次赋成$0 $1 $2 $3 …等变量，$0 代表整行数据，$1 则为第一个字段，依次类推。
	读入下一行，重复赋值变量
 正则表达式、刚才看到了，我们识别字符串用的是// 这是awk 的正则
 printf 和 print 的区别
 #查看df 的真实分区的使用情况，不看光盘和虚拟磁盘
awk内置变量
 
 

 
#BEGIN的作用，不写的时候直接输出$0 即第一行。
  #将上述命令中的grep “/bin/bash”去掉，sshd是伪用户。 

awk流程控制
	先准备好操作文档，如下
	 
	在awk中定义和调用变量
	 
	
在awk编程中，因为命令语句非常长，输入格式时需要注意以下内容：
	多个条件{动作}可以用空格分割，也可以用回车分割。
	在一个动作中，如果需要执行多个命令，需要用“；”分割，或用回车分割。
	在awk中，变量的赋值与调用都不需要加入“$”符。
	条件中判断两个值是否相同，请使用“==”，以便和变量赋值进行区分。

 
假如年龄小于25岁，则输出 $2 is young man
	 、
按照成绩来过滤，并显示相应信息。

awk函数
awk在编程时允许使用函数，函数定义方法：
function 函数名 （参数列表）{
函数体	
}
 
通过定义的函数格式，去匹配并传递参数。

awk中调用脚本
对于小的单行程序来说，将脚本作为命令行自变量传递给awk是非常简单的，而对于多行程序就比较难处理。当程序是多行的时候，使用外部脚本是很适合的。首先在外部文件中写好脚本，然后可以使用awk的-f选项，使其读入脚本并且执 
awk –f pass.awk /etc/passwd

sed命令
	sed主要是来进行数据选取，替换，删除，新增的命令
	选项：
	-n：一般sed命令会把所有数据都输出到屏幕，如果加入此选择，则只会把经过sed命令处理的行输出到屏幕。
	-e：允许对输入数据应用多条sed命令编辑。
	-f 脚本文件名：从sed脚本中读入sed操作。和awk命令的-f非常类似。
	-r：在sed中支持扩展正则表达式。
	-i：用sed的修改结果直接修改读取数据的文件，而不是由屏幕输出
	动作：
	p：打印，输出指定的行。
	a \：追加，在当前行后添加一行或多行。添加多行时，除最后一行外，每行末尾需要用“\”代表数据未完结。
	i \：插入，在当期行前插入一行或多行。插入多行时，除最后一行外，每行末尾需要用“\”代表数据未完结。
	c \：整行替换，用c后面的字符串替换原数据行，替换多行时，除最后一行外，每行末尾需用“\”代表数据未完结。
	d：删除，删除指定的行。
	s：字串替换，用一个字符串替换另外一个字符串。格式为“行范围s/ 旧字串/新字串/g”（ 和vim中的替换格式类似）

对sed命令我们要知道的是，它所有的修改都不会直接修改文件的内容，而是在内存中进行处理然后打印到屏幕上，使用 -i 选项才会保存到文本中。

行数据操作
显示某行的信息
sed ‘2p’文件
 
-n 显示时只显示指定的行进行显示

删除数据
sed ‘2,4d’文件
 
用sed 删除掉的文件内容并没有真的修改文件

追加、插入数据
sed ‘2[ a | i ]’ 文件名
 
a 在指定行后面追加，i 在指定行前面追加
 
假如要追加多行，则需要用 \ 作为一行的结束，最后一行不需要。
 
-n 的作用是只显示追加部分！
整行替换数据
sed ‘2c No such person’
 

上面我们做了很多操作，但是所有的操作都没有保存到源文件中，假如你确定你就是要修改此文档，请在sed 后面跟上-i 选项，但请一定要小心，（最好是先不带i 预先设置看下结果，然后再加上i选项）
 
字符串替换
c 进行整行替换，假如想进行关键词替换（一行中的一部分），我们需要用s 来进行替换，格式：
sed	‘ns/old/new/g’ 文件名		#n代表第几行
 
顺便把sc 的成绩注销掉，让他补考去吧！
 
将指定内容替换成空
 
sed 要进行多行操作时，只能通过-e 写多条操作语句，用；或回车分隔。
















8.9

sort a.txt | uniq
			
	条件判断：
	
		[ -b /dev/sda1 ] && echo yes || echo no
	
	SUID: 
		可执行文件和命令
	SGID：						权限溢出！
		可执行文件和命令
		目录
	SBIT
		目录
	
	磁盘使用率划分等级：
		0-69	A		正常
		70-89	B		警告
		90-100	C		致命
	
	a=23
	
	a=a23		*23
	
	“”
	
	1.	是否为空
	2.	若不为空，则判断是否包含非数字的内容
		
		sed 将变量中的 数字 替换为 空  赋给另外一个变量
		
			对另外一个变量测试：
				是否为空： 纯数字
				不为空：   有杂质
	

字符处理命令
	sort 排序命令
sort 选项	文件名
	-f	忽略大小写
	-b	忽略每行前的空白部分
	-n	以数值型进行排序，默认使用字符串类型排序
	-r	反向排序
	-u	删除重复行（=下面的uniq）
	-t	指定分隔符，默认分割符是制表符
	-k n[,m]	按照指定字段范围排序，从n字段开始到m字段结束。
sort 命令默认使用每行开头第一个字符进行排序
 
假如 要进行反向排序则需要加-r 选项

按照指定的排序字段进行排序，使用-t 指定分割符 ， 并且使用-k 指定段号
 
#有问题！排序并不是0 1 2 3 。。。
 
oh，好了，看来之前的排序方式是字符排序，而加上-n 之后成为了数值排序。
指定范围时我们可以写 –k 3,5  也可以写3,3 == 3

	uniq取消重复行
uniq用来取消重复行，与sort –u 是一样的，格式：
uniq 选项 文件名
	-i	忽略大小写
 

需要注意的是，当重复行不连续时，uniq是不生效的，需要先排序，再执行
 

条件判断
		按照文件类型进行判断
		 
		使用 [ ] 括号来进行判断，利用 $? 来检测判断结果
		 
		#注意 [ ] 中内容和括号之间有空格
		 
		#我们可以结合之前所学的&& 和 || 实现
		
		按照文件权限进行判断
 
测试：
 

两个文件之间进行比较
 
判断下我们的硬链接
 

两个整数之间进行比较
 
测试
 

字符串的判断
 
测试
 
#字符为空和没有赋值都为空
 

多重条件判断
 
测试：逻辑与
 

逻辑非
 
-n 变量不为空，则为真
！ 加入后，判断取反，所以变量为空才是真
 
流程控制
	if条件判断
		单分支if条件语句
		 
		单分支条件语句比较简单，只需要一个判断条件，符合则执行，不符合则直接退出。
		格式：
		if	[ 条件判断式 ]；then
			程序
		fi
注意事项：
1.	if 语句使用fi结尾，和一般语言使用大括号结尾不一样
2.	[ 条件判断式 ] 就是使用test 命令进行判断，所以中括号和条件判断式之间必须有空格
3.	then 后面跟符合条件后执行的程序，可以放在 [ ] 之后，加；隔开。也可以使用换行写入（用换行就不必写；了）
		if	[ 条件判断式 ]
			then
			程序
		fi
	
	统计根分区使用率？							 

	双分支if条件语句
	 
	
	格式：
if	[条件判断式]
	then
		条件成立，执行的程序
	else
		条件不成立，执行的程序
fi

多分支if分支语句
 
格式：
if	[条件判断式1]
	then
		条件判断式1成立，执行程序1
elif	 [条件判断式2]
	then
		条件判断式2成立，执行程序2
更多………
else
	都不成立，则执行此程序
fi

	练习：判断文件是什么类型的文件的脚本！
		
	case分支语句
case语句和if...elif...else语句一样都是多分支条件语句，不过和if多分支条件语句不同的是，case语句只能判断一种条件关系，而if语句可以判断多种条件关系。
 
case语句语法如下：
		case  $变量名	in
			“值1”）
					变量的值等于值1，则执行程序1
					；；
			“值2”）
					 变量的值等于2，则执行程序2
					；；
			 省略多个分支…………
			  *）
					变量的值都不匹配上面的值，则执行此程序
					；；
		esac
		
	注意事项：
1.	case语句，会取出变量中的值，然后与语句体中的值逐一比较。如果数值符合，则执行对应的程序，如果数值不符，则依次比较下一个值。如果所有的值都不符合，则执行“*）”（“*”代表所有其他值）中的程序。
2.	case 语句以case开头，以esac结尾（切记……）
3.	每一个分支需要用；； 结束，注意是everyone！！！

	练习：写一个源码apache的启动管理脚本

	for循环
	for循环是固定循环，循环次数是有限的次数，也叫计数循环。
	 
	语法一：
		for	变量  in  值1  值2  值3 ……
		do	
			程序
		done
注：这种语法中for循环的次数，取决于in后面值的个数（空格分隔），有几个值就循环几次，并且每次循环都把值赋予变量。也就是说，假设in后面有三个值，for会循环三次，第一次循环会把值1赋予变量，第二次循环会把值2赋予变量，依次类推。
	练习：计算1+2+3+..+10的结果？
	
	语法二：
		for(( 初始值；循环控制条件；变量变化))
		do
			程序
		done
		注：
1.	初始值：在循环开始时，需要给某个变量赋予初始值，如i=1；
2.	循环控制条件：用于指定变量循环的次数，如i<=100，则只要i的值小于等于100，循环就会继续；
3.	变量变化：每次循环之后，变量该如何变化，如i=i+1。代表每次循环之后，变量i的值都加1。
练习：计算1+2+3+..+100的值？

	while循环
	只要条件判断式成立，循环就会一直继续，直到条件判断式不成立，循环才会停止。
		 
		语法：
		while  [ 条件判断式 ]
		do
			程序
		done
		练习：还是1+2+3+..+100=？

	until循环
	until循环和while循环相反，只要条件判断式不成立，则一直循环，什么时候成立，什么时候结束循环
	 
	语法：
		until	[ 条件判断式 ]
		do
			程序
		done
				
函数 function
	语法：
	function	函数名 （） {
		程序
	}
	练习：将1+2+3+..+n写成函数！

特殊流程控制语句
	exit
		系统中的exit是退出当前登录 ， 但是在shell中则只是退出脚本，后续不再进行执行。
	exit [ 值 ]
		exit 退出时如果定义好了返回值，那么我们可以通过“$?”来查看

	break
		当程序执行到break 语句时，会结束当前的循环，直接退出。
		 
	
	continue
		continue只会结束当前的单次循环，将本次跳出继续下次循环。
8.11.
Linux启动管理  
  
启动流程 
1.	按下电源键 
2.	BIOS自检 
 	 	第一阶段：POST（Power-on-self test），主要检测主机硬件设备如：CPU、内  	存、硬盘、显卡等是否正常； 
 	 	在第一阶段完成后会按BIOS中设置的系统启动顺序来搜索可启动的磁盘设备。如：光  	 	盘、硬盘、U盘等；搜到第一个可启动的设备后就读取该设备的第一个扇区的内容并  	 	执行。到此为止BIOS的任务就完成了。 
3.	系统引导 
 	 	MBR（Master Boot Record）:硬盘的0柱面、0磁头、1扇区称为主引导扇区。它
 	 	由三个部分组成，主引导程序(Bootloader)、硬盘分区表DPT（Disk Partition   	 	table）和硬盘有效标志（55AA） 
4.	Linux内核启动 
 	 	Bootloader为引导加载程序，它的主要功能为： 
1、	提供菜单，允许用户选择要启动的系统或不同的内核版本； 
2、	加载选定的内核到内存中，解压、展开，而后把系统的控制权交给内核；   目前Linux中最常用的Bootloader 为GRUB； 
 	 	GRUB引导主要有三个阶段： 
 	 	stage1：作用很简单就是把第一个扇区读取到内存中，但注意stage1是没有识别文  	 	件系统的能力的。 
 	 	stage1.5：作为stage1和stage2的中间桥梁，stage1.5是有识别文件系统的能力 
 	 	的，此后grub才能去访问/boot/grub目录下的stage2文件，并将stage2载入内存中  	 	执行。 
 	 	stage2：被载入内存执行时，它首先会去解析grub的配置文件 	 	 	 
 	 	/boot/grub/grub.conf，然后加载内核镜像到内存中，并将控制权转交给内核。而  	 	内核会立即初始化系统中各设备并做相关的配置工作，其中包括CPU、I/O、存储设  	 	备等。 
5.	初始化系统 
 	 	内核被加载到内存中并且取得了系统的控制权，在取得控制权后内核会立即初始化系  	 	统中的设备，包括CPU、I/O、存储等； 
 	 	关于Linux的设备驱动程序的加载，可能会需要initrd（ramdisk）。因为有一部分驱  	 	动程序会被直接编译进内核文件中，另一部分会被以模块的形式放在initrd中； 
 	 	在初始化硬件及加载各硬件驱动程序后，内核会以只读的方式挂载根文件系统，并且  	 	运行第一个程序/sbin/init。此后系统的控制权就交给了/sbin/init进程了。 
6.	登录系统  	 	/sbin/init进程是系统第一个启动的程序，它是其他所有进程的父进程。当它接管了  	 	系统的控制权先之后，它首先会去读取/etc/inittab文件来执行相应的脚本进行系统  	 	初始化，如设置键盘、字体，装载模块，设置网络等。 
 	 	在niittab中有一个很重要的设置选项runlevel。根据runlevel的不同启动不同的服  	 	务，让Linux的使用环境不同。基本上runlevel分为0-6 ，7个等级： 
 	 	0：关机，shutdown 
 	 	1：单用户模式（sigle user），root用户，无须认证；维护模式； 
 	 	2：多用户模式（multi user），会启动网络功能，但不会启动NFS；维护模式； 
 	 	3：多用户模式（multi user），完全功能模式；文本界面； 
 	 	4：预留级别：目前无特别使用目的，但习惯同3级别使用； 
 	 	5：多用户模式（multi user），完全功能模式，图形界面； 
 	 	6：重启模式， 
 
 	系统初始化的过程主要是执行一些脚本配置文件来完成的： 
1、	执行系统初始化脚本(/etc/rc.d/rc.sysinit)，对系统进行基本的配置，以读写方式  	 	挂载 根文件系统及其它文件系统，到此系统算是基本运行起来了，后面需要进行运行  	 	级别的确定及相应服务的启动。 
 
2、	执行/etc/rc.d/rc脚本。该文件定义了服务启动的顺序是先K后S，而具体的每个运
 	 	行级别的服务状态是放在/etc/rc.d/rc*.d（*=0~6）目录下，所有的文件均是指向
 	 	/etc/init.d下相应文件的符号链接。rc.sysinit通过分析/etc/inittab文件来确定系统的  	 	启动级别，然后才去执行/etc/rc.d/rc*.d下的文件。 
 
3、	执行用户自定义引导程序/etc/rc.d/rc.local 
 	 	完成了系统所有的启动任务后，linux会启动终端或X-Window来等待用户登录。 
 	 	最后一步输入用户名及密码就可以登入系统了。 

配置文件 
 	grub.conf 
 	grub.conf是grub的主配置文件，通过这个配置文件，grub才能找到kernel，系统才能正
 	常启动。 
 
 	default：定义默认启动的操作系统 
 	timeout：定义选择操作系统菜单的等待时间 
 	splashimage：指定我们选择kernel或操作系统菜单后面那张图片。如果定义，这张图片
 	需要用linux自带的软件xmp制作，在图形界面可以打开。图片的特点为： 
     1，必须是xpm的格式   
     2，必须用gzip压缩    
     3，最多使用14位的颜色位数   
     4，分辨率640*480 
 	hiddenmenu：表示隐藏选择k操作系统的菜单，只有出现等待界面后按下enter键才会出  	现。如果没有这个字段，则每次系统启动都会出现这个选择菜单。 
 	title identify：指定一个操作系统，linux中可以有多个title；identify是这个操作系统的  	识别符，可以随意写。  
      	root：用于指定grub所能识别的根，而不是根文件系统。  
       	kernel：用于指定系统的内核文件的位置 
      	initrd：帮助kernel完成系统的启动，例如加载根文件系统所在分区的驱动等。如果  	 	kernel本身有相应强大的功能，则不需要initrd 
 	password：设定密码。放在title外表示进入操作系统等待菜单的编辑模式需要密码，而放  	在title内表示启动对应的操作系统需要密码，密码可以是明文或是用MD5进行加密过的。
 	可以防止其他人进入编辑kernel菜单进入单用户模式启动我们的系统 
 
 
实验： 
 	1. 	背景图片的位置： 
 	splashimage=(hd0,0)/grub/splash.xpm.gz 
 	grub是以hd来识别磁盘的，第一磁盘为hd0，第二个磁盘为hd1...，而hd0,0表示第一个  	磁盘的第一个分区，hd0,1表示第一个磁盘的第二个分区...，并且grub是直接读分区来找  	到对应的文件；而我的系统上只有一块硬盘，并且/boot是一个单独的分区，并且为系统  	的第一个分区，grub等文件在这个分区上。(如果你的系统上/是一个独立分区，并且  	boot，grub和其中的文件都在/这个分区中，则这段应该是：
 	splashimage=(hd0,0)/boot/grub/splash.xpm.gz)所以它的意思是：grub在第一个分区  	中找到grub这个目录，再找到这个图片文件作为背景 
 
 	修改背景图片： 
 	 	生成所需的xpm格式的图片文件 
 	 	使用ImageMagick命令将普通的.jpg.bmp等生成xpm文件 
  convert –resize 640x480 -colors 14 源文件 生成文件   gzip 文件名  
 	 	将生成的文件导入到/boot/grub/下（导入前先将源文件备份） 
 
2.	grub 加密： 
 	password --md5 $1$UrprW0$UzN7ozenwICzcPCQgiFts1 
表示要想进入kernel的编辑菜单，需要输入密码。这个密码可以通过命令grub-md5 	crypt生成。 
a.	密码添加在title前面 
	  	 	将密码放在这个位置时，在选择grub菜单时就需要输入密码了。 
b.	密码添加在title后面 
	  	 	密码在这个位置时，选择完操作系统后，在进入系统引导时才需要输入密码。 
 
3.	root密码找回 
a.	重启系统后出现GRUB界面在引导装载程序菜单上，用上下方向键选择你忘记密  	 	码的那个系统键入“e” 来进入编辑模式。 
b.	接下来你可以看到如下图所示的画面，然后你再用上下键选择最新的内核（这里  	 	是第二行，kernel..），然后继续按“e”键。 
c.	然后在编辑界面rhgb quiet后面加“空格”，然后键入“single”，或者直接输  	 	入数字的“1”并回车确定。 
d.	回车后，按“b”键启动进入单用户模式，在这里修改root的密码。 
 
4.	手动安装grub 
  	一般在grub被覆盖的情况下我们需要进行手动的安装grub到我们的MBR中，那现在  	 	的问题是grub已经损坏了，我们没有一个可以交互写命令的地方了，应该怎么设置  	 	呢？so…我们要借助光盘上的拯救模式。 
  	   	根据提示加载光盘上的虚拟系统后，我们需要手动安装下grub 
a.	chroot /mnt/sysimage 
  	由于是光盘启动的救援模式，so….它的根目录是虚拟的，我们需要用chroot命令将真  	 	根目录挂载回来 
b.	执行grub 进入交互界面    root （hd0,0） #设置grub的主目录    setup （hd0） #直接将grub安装到MBR中，不需要指定分区（硬盘开头）    quit 
c.	重启 
 
内核模块   	模块 位置： 
	  	 	/ib/modules/2.6******/kernel/ 
	  	模块保存文件： 
  	 	/ib/modules/2.6******/modules.dep   	模块同步到modules.dep中   	 	depmod  	   	 	 	-a 扫描所有，并写入*.dep 
  	 	 	-A 扫描新模块，并写入*.dep   	 	 	-n 显示到屏幕，不写入*.dep   	查看内核模块   	 	lsmod 	查询所有模块的信息   	 	modinfo  	查询某模块的简单信息 
 
  添加删除内核模块    modprobe [选项] 模块    a. 下载到相应的模块 
b.	复制到指定位置，一般/ib/modules/2.6******/kernel/ 
c.	用depmod进行扫描，将新模块写入modules.dep文件中 
d.	用modprobe进行安装 
 
	  	 	eg： 
  	 	 	modprobe 	vfat  	 	 	#添加 
  	 	 	lsmod 	vfat | grep vfat 	 	#查看 
  	 	 	modprobe 	-r 	vfat  	 	#删除 
  	 	 	lsmod 	vfat | grep vfat 	 	#查看 




		
8.11
Linux服务管理
	lilo 引导
	
	grub引导	grub1 
				grub2
	
	init 进程 （守护进程、父进程、主进程）
	
	
	1.	BIOS - boot
	2.	GRUB - MBR&GPT
	3.	内核 - 硬件之间的协同工作
	3.	init - 管理所有进程的
	
	
	1.	bios 密码（不影响启动，需要修改bios时才需要输入密码）
	2.	硬盘密码（只要读取数据就必须输入密码，会影响开机）
	3.	GRUB 密码：
		a、是否允许编辑菜单（不影响系统启动）
		b、指定系统的加载的密码（会影响操作系统的启动）
	4.	系统级别
		root MM
		zhangsan MM
	
	iptables ：
	
		iptables -A INPUT -p tcp -s $ip -j DROP
		
	强制注销：
		
		pkill -9 -t  $pts 
	
	
	文件切割命令
	
		split -b  100M 	a.txt  a

		split -b  切割后的大小		源文件		生成的文件名的前缀（后缀默认是字母）

		split -l  行数				源文件

服务分类
 
二进制包
	1.	快速安装、卸载、升级和管理软件
	2.	安装简洁、速度快
	3.	经过封装，无法直接获取源代码
	4.	功能选择性差，功能定制不灵活

源码包
	1.	获得最新的软件版本，及时修复bug
	2.	根据用户需要，灵活定制软件功能
	
RPM包的服务管理
RPM包所安装的软件有特定的管理命令，管理方式分为两种：

	独立服务：
所谓的独立启动，就是可以自行管理启动，和其他的软件的启动与否没有关系，不依赖其他软件的启动，此类软件当被调用时会直接响应，处理请求的速度快。目前Linux中绝大多数服务为独立服务。

	手动启动：
1.	启动脚本启动，/etc/init.d/某服务脚本文件
		/etc/init.d/httpd start
		2.	service服务管理工具
		service httpd start | stop | restart 
	自启动：
		1.	使用chkconfig服务自启动工具管理
			查看软件的自启动：
			chkconfig –list | grep 服务名
			设置某服务的自启动：
			chkconfig	[--level 级别]	 [独立服务名] [on | off]
		2.	使用ntsysv工具设置自启动软件
			netsysv	--level 级别			#设置某级别下软件是否自启动
			F1 ：显示服务的说明信息	

	基于xinetd的服务：
此类服务无法独立启动，必须依赖某一管理服务来启动或者关闭，这个管理服务就是我们xinetd服务了，此服务是Linux的超级守护进程，专门用来管理那些无法自行启动的服务，当客户端请求服务启动时，请求会先被xinetd服务接受，然后xinetd去唤醒对应的服务，打到启动某服务的目的。这类服务不会一直处于开启状态，只有在xinetd服务接受到请求的时候才会唤醒对应服务，处理完后服务关闭，这样大大节省了服务器的资源，但是对应的软件的反应速度没有独立服务反应快。


	基于xinetd服务的—telnet
此处我们用telnet服务来举栗子！telnet是远程管理命令，但由于传输过程是明文，so… 我们不选用他，我们使用更安全的ssh，telnet的端口是23，我们借助xinetd来启动下我们的telnet。

	1.	手动启动xinetd中的某服务
		vim	/etc/xinetd.d/telnet
		 
		此处我们只需要将disable = yes   修改成 no 即可！
		然后重新启动xinetd服务（注意我们现在是借助xinetd来管理的telnet） 
		
	2.	设置xinetd内的服务自启动
同样借助chkconfig 和 ntsysv 来实现自启动，但是这个地方我们需要注意的是，我们不是设置某个具体服务的自启动，而是设置的xinetd的自启动。

源码包的服务管理
	1.	源码包服务的手动启动—指定路径启动
		eg. /usr/local/apache2/bin/apachectl start | stop | restart …………
	2.	源码包服务的自启动
		借助/etc/rc.d/rc.local 或者 /etc/rc.local 
		写入手动启动命令即可
	
	3.	让系统识别源码包
		对照刚才看的RPM包安装的httpd的启动脚本文件我们自己写一个让系统识别我们的源码软件。
		
		注意：脚本中有两句话必须存在！作用让chkconfig识别此脚本，并能执行。
Linux系统管理 
 
进程管理 
 	 	进程是什么？ 
 	 	 	代替人管理操作系统内的程序，完成特定任务，解决特定问题的一段代码集合！ 
 
 	 	进程的作用？ 
 	 	 	判断服务器的健康状态： 
 	 	 	 	我们可以通过观察服务器的CPU 内存等占用率来提前发现问题，及时解
 	 	 	 	决，避免发生宕机或者服务卡死！ 
 	 	 	查看系统内的进程是否合法： 
 	 	 	 	我们要经常过滤进程中查看是否有非法进程在运行，避免信息的泄露或损坏 
 	 	 	杀死进程： 
 	 	 	 	通过特定的命令我们可以将制定的进程杀死，此处先以正常的服务管理方式
 	 	 	 	来处理进程（service等），假如进程卡死正常的无法进行，则需要通过特
 	 	 	 	殊命令进程杀死进程（kill等）。 
 
 	 	 	进程的查看 
 	 	 	 	1. 	ps 命令 
 	 	 	 	ps 静态查看系统中的进程，查询的是命令执行一瞬间的进程的状态。 
 	 	 	 	 	aux  	以BSD操作系统的格式输出 
 	 	 	 	 	le 	 	以Linux标准格式输出 
 	 	 	 	 	选项详解： 
 	 	 	 	 	 	a 	显示一个终端的所有进程 
 	 	 	 	 	 	u 	显示进程的归属用户及内存的使用情况 
 	 	 	 	 	 	x 	显示没有控制终端的进程 
 	 	 	 	 	 	l 	长格式显示，更加详细的信息 
 	 	 	 	 	 	e 	显示所有进程 与a的作用一致 
 	 	 	 	结果分析： 
 	 	 	 	  
 	 	 	 	USER： 该进程的运行用户，或者理解为产生进程的用户 
 	 	 	 	PID： 	进程的PID号 
 	 	 	 	%CPU： 进程占用的cpu的百分比 
 	 	 	 	%MEM：进程占用物理内存的百分比 
 	 	 	 	 VSZ： 占用的虚拟内存的大小 KB 
 	 	 	 	 RSS： 占用物理内存的大小 	KB 
 	 	 	 	 tty： 	登录终端  	 	 	alt+F1-F6 
 	 	 	 	 	 	tty 本地登录  	pts/（0-255） 远程终端 
 	 	 	 	 STAT： 
 	 	 	 	 	D 无法中断的休眠状态（通常 IO 的进程） 
R	正在运行的进程 
S	处于休眠状态 T 停止或被追踪 
W	进入内存交换  （从内核2.6开始无效） 
X	死掉的进程   （基本很少见） 
Z 僵尸进程 
< 优先级高的进程 
N 优先级较低的进程 L  被锁进内存的进程 
s  进程的领导者（在它之下有子进程） 
l   多进程的（使用 CLONE_THREAD, 类似 NPTL pthreads） 
+ 位于后台的进程组 
START 进程启动时间 
	TIME 	进程运行的时间，非系统时间 
COMMAND 产生此进程的命令 
 
ps -le  
	 	F 	 	进程标志，说明进程有那些权限 
	 	 	1 	进程可以复制 
	 	 	4 	进程使用超级用户权限 
	 	S 	 	进程状态 
	 	PPID 	进程的父进程ID号 
	 	C 	 	cpu占比 %  
	 	PRI  	进程优先级，数字越小优先级越高，越快被调用执行 
	 	NI  	进程优先级，数字越小越先被调用 
 	ADDR 	进程存在内存的位置  	SZ  	进程占用的内存大小 
	 	WCHAN 进程是否运行  	-  代表正在运行 
 
top 命令 
	 	选项： 
 	-d 秒数  	指定刷新频率 
 	-b  	 	使用批处理模式，和-n结合将top的结果重定向到文本 
 	-n 次数  	指定top 次数，和-b结合 
 	-p  	 	指定查看某的PID的进程 
 	-s 	 	 	使top在安全模式下运行，避免在交互模式下出现错误 
 	-u 用户名 	只查看（监听）某一个用户的进程  	在交互模式下使用的命令： 
	 	？或h   	帮助信息 
	 	P 	 	 	按照CPU使用率排序 
M	按照内存使用率排序 
N	按照PID号排序 
	 	T 	 	 	按照cpu运算时间排序 
 	k 	 	 	按照PID号给予某一个进程信发送指令，一般用于杀死进  	 	 	 	程 9 
 r   按照PID 给某个进程重设优先级（Nice）值  q   退出交互模式 
 
top 结果分析 
  第一行信息： 
  第二行信息： 
  
第三行信息： 
  第四行信息： 
  第五行信息： 
  剩下的选项基本和我们的PS 是相同的。 
 
	pstree 	进程树 
	 	-p 显示PID 
	 	-u 显示运行用户 
 
进程处理命令： 
	 	kill -l 	或者  man 	7  signal 查看信号 
	 	  
 kill 进程号   kill -1  PID  重启某服务或进程   kill -19 PID  #哪我们的vim 文件来实验下！ 
	 	 	ps aux | grep “vi” | grep -v“grep” 
 	 	 
 	killall 	进程名称  	 	killall 	-i 	交互式，询问是否杀死  	 	killall 	-I 	忽略大小写 
 
	 	pkill  终端号  
	 	 	-t 	根据终端号杀死 
 
进程优先级 ps –le 	可以查看到进程的优先级  	PRI代表的是Priority，NI代表nice 两个都是优先级，但是PRI不能修
改，因为这是内核内定义的，无法人为修改，但是我们能修改NI ，看公
式：PRI（最终值）=PRI（原值）+NI 
我们可以通过这样的方式改变优先级，但是NI也有限制。 
	 	NI值范围：-20 到 19 
	 	普通用户的NI值 : 0 到 19 
	 	普通用户只能调高NI值，不能降低 
	 	root可以随意调整，包含其他用户的进程 
nice  命令 
	 	此命令可以直接修改NI的值nice –n 数值 
	 	nice –n -5  service httpd start 
	 	ps –le | grep “httpd” | grep –v “grep” 
renice 命令 
	 	修改已存在的（启动状态）的nice值 
	 	renice -10 PID 
 
 工作管理 
 	 	工作管理注意事项：  	 	 	前台：当前终端标准输出到显示器上的正在进行的工作；后台：将  	 	 	当前正在进行的工作放到后台，并且能持续不间断的工作的叫后台
 	 	 	（后台的不能进行ctrl+c结束）  	 	 	当前终端的工作只能当前终端管理，其它终端不能管理。 
 	 	 	放入后台的工作必须是能持续运行一段时间的，否则无法捕获工作  	 	 	进程 
 	 	 	放入后台的工作不能是需要进行交互操作的，否则程序会被暂停 
 	 	 
 	 	如何将工作放到后台执行 
1.	命令 & 
2.	ctrl + z       	 	后台命令的管理 
1.	查看： jobs 
 	 	 	 	-l 显示工作进程PID 
2.	将后台暂停的工作恢复到前台继续执行     fg %工作号   # %可省略，主要是却别PID的 
3.	将后台暂停的工作恢复到后台继续执行  	 	 	 	bg %工作号 
4.	让后台的工作脱离终端进行运行 
a.	rc.local 
b.	定时计划任务（下边） 
c.	nohup [命令] & 
 	 	 	 	我们使用nohup执行某些命令或者脚本，让他在没有用户登录  	 	 	 	的情况下执行某些任务 
 
系统资源查看 
 	 	1. vmstat  	监控系统资源  	 	 	vmstat  	刷新频率 	刷新次数  	 	 	显示信息分析： 
 	 	 	Procs（进程）： r: 运行队列中进程数量 b: 等待IO的进程数量，即阻塞的进程 
Memory（内存）： swpd: 虚拟内存大小 free: 可用内存大小 buff: 用作缓冲的内存大小 cache: 用作缓存的内存大小 
Swap： 
si:  Amount of memory swapped in from disk (/s). so: Amount of memory swapped to disk (/s). 
IO：（现在的Linux版本块的大小为1024bytes） bi: 每秒读取的块数 bo: 每秒写入的块数 
系统： in: 每秒中断数，包括时钟中断。 cs: 每秒上下文切换数。 CPU（以百分比表示）： 
us: 用户进程执行时间(user time) sy: 系统进程执行时间(system time) id: 空闲时间(包括IO等待时间) wa: 等待IO时间 
 
2.	dmesg 
	 	查看开始是内核的检测信息 
	 	dmesg  	| 	grep 	cpu 
	 	dmesg  	| 	grep 	eth0 
 
3.	free 	查看内存使用情况 
	 	 	-b 以字节为单位显示 
	 	 	-k 以KB为单位（默认） 
  -m 以MB为单位   -g 以GB为单位  显示信息解释： 
total:总计物理内存的大小。 used:已使用多大。 free:可用有多少。 
Shared:多个进程共享的内存总额。 
Buffers/cached:磁盘缓存的大小。 
第三行(-/+ buffers/cached): 
used:已使用多大。 free:可用有多少。 
第四行就不多解释了。。。。 
4.	查看cpu信息 
	  	cat /proc/cpuinfo  
   processor     逻辑处理器的id。    physical id    物理封装的处理器的id。    core id       每个核心的id。 
   cpu cores  位于相同物理封装的处理器中的内核数量。    siblings   位于相同物理封装的处理器中的逻辑处理器的    数量。 
	  	 	逻辑CPU个数： 
  	 	# cat /proc/cpuinfo | grep 'processor' | wc -l   	 	物理CPU个数： 
  	 	# cat /proc/cpuinfo | grep 'physical id' | sort | uniq | \   	 	wc -l 
	  	 	每个物理CPU中Core的个数： 
	  	 	# cat /proc/cpuinfo | grep 'cpu cores' | wc –l 
 
	5. 	查看本机登录信息： 
显示项目按以下顺序排列： 
 	 	当前时间，系统启动到现在的时间，登录用户的数目，系统在最近1秒、5秒和15秒的平均负载。 
 	 	每个用户的各项数据，项目显示顺序如下：登录帐号、终端名称、远程主机名、登录时间、空闲时间、JCPU、
PCPU、当前正在运行进程的命令行。 
 	 	 	其中JCPU时间指的是和该终端（tty）连接的所有进程占用的时间。这个时间里并不包括过去的后台作业时间，但却包括当前正在运行的后台作业所占用的时间。而PCPU时间则是指当前进程（即在WHAT项中显示的进程）所占用的时间。 
 
6.	uptime  
	     	系统启动时间和平均负载（一般用top） 
7.	查看系统与内核相关信息 
	  	uname  
	  	 	-a 查看所有相关信息 
-r	查看内核版本 
-s	查看内核名称 
	  	file 文件或者命令 
	  	 	确定当前操作系统位数 
	  	lsb_release 	-a  
	  	 	查看当前发行版 
8.	lsof 	列出进程打开或正在使用的文件信息   	lsof 	文件名  	#查看某文件被哪个进程所调用   	lsof 	-u  	 	#查看用户运行的进程调用了哪些文件 










8.15系统定时任务 
####总结
选择器：
			*.*
			第一个* 代表服务类型
			第二个* 代表日志等级
			. 	记录指定等级及以上等级的信息
			.= 	只记录指定等级的信息
			.!	不记录指定等级的信息（除了该等级以外的信息进行记录）

			，	多个服务时，使用逗号分隔
			；	多个选择器之间，使用分号分隔
		日志记录位置：
			1.	指定的本地文件/var/log/*
				/usr/local/apache2/logs/*		#源代码apache的日志
			2.	指定的远端服务器（日志收集服务器）
				客户端和服务器 所使用的协议一致！ UDP & TCP
				
		rsyslog 服务通过匹配配置文件中的规则进行日志的分类记录。
		/etc/cron.daily/logrotate		每天执行一次
		
		#每天检查是否有遗漏的轮询任务未执行。					
									
		/etc/rsyslog.conf		日志管理服务（日志记录器）
		/etc/logrotate.conf		日志轮替服务
		/etc/cron.daily/*		定时计划任务中的每天执行的目录
									
		日志收集服务器搭建！
		日志的轮替和切割脚本！
							
1.	在指定脚本中添加指定内容  
				chkconfig：2345 n n
				discriptions：aaaaaaaaaaaa
2.	chkconfig --add /etc/init.d/apache2					
3.	chkconfig --list | grep "apache"	
####系统定时任务			
  1. 单次计划任务  at    at 命令的执行需要依托atd服务的启动，so….. 
   service atd start    
 chkconfig atd on 
 	 	 	限制用户使用at 命令 
             /etc/at.allow  #白名单     /etc/at.deny  #黑名单 
 	 	 	 白名单的优先级大于黑名单  	 	 	 	
假如黑白名单都不存在，只有root能使用at命令  	 
	 	
at [选项] 时间 
 	 	 	 	-m  	#执行结束发送通知邮件（执行此命令的用户） 
一般使用“at  时间”即可，ctrl +D结尾
 
 	 	 	 	atq  	#查看计划任务   atq
 	 	 	 	atrm 	#删除计划任务   atrm
 	 	 	 	-c         	-c  工作号 #查看对应工作号的详细信息 
 	时间格式： 
 	       [HH:MM] [yyyy-mm-dd]  	(now2minutes)
at now+2min                         任务两分钟之后执行
                写完后用ctrl + d 结束并保存任务  	 	2. 循环计划任务  	crontab  	 	 	按照预先设置好的时间周期，定期执行特殊动作（命令、脚本）  	 	 	格式： 
编辑：crontab -e  #添加循环计划任务     
查看：crontab -l  #查看已存在的计划任务      
 删除：crontab -r  #删除已存在的计划任务    时间格式： 
 	 	 	 	  
 	 	 	 	* 	   表示该范围内的任意时间 
	 	 	,       表示间隔的多个不连续时间点 
	 	 	- 	   表示一个连续的时间范围 
	 	 	/ 	   指定间隔的时间频率 
	 	例子： 
 	 	0  17  *  *  1-5 	 	周一到周五每天 17:00  
 	 	30  8  *  *  1,3,5  	每周一、三、五的 8 点 30 分 
 	 	0  8-18/2  *  *  *  	8 点到 18 点之间每隔 2 小时 
 	 	0  *  */3  *  *  	 	每隔 3 天 





































Linux日志管理 
 
 	Linux系统内核和许多程序会产生各种错误信息、警告信息和其他的提示信息，这些信息对管理员了解系统的运行状态是非常有用的，所以应该把它们写到日志文件中去。完成这个过程的程序就是syslog。syslog可以根据日志的类别和优先级将日志保存到不同的文件中。例如，为了方便查阅，可以把内核信息与其他信息分开，单独保存到一个独立的日志文件中。默认配置下，日志文件通常都保存在“/var/log”目录下。 
 
日志相关服务 
 	CentOS 6.X 以后日志的管理服务从syslogd 升级成为了 rsyslog ，增强了部分功能。 
 	 	基于TCP网络协议传输日志信息 
 	 	更安全的网络传输方式 
 	 	有日志消息的及时分析框架 
 	 	后台数据库 
 	 	配置文件可以写一些简单的逻辑判断 
 	 	兼容syslogd配置文件 
 	常见的日志文件 
 
 
 
这些都是系统默认的日志，以及存放位置，那么除此之外我们还有一些RPM或者源码的软件安装产生的日志。 
 
那么源码的日志则存放在了指定安装的位置下。 
 
 
 
rsyslog 服务 
 	 	日志的格式： 
 	 	只要是通过rsyslog记录的日志，格式是相同的，包含以下内容：  	 	 	发生时间  	 	 	服务器的主机名  	 	 	服务名或者程序名 
 	 	 	事件具体信息 
 	 	rsyslog 配置文件： 
 	 	 	/etc/rsyslog.conf 
 	 	 	   	 	 	第一列为日志类型和日志优先级的组合，每个类型和优先级的组合  	 	 	称为一个选择器；后面一列为保存日志的文件、服务器，或输出日
 	 	 	志的终端。syslog 进程根据选择器决定如何操作日志。 
 
 	 	对配置文件的几点说明： 
	日志类型和优先级由点号(.)分开，例如 kern.debug 表示由内核产生的调试信息。 
	kern.debug 的优先级大于 debug。 
	星号(*)表示所有，例如 *.debug 表示所有类型的调试信息， kern.*表示由内核产生的所有消息。 
	可以使用逗号(,)分隔多个日志类型，使用分号(;)分隔多个选择器。 
 	 	对日志的操作包括： 
	将日志输出到文件，例如 /var/log/maillog 或 
/dev/console。 
	将消息发送给用户，多个用户用逗号(,)分隔，例如 root, 
amrood。 
	通过管道将消息发送给用户程序，注意程序要放在管道符(|)后
面。 
	将消息发送给其他主机上的 syslog 进程，这时 
/etc/syslog.conf文件后面一列为以@开头的主机名，例如
@see.xidian.edu.cn 
 	服务名称  	 	 	rsyslog 是别的服务才能写到配置文件中 
 	 
 	  
 
 	连接符号： 
 	 日志服务 [ 连接符号 ] 日志等级  日志记录位置 
 “.” ：代表只要比后面的等级高的（包含该等级）日志都记录下
来。比如：“cron.info”代 表 cron 服务产生的日志，只要日志等级大于等于 info 级别，就记录 
 “.=”代表只记录所需等级的日志，其他等级的都不记录。比如：
“*.=emerg”代表人和日志服务产生的日志，只要等级是 emerg 等级就记录。这种用法及少见，了解就好 
 “.!”代表不等于，也就是除了该等级的日志外，其他等级的日志都记录。 
 
 	日志等级： 
 	   	特殊等级：none 不记录任何等级，相当于忽略该服务 
 
 	日记记录位置： 
 	 	日志文件的绝对路径。这是最常见的日志保存方法，如
“/var/log/secure”就是保存系统验证和授权信息日志的。  	 	系统设备文件。如“/dev/lp0”代表第一台打印机，如果日志保存位置是打印机设备的话，当有日志时就会在打印机打印（不太符合可持续发展战略哦-_-!）。 
 	 	转发给远程主机。因为可以选择使用 TCP 协议和 UDP 协议传输日志信息，所以有两种发送格式。如使用“@192.168.0.210:514”，就会把日志内容使用 UDP 协议发送到 192.168.0.210 的 UDP 514 端口上；如果使用“@@192.168.0.210:514”就会把日志内容使用 TCP 协议发送到
192.168.0.210 的 TCP 514 端口上，其中 514 是日志服务默认端口。当然只要 192.168.0.210 同意接收此日志，就可以把日志内容保存在日志服务器上。 
 	 	用户名。如“root”，就会把日志发送给 root 用户，当然 root 要在在线，否则就收不到日志信息了。发送日志给用户时，可以使用“*”代表发送给所有在线用户，如“mail.* *”就会把 mail 服务产生的所有级别的日志发送给所 
 	 	有在线用户。如果需要把日志发送给多个在线用户，用户名之间用 “，”分隔。忽略或丢弃日志。如果接受日志的对象是“”，代表这个日
志不会记录，而被直接丢弃。如“local3.* ~”代表忽略 local3 服务类型所有的日志都不记录。 
 
自定义日志记录： 
 	vi /etc/rsyslog.conf 
 	*.crit   	 	/var/log/alert.log 
 	将所有临界点以上的错误都记录到alert日志中 
 	修改完成，重启rsyslog服务，检查下有没有生成文件。日志服务器搭建：  	接收端： 
 	 	配置文件：（有UDP和TCP） 
      取消注释，让接受端口生效。 
 	 	重启服务，然后查看端口是否生成  	发送端： 
 	 	修改配置文件： 
 	 	 	添加： 
 	 	 	*.*  	 	@192.168.110.111:514 
 	 	 	注意：可以使用UDP 用一个@ ； 也可以使用TCP 要用两个@@  	 	 	重启服务，OK 
 	测试： 
 	 	在发送端，创建用户，然后检查接收端，查看日志/var/log/secure 
 
 	注意事项：都知道Linux不依靠主机名识别，但是日志服务器需要根据主机  	来识别，so。。。我们如果一台记录多台的日志信息，需要修改主机名。日志轮替 
 	 	主要目的防止单个日志文件过                     大，按照我们的规则对日志进行相应处理  	主要依赖/etc/logrotate.conf配置文件中的dateext参数实现日志的处理。 
 	 	主要参数解释： 
 	 	 	weekly  	 	每周对日志进行依次轮替 
 	 	 	rotate  	 	保存日志的数量 
 	 	 	create  	 	在轮替过程中，自动创建新的文件 
 	 	 	dateext 	 	使用日期作为日志文件的后缀 
 
 
 
 
 	系统自动定期进行日志轮替的原因： 
 	 	/etc/cron.daily/ 	有一个脚本，每天都会运行，查看是否有符合轮替  	 	的日志，然后进行相应处理 
 
 	 	我们尝试在rsyslog配置文件中添加自己的日志记录，然后并且强制执  	 	行轮替，看会不会产生轮替文件 
1.	先在配置文件中写入自己的日志轮替规则（参照原文中的） 
2.	强制执行日志轮替（不管符不符合规定时间）    logrotate  –vf  /etc/logrotate.conf 






































Linux备份管理 
 
Linux中需要备份的数据 
1.	Linux系统重要数据 
	/root/目录：/root目录是管理员的家目录，很多管理员会习惯于在
这个目录中保存一些相关数据，那么当进行数据备份时，需要备份
此目录。 
	/home/目录：/home/目录是普通用户的家目录，如果是生产服务
器，这个目录中也会保存大量的重要数据，应该备份。 
	/var/spool/mail/目录： 默认情况下，所有的用户未读的邮件会保
存在/var/spool/mail/目录中和用户名相同的邮箱文件中，已读的邮件会保存在用户家目录中mbox文件中（mail命令默认是如此保存，不过如果使用了hold命令，那么不管邮件是否已读，都保存在
/var/spool/mail/目录中，可以使用mbox命令恢复已读邮件保存在“~/mbox”文件中）。一般情况下，用户的邮件也是需要备份
的重要数据。 
	/etc/目录：系统重要的配置文件保存目录，当然需要备份。 
	其他目录：更具你的系统的具体情况，备份自己认为的重要目录。比如我们的系统中有重要的日志，或者安装了RPM包的mysql服务器（RPM包安装的mysql，数据库保存在/var/lib/mysql/目录
中），那么/var/目录就需要备份。如果我们服务器中安装了多个操作系统，或编译过新的内核，那么/boot/目录就需要备份。 
2.	安装服务和软件的数据 
 
	 	 	apache需要备份如下内容： 
	配置文件。RPM包安装的apache，需要备份
/etc/httpd/conf/httpd.conf；源码包安装的apache则备份
/usr/local/apache2/conf/httpd.conf。 
	网页主目录。RPM包安装的apache，需要备份
/var/www/html/目录中所有数据；源码包安装的apache需要备份/usr/local/apache2/htdocs/目录中所有数据。 
	日志文件。RPM包安装的apache，需要备份/var/log/httpd/ 目录中所有日志；源码包安装的apache需要备份
/usr/local/apache2/logs/目录中所有日志。 
 
mysql服务需要备份如下内容： 
	mysql需要备份的内容就没有apache多了，主要需要备份的就是数据库内容。 
	源码包安装的mysql，数据库安装/usr/local/mysql/data/目录
中，只要备份此目录即可 
	RPM包安装的mysql，数据库默认安装到了/var/lib/mysql/目
录中，如果需要备份则需要备份这个目录。 
 
 
备份策略 
 	完整备份 	 
 	完全备份就是指把所有需要备份的数据全部备份，当然完全备份可以备份整块硬盘，整个分区或某个具体的目录。完全备份的好处是数据恢复方便，因为所有的数据都在同一个备份中，所以只要恢复完全备份，所有的数据都会被恢复。如果完全备份备份的是整块硬盘，那么甚至都不需要数据恢复，只要把备份硬盘安装上，服务器就会恢复正常。可是完全备份的缺点也很明显，那就是需要备份的数据量较大，备份时间较长，占用的空间较多，所以完全备份不可能每天执行。 
我们一般会对关键服务器进行整盘完全备份，如果出现问题，可以很快的使用备份硬盘进行替换，从而减少损失。甚至会对关键服务器搭设一台一模一样的服务器，这样只要远程几个命令（或使用shell脚本自动检测，自动进行服务器替换），备份服务器就会接替原本的服务器，使我们的故障响应时间缩短为最短。 
 
增量备份 
完全备份随着数据量的加大，备份耗费的时间和占用的空间会越来越多，所以完全备份不会也不能每天进行。这时增量备份的作用就体现了出来。增量备份是指先进行一次完全备份，服务器运行一段时间之后，比较当前系统和完全备份的备份数据之间的差异，只备份有差异的数据而已。服务器继续运行，再经过一段运行时间之后，进行第二次增量备份，第二次增量备份时，当前系统是和第一次增量备份的数据进行比较，也是只备份有差异的数据。第三次增量备份是和第二次增量备份的数据进行比较，以此类推。
 
假设我们第一天时，进行一次完全备份。第二天增量备份时，只会备份第二天和第一天之间的差异数据，但是第二天的总备份数据是完全备份加第第一次增量备份的数据。第三天增量备份，只会备份第三天和第二天之间的差异数据，第三天的总备份数据是完全备份，加第一次增量备份的数据，再加第二次增量备份的数据。当然第四天增量备份时，只会备份第四天和第三天的差异数据，数据时完全备份加第一次增量备份加第二次增量备份加第三次增量备份的数据。这种备份的好处是每次备份需要备份的数据较少，耗时较少，占用的空间较少。坏处是数据恢复比较麻烦，如果是上图的例子，那么当数据恢复时，就要先恢复完全备份的数据，再依次恢复第一次增量备份的数据，第二次增量备份的数据和第三次增量备份的数据，最终才能恢复所有的数据。 
差异备份相比较而言，既不要像完全备份一样把所有数据都进行备
份，也不像增量备份数据恢复时那么麻烦。只要先恢复完全备份的数据，再恢复差异备份的数据即可。不过随着时间的增加，和完全备份相比，变动的数据越来越多，那么差异备份也可能会变得数据庞大，备份缓慢，占用空间较大。 
 
备份与恢复工具：dump 和 restore  	dump 
	 	dump 支持0-9十个备份级别，0指完整备份，1-9指增量备份 
我们备份一个数据时，第一次备份应该使用0级别，会把所有数据
完全备份一次。第二次备份时就可以使用1级别了，它会和0级别比较，把0级别备份之后变化的数据进行备份。第三次备份时，使用2级别，2级别是和1级别比较，把1级别备份之后变化的数据进行备份，以此类推。需要注意的是，只有备份整个分区或整块硬盘时，才能支持1-
9的增量备份级别。而如果只是备份某个文件或不是分区的目录，则只能使用0级别进行完全备份。 
dump [选项] 备份之后的文件名 源文件名 
	 	-level  	 	0-9十个备份级别 
	 	-f 文件名  	指定备份后的文件名 
-u	备份成功，把备份时间记录在/etc/dumpdates中 
-v	显示详细信息 
	 	-j  	 	 	调用bzlib库压缩备份文件，（.bz2）压缩等级2 
备份分区： 
	 	 	df –h  查询当前能进行备份的分区信息 
	 	 	dump -0uj 	-f /root/boot.bak.bz2 	/boot 
 	 	 	#第一次先进行完整备份，并且压缩写入备份时间  	 	cat /etc/dumpdates 
	 	 	 	#查看备份时间 
	 	 	修改/boot/分区内的信息，进行第二次备份 
	 	 	dump -1uj 	-f /root/boot.bak1.bz2 /boot/ 
	 	 	 	#进行第二次备份，使用1级别，即增量备份 
 	 	 
	 	 	dump -W  
 	 	 	查询系统内进行过dump备份的分区，以及级别和时间。  	 	注意：目录的备份只能使用完整备份，无法使用增量备份。 
 
	restore 	 
 	 	restore [模式选择] [选项]  	 	模式：  
-C 比较备份数据和实际数据的变化。如果实际数据中的现有
数据发生了变化，这个选项能够检测这个变化。但是如果实际数据新增了数据，这个选项是不能检测到变化的。 
-i 交互模式，一般进行恢复时文件选择 
-t 查看模式，查看备份文档中的内容 
-r 还原模式，还原数据 
-f 指定备份文件的名称 
 
比较备份数据和实际数据的区别，根据刚才我们的备份，进行对比首先创建新的文件 
	 	touch /boot/a.txt 
进行数据的比对 
	 	restore -C  -f /root/boot.bak.bz2 
 	 注意：这样的比较无法比较出新增的信息，只能比对出减少的和修
改的。 
 
查看模式： 
	 	restore –t –f /root/boot.bak.bz2 
还原模式  	首先创建恢复目录，然后进行恢复 
	 	restore -r –f /root/boot.bak.bz2 
	 	第一次是恢复原始数据 
	 	restore -r –f /root/boot.bak1.bz2 
	 	第二次进行增量备份的恢复 


		



























8.21
一．网络配置
1.修改主机名
临时生效
	查看主机名：hostname
	设置主机名
		格式：hostname   主机名
		注：主机名尽量使用FQDN名称（可以重名，不同于windows的UNC路径的wins服务）


永久生效
	修改 /etc/sysconfig/network 文件
	设置主机名
		方法：HOSTNAME=主机名

centos7
	hostnamectl set-hostname xx

2.IP配置
IP配置
	查看：ifconfig
	设置：ifconfig  网络接口  IP地址  netmask  子网掩码
	永久配置 ：/etc/sysconfig/network-scripts/ifcfg-eth0
     网卡配置文件基本信息
DEVICE=eth0
ONBOOT=yes
BOOTPROTO=static
IPADDR=10.10.10.11
NETMASK=255.255.255.0
(GATEWAY=)

ip获取方式：1.静态获取：static 服务器设置
            2.动态获取：dhcp

3.网关和路由
	查看： router –n
	设置：router  add  default  gw  ip
	路由设置：router  add  -net  目标网段  gw  ip
	
   永久生效：vim /etc/resolv.conf
             echo  “route add –net 30.30.30.0/24 gw 10.10.10.2 ” >> /etc/rc.local
		
4.DNS
	修改： /etc/sysconfig/network-scripts/ifcfg-eth0
		添加：DNS1    DNS2
	查看：cat    /etc/resolv.conf 
	主机映射文件：/etc/hosts   
net stat   -anpt：查看本机工作端口信息

网络转发实验
（1）开启三个虚拟机10.10.10.11  10.10.10.12   10.10.10.13
（2） 10.10.10.12
vim /etc/sysctl.conf
              net.ipv4.ip.forward=0改为1（开启路由转发）
              sysctl  -p  内核刷新
arpspoof   -i  eth0  -t  源地址  目标地址
*arpspoof需要安装 4个包
（3）10.10.10.11
    route  add  default  gw   10.10.10.13
10.10.10.13开启apache服务
    curl  10.10.10.13 查看是否正常访问
（4）10.10.10.11
traceroute  10.10.10.13   查看访问10.10.10.13的路径
（5）arpspoof   -i  eth0  -t  10.10.10.11  10.10.10.13
（6）10.10.10.11
     traceroute    10.10.10.13
    

二、网络服务
1.测试命令
netstat  -anpt  查看本机工作端口信息
curl  查看网页源代码     curl  localhost
yum  -y install  elinks     字符界面下访问网页界面
elinks  http：//IP地址

ping ：测试网络的连通性
	-c  次数
	-I    频率

2.traceroute ：数据包路径追踪（TTL网络生存时间）
	tracert	windows 平台
高位端口：1024-65535

3.arp：地址解析协议，将 IP 地址转化为 MAC 地址
	arp  -s   目标 IP 地址   目标 MAC 地址     

4.nmap ：网络探测扫描命令
       yum   -y  install  nmap
     nmap   IP地址
     nmap    10.10.10.0/24  查看网络中的所有主机

二、远程管理
1、远程桌面连接
	a、VNC Windows 或 Linux 客户端，连接 Linux 桌面的工具
		yum  -y  install  vnc-server
		初始化设置密码：
			vncserver
		编辑修改 vnc 启动图形界面配置
			vi /root/.vnc/xstartup
				gnome-session &(注释最后两行，添加)
		编辑修改主配置文件
			vi /etc/sysconfig/vncservers
				VNCSERVERS="1:root 2:root"
				VNCSERVERARGS[2]="-geometry 800x600 -nolisten tcp -localhost"
		重启服务生效
			service  vncserver restart

b、rdesktop：Linux 连接 windows 远程桌面
		rdesktop   -u  win用户名   -p   win密码   服务器IP  -a    16、

2、远程管理
登录方式认证
	密码验证：核对用户名、密码是匹配
	密钥对验证：核对客户的私钥、服务器公钥是否匹配
	
	SSH 协议（密码认证）
	为客户机提供安全的 shell 环境，用于远程管理
	默认端口：TCP 22

	Openssh
	服务名称：sshd
	服务主程序：/usr/sbin/sshd
	客户端主程序：/usr/bin/ssh
	服务端配置文件：/etc/ssh/sshd_config
	客户端配置文件：/etc/shh/ssh_config

3、功能模块
	
	ssh命令      ——      远程安全登录
	格式： ssh     user@host
	查看指纹 ：ssh-keygen  -l -f /etc/ssh/ssh_host_rsa_key
		-p   指定端口

	scp命令      ——      远程安全复制
	格式（下载）：scp     user@host:file1     file2
	格式（上传）：scp     file1     user@host:fille2
		-P（大）  指定端口

	sftp命令      ---      远程安全的ftp服务器
	sftp     user@host
	-oport=端口
	第一步：创建密钥对  （SSH客户端）  ssh-keygen  -t  rsa
      私钥文件：id_rsa
    第二步：上传公钥文件 id_rsa.pubrsa.pub

第三步：导入公钥文件（ssh服务器端）
公钥文件：~/.ssh/authorized_keys

第四步：使用密钥对验证方式


8.21
一．网络配置
1.修改主机名
a.临时生效
	查看主机名：hostname
	设置主机名:hostname   主机名
		注：主机名尽量使用FQDN名称（可以重名，不同于windows的UNC路径的wins服务）

b.永久生效
	修改 /etc/sysconfig/network 文件
	设置主机名
		方法：HOSTNAME=主机名

centos7
	hostnamectl set-hostname xx

2.IP配置
	查看：ifconfig
a．临时设置：ifconfig  网络接口  IP地址  netmask  子网掩码
     eg: ifconfig eth0 192.168.19.63 netmask 255.255.255.0
b．永久配置 ：/etc/sysconfig/network-scripts/ifcfg-eth0
     网卡配置文件基本信息
DEVICE=eth0
ONBOOT=yes
BOOTPROTO=static
IPADDR=10.10.10.11
NETMASK=255.255.255.0
(GATEWAY=)

ip获取方式：静态获取：static 服务器设置
             动态获取：dhcp

3.网关和路由
	查看： route  –n
	设置： route  add  default  gw  ip   (添加的是路由记录)
           route  del  default  gw  ip    删除路由记录
	路由设置：route  add  -net  目标网段  gw  ip
	
	
   永久生效：vim  /etc/resolv.conf
             echo  “route add –net 30.30.30.0/24 gw 10.10.10.2 ” >> /etc/rc.local
		
4.DNS
	修改： /etc/sysconfig/network-scripts/ifcfg-eth0
		添加：DNS1    DNS2
	查看：cat    /etc/resolv.conf 
	主机映射文件：/etc/hosts   
netstat   -anpt：查看本机工作端口信息

网络转发实验
（1）开启三个虚拟机10.10.10.11  10.10.10.12   10.10.10.13
（2） 10.10.10.12
vim /etc/sysctl.conf
              net.ipv4.ip.forward=0改为1（开启路由转发）
              sysctl  -p  内核刷新
arpspoof   -i  eth0  -t  源地址  目标地址
*arpspoof需要安装 4个包
（3）10.10.10.11
    route  add  default  gw   10.10.10.13
10.10.10.13开启apache服务
    curl  10.10.10.13 查看是否正常访问
（4）10.10.10.11
traceroute  10.10.10.13   查看访问10.10.10.13的路径
（5）arpspoof   -i  eth0  -t  10.10.10.11  10.10.10.13
（6）10.10.10.11
     traceroute    10.10.10.13
    

二、网络服务
1.测试命令
netstat  -anpt  查看本机工作端口信息
curl  查看网页源代码     curl  localhost
yum  -y install  elinks     字符界面下访问网页界面
elinks  http：//IP地址

ping ：测试网络的连通性
	-c  次数
	-I    频率

2.traceroute ：数据包路径追踪（TTL网络生存时间）
	tracert	windows 平台
高位端口：1024-65535

3.arp：地址解析协议，将 IP 地址转化为 MAC 地址
	arp  -s   目标 IP 地址   目标 MAC 地址     

4.nmap ：网络探测扫描命令
       yum   -y  install  nmap
     nmap   IP地址
     nmap    10.10.10.0/24  查看网络中的所有主机

二、远程管理
1、远程桌面连接
	a、VNC Windows 或 Linux 客户端，连接 Linux 桌面的工具
		yum  -y  install  vnc-server
		初始化设置密码：
			vncserver
		编辑修改 vnc 启动图形界面配置
			vi /root/.vnc/xstartup
				gnome-session &(注释最后两行，添加)
		编辑修改主配置文件
			vi /etc/sysconfig/vncservers
				VNCSERVERS="1:root 2:root"
				VNCSERVERARGS[2]="-geometry 800x600 -nolisten tcp -localhost"
		重启服务生效
			service  vncserver restart
连接     192.168.19.67:5901

b、rdesktop：Linux 连接 windows 远程桌面
		rdesktop   -u  win用户名   -p   win密码   服务器IP  -a    16、

2、远程管理
登录方式认证
	密码验证：核对用户名、密码是匹配
	密钥对验证：核对客户的私钥、服务器公钥是否匹配
	
	SSH 协议（密码认证）
	为客户机提供安全的 shell 环境，用于远程管理
	默认端口：TCP 22

	Openssh
	服务名称：sshd
	服务主程序：/usr/sbin/sshd
	客户端主程序：/usr/bin/ssh
	服务端配置文件：/etc/ssh/sshd_config
	客户端配置文件：/etc/shh/ssh_config

3、功能模块
	
	ssh命令      ——      远程安全登录
	格式： ssh     user@host
	查看指纹 ：ssh-keygen  -l -f /etc/ssh/ssh_host_rsa_key
		-p   指定端口

	scp命令      ——      远程安全复制
	格式（下载）：scp     user@host:file1     file2
	格式（上传）：scp     file1     user@host:fille2
		-P（大）  指定端口

	sftp命令      ---      远程安全的ftp服务器
	sftp     user@host
	-oport=端口
	第一步：创建密钥对  （SSH客户端）  ssh-keygen  -t  rsa
      私钥文件：id_rsa
    第二步：上传公钥文件 id_rsa.pubrsa.pub

第三步：导入公钥文件（ssh服务器端）
公钥文件：~/.ssh/authorized_keys

第四步：使用密钥对验证方式

8.22 
TCP   wrappers
1.数据包安全控制：Iptables   -   tcp wrappers   -   selinux   -   acl
iptables ： 通过拒绝或放行数据包的通入达到安全检测的目的

2.Tcp wrappers：相对简单的安全防护机制，对基于 TCP 协议的某些应用程序进行访问控制（工作在kernel空间与user空间之间）
tcpwrappers： 
	              tcp 协议开发的应用程序
	              需要调用 libwrap.so 库文件
			
3.查看哪些可以被 Tcp wrappers 管理
    ldd  /usr/sbin/sshd   |   grep  libwrap  


4.访问控制设置配置文件
/etc/hosts.allow	   /etc/hosts.deny
语法格式：
(1) 单个或多个IP
	服务列表:客户端地址列表
eg:    sshd:192.168.19.64
(2) 网段
	服务列表:客户端网段/子网掩码（不能使用/24格式）
eg:    sshd:192.168.19.0/255.255.255.0
(3)域名
	*.xdl.cn = .xdl.cn     	*.baidu.com      

(4)分隔符
	服务列表@服务器IP地址:客户端地址
eg:   sshd@192.168.19.67:192.168.19.64

(5)ALL(所有)     LOCAL(本机)   KNOWN(本地能解析的域名)   	UNKNOWN(本地不能解析的域名)   
	EXCEPT(排除)     
eg:   sshd:ALL   EXCEPT  192.168.1.1
注：TCP Wrappers 支持使用通配符 * ？ ，但是不能同 . 开始和结束混用      
eg:   .*.com	192.168.*.

5.生效过程
      (1) /etc/hosts.allow里有对应信息则该配置文件里的主机允许访问

      (2) /etc/hosts.deny里有对应信息则该配置文件里的主机都无法访问

      (3)TCP Wrappers是优先查找/etc/hosts.allow，再查找/etc/hosts.deny

      (4)如果两个文件信息有冲突，同一个主机出现在两个文件中，则/etc/allow的生效

      (5)如果一个主机都没有出现在2个文件中，则默认允许访问










DHCP
1.DHCP作用
为大量客户机自动分配 IP 地址，提供集中管理                                               
服务器减轻管理和维护成本，提高网络配置效率 

2.可分配的地址信息的主要内容 
*网卡的 IP 地址、子网掩码 
*对应的网络地址、广播地址 
*默认网关地址 
*DNS服务器地址                                          
*引导文件  tftp 服务器地

3. DHCP工作流程：
（1）计算机上线
		static 配置网卡  向当前广播域发送广播包
		dhcp
			向当前广播域发送 DHCP discover 报文
					0.0.0.0  255.255.255.255
					
				没有 DHCP 服务器，网络不可用
（2）有 DHCP 服务器，并且有多台，谁先相应采取谁的，服务器发送 Offer报文  IP地址 子网掩码
（3）客户端向广播域中发送 requst 报
		通过 arp 协议测试此IP是否可用
（4）如果可用 dhcp server 向客户端 发送 ACK报文
		IP 地址  子网掩码  广播地址 DNS  网关  租约信息。。。
	
	计算机下线，再上线
		发送 requst 报文，查询之前使用的IP地址还是否可用
		
	租约信息：

4. DHCP-相关文件 
(1)RHEL6 的 DHCP 软件包 
dhcp.4.1.1-51.P1.e16.centos.x86_64.rpm 
(2)DHCP 的相关配置： 
端口号：   IPV4 UDP67（接收请求      UDP68（发送回应 
           IPV6 UDP546               UDP547 
服务名:    dhcpd 
主配置文件     /etc/dhcp/dhcpd.conf 

                   
模板文件     /usr/share/doc/dhcp-4.1.1/dhcpd.conf.sample  

中继配置文件：   /etc/sysconfig/dhcrelay

5. DHCP服务器配置
*仅主机模式
一．基本DNS服务器：
1、	搭建本地yum源，安装DHCP服务包
yum     -y    install    dhcp
2、	覆盖/etc/dhcp/dhcpd.conf ——       源文件为空    
 cp -a /usr/share/doc/dhcp-4.1.1/dhcpd.conf.sample /etc/dhcp/dhcpd.conf  
3.     vi    /etc/dhcp/dhcpd.conf  —— 进入覆盖以后文件，设置作用域

            
# A slightly different configuration for an internal subnet.    
                
 subnet 192.168.19.0 netmask 255.255.255.0{
 range 192.168.19.100 192.168.19.20;                                               
option routers 192.168.19.1;             网关                                                     
 }
4.service  dhcpd restart
   chkconfig  dhcpd  on
               
二、	设置保留IP：如打印机等需要固定IP设备 
vim  /etc/dhcp/dhcpd.conf                     

host fantasia {
  hardware ethernet 00:0c:29:36:6c:f4;          mac地址
  fixed-address 192.168.19.201;                保留IP
}

查看MAC地址
arp  -a
arp  IP

三、	超级作用域：分配不同网段
 仍然在/etc/dhcp/dhcpd.conf                    
 在配置超级作用域之前，需要把之前的配置文件删除或注释

shared-network 224-29 {
  subnet 192.168.19.0 netmask 255.255.255.0 {
  range 192.168.19.100 192.168.19.100;
  option routers 192.168.19.1;
  }
  subnet 192.168.20.0 netmask 255.255.255.0 {
    range 192.168.20.100 192.168.20.200;
    option routers 192.168.20.1;
  }
}
                          
service  dhcpd restart
chkconfig  dhcpd  on                                     

四、	DHCP跨网段分配IP地址
 
1.	准备四台虚拟机
192.168.19.63
192.168.19.64
192.168.19.65（192.168.20.65）
192.168.20.66
都设为仅主机模式
第一台和第二台在同一网段，设置为vmnet1
第三台开启两块网卡，设置为vmnet1和vmnet2，
如果复制网卡，记得要改设备名为eth1，DEVICE=eth1
第四台为vmnet2
2.a．第一台虚拟机安装dhcp服务   yum  -y  install  dhcp
  b．网关指向中继   route    -n（查看路由表）
     route     add    default    gw    192.168.19.65
     echo “GATEWAY=192.168.19.65” >> /etc/sysconfig/network-scripts/ifcfg-eth0（添加网关路由第三台）                     
3、第一台配置dhcp服务
                     
a．	开启服务，设置地址池 ，两个地址池为两个不同网段
4.第三台
如果复制网卡，记得要改设备名为eth1，DEVICE=eth1
a．中继：开启路由转发功能            vi    /etc/sysctl.conf     改为1
重新加载文件生效            sysctl    -p
b．安装dhcp服务    yum  -y  install  dhcp
                     service  dhcpd  start
                     chkconfig  dhcpd  on

 
c．  vi  /ets/sysconfig/dhcrelay        
第二列：采用的网卡  INTERFACES=“eth0 eth1”       
第三列：DHCP服务器的网段 DHCPSERVERS=”192.168.19.63”  第一台
d．开启服务，以及开机自启动           
 service    dhcrelay    start        
chkconfig    dhcrelay    on
4.第二台和第四台自动获取IP
   vim   /etc/sysconfig/network-scripts/ifcfg-eth0
   BOOTPROTO=dhcp



































8.23 DNS服务器
一、基础知识
1.DNS系统的作用
正向解析:根据主机名称（域名）查找对应的IP
反向解析：根据IP查找对应的主机名称（IP）
2.	相关机构
IANA域名设计维护以及地址资源分配
ICANN互联网名称数字地址分配机构
3.	DNS的发展
/etc/hosts  

域名服务器
          减少客户端操作复杂度，增加服务器端操作难度
搭建分布式存储
          缺点：更新时间过长，管理相对麻烦
          解决方式：服务器只管理与其直连的下级
                   优点：命名简单
4 


5.DNS工作流程
 
6.根服务器（ 13个 ）

 

二、DNS服务相关软件包和配置文件
1. BIND
（Berkeley   Internet  Name  Daemon）    -      伯克利 Internet 域名服务
官方站点：https://www.isc.org
软件包：bind-9.8.2-0.47.rc1.el6.x86_64.rpm
服务名：named
端口号：53
主配置文件：/etc/named.conf
保存 DNS 解析记录的数据文件位置： /var/named/
2.DNS配置文件说明
0    ; serial	  主从同步使用
        1D   ; refresh 刷新时间
        1H   ; retry	  间隔时间，主从同失败后多上时间重试
        1W   ; expire	  和主服务器失去联系后可以使用多长时间
        3H ) ; minimum  缓存老化时间
三、实验流程
1.基本服务
yum –y install bind
a．修改 /etc/named.conf
			listen-on port 53 { any; };
			allow-query     { any; };
			
b．修改设区域申明配置文件
         cp  -a /etc/named.rfc1912.zones  /etc/named.rfc1912.zones.back         >>                 备份
vim   named.rfc1912.zones
#########	
zone "xdl.com" IN {                          正向
				type master;
				file "xdl.zheng";
				allow-update { none; };
			};
			zone "19.168.192.in-addr.arpa" IN {          反向
				type master;
				file "xdl.fan";
				allow-update { none; };
			};
#########
c.修改数据配置文件
cp  -a  /var/named/localhost    /var/named/xdl.zheng  正向
cp  -a  /var/named/loopback    /var/named/xdl.fan     反向

vim    xdl.zheng
#########                               （##注意“.”一定要写）
					$TTL 1D
			@       IN SOA  xdl.com. rname.invalid. (
													0       ; serial
													1D      ; refresh
													1H      ; retry
													1W      ; expire
													3H )    ; minimum
					 NS      dns.xdl.com.
			dns     A       192.168.19.63
			www	  A		   192.168.19.64
##########
vim  xdl.fan
			$TTL 1D
			@       IN SOA  xdl.com. rname.invalid. (
													0       ; serial
													1D      ; refresh
													1H      ; retry
													1W      ; expire
													3H )    ; minimum
					NS      dns.xdl.com.
			63     PTR     dns.xdl.com.
			64		PTR		www.xdl.com.
########
                                        “.”一定要写
d．service   named  restart  
   chkconfig  named on
  e.测试
     nslookup

2.主从 DNS 配置
A．首先搭建基本DNS服务（在主机192.168.19.63上搭建）
B.设置 主DNS 允许同步
         vim   /etc/named.conf
               添加一行
			allow-transfer  { 192.168.19.64; };  
		
C.设置 从DNS 同步设置（在第二台主机192.168.19.64上搭建）

a．yum –y install bind
修改 /etc/named.conf
			listen-on port 53 { any; };
			allow-query     { any; };
			
b．修改设区域申明配置文件
         cp  -a /etc/named.rfc1912.zones  /etc/named.rfc1912.zones.back         >>                 备份
vim   named.rfc1912.zones

			zone "xdl.com." IN {
				type slave;
				file "slaves/xdl.zheng";
				allow-update { none; };
				masters { 192.168.19.63;};
			};
       d．vim  /etc/sysconfig/network-scripts/ifcfg-eth0
            添加”DNS1=192.168.19.64”
           service   named  restart
           chkconfig  named   on 
           service   network   restart   重启网络
           nslookup                         检测
       

3.缓存DNS 服务器的设置
A．主DNS搭建（在主机192.168.19.63上搭建）
yum –y install bind
a．修改 /etc/named.conf
			listen-on port 53 { any; };
			allow-query     { any; };
			
b．修改设区域申明配置文件
         cp  -a /etc/named.rfc1912.zones  /etc/named.rfc1912.zones.back         >>                 备份
vim   named.rfc1912.zones
#########	
zone "xdl.com" IN {                          正向
				type master;
				file "xdl.zheng";
				allow-update { none; };
			};

c.修改数据配置文件
cp  -a  /var/named/localhost    /var/named/xdl.zheng  正向

vim    xdl.zheng
#########                               （##注意“.”一定要写）
					$TTL 1D
			@       IN SOA  xdl.com. rname.invalid. (
													0       ; serial
													1D      ; refresh
													1H      ; retry
													1W      ; expire
													3H )    ; minimum
					 NS      dns.xdl.com.
			dns     A       192.168.19.63
			www	  A		   192.168.19.64
B．缓存服务器搭建（在第二台主机192.168.19.64上搭建）
        yum  -y   install  dnsmasq		
修改 dnsmasq 配置文件     vim   /etc/dnsmasq.conf
			domain=all    设置当前的域     
			server=192.168.19.63 从什么dns 服务器上缓存
			cache-size   缓存大小     默认150
C．	测试 
  vim  /etc/sysconfig/network-scripts/ifcfg-eth0
     添加”DNS1=192.168.19.64”
dig www.xdl.com   进行压力测试（第三台192.168.19.65）

8.24	
分离解析
 
	
1.准备三台虚拟机
   18.18.18.63
   18.18.18.64
   18.18.18.65
2.主服务器配置两块网卡（18.18.18.64）
  a．cp ifcfg-eth0 ifcfg-eth1
  b．vim ifcfg-eth1
       DEVICE=eth1
       ONBOOT=yes
       BOOTPROTO=static
       IPADDR=28.28.28.64
       NETMASK=255.255.255.0
     service network restart
     shutdown –h now
c．添加网卡
3.修改第三台虚拟机网卡（18.18.18.65）vmnet2
ip改为   28.28.28.65
4.	主服务器定制 view 区域
 yum –y install bind
a．修改 /etc/named.conf
	listen-on port 53 { any; };
			allow-query     { any; };



		view    nei {
		match-clients { 18.18.18.0/24; };
		zone "." IN {
				type hint;
				file "named.ca";
		};
		include "/etc/named.nei";
		};
                                  分号一定要加

		view    wai {
		match-clients { any; };
		zone "." IN {
				type hint;
				file "named.ca";
		};
		include "/etc/named.wai";
		};
b．修改设区域申明配置
cp -a /etc/named.rfc1912.zones  /etc/named.nei
cp -a /etc/named.rfc1912.zones  /etc/named.wai

vim   named.nei
#########	
zone "xdl.com" IN {                          正向
		type master;
		file "xdl.nei.zheng";
		allow-update { none; };
			};


zone "18.18.18.in-addr.arpa" IN {          反向
				type master;
				file "xdl.nei.fan";
				allow-update { none; };
			};

vim named.wai

#########	
zone "xdl.com" IN {                          正向
		type master;
		file "xdl.wai.zheng";
		allow-update { none; };
			};
zone "28.28.28.in-addr.arpa" IN {          反向
		type master;
		file "xdl.wai.fan";
		allow-update { none; };
           };

c. 修改数据配置文件
cp  -a  /var/named/localhost  /var/named/xdl.nei.zheng  
cp  -a  /var/named/localhost  /var/named/xdl.wai.zheng  
正向
cp  -a  /var/named/loopback    /var/named/xdl.nei.fan 
cp  -a  /var/named/loopback    /var/named/xdl.wai.fan
反向

vim    xdl.nei.zheng
vim    xdl.wai.zheng
vim    xdl.nei.fan
vim    xdl.wai.fan
d.重启服务
service named restart
  chkconfig named on
5.测试
18.18.18.63  配上DNS1=18.18.18.64
   28.28.28.65  配上 DNS1=28.28.28.64
   
   
文件共享服务器FTP
一、本章结构
 
二、简介
File Transfer Protocol （文件传输协议）的英文简称，而中文简称为“文件传输协议”。用于 Internet 上的控制文件的双向传输。
同时，它也是一个应用程序（Applicaction）。基于不同的操作系统有不同的 FTP 应用程序，而所有这些应用程序都遵循同一种协议
以传输文件。在 FTP 的使用中，用户经常遇到两个概念：“下载”和“上传”。
	下载：从远程主机拷贝文件到自己的计算机之中
	上传：将文件从自己的计算机拷贝到远程计算机之中
支持 FTP 协议的服务器都叫做 FTP 服务器
三、服务端和客户端程序
FTP 用户的类型：
	匿名用户：anonymous 或 ftp
	本地用户：账号名称、密码等信息都保存在 password 和 shadow 文件中
常见的 FTP 服务器程序：
	IIS、Serv-U
	wu-ftpd、Proftpd
	vsftpd（Very Secure FTP Daemon）
常见 FTP 客户端或程序：
	CuteFTP、FlashFTP、LeapFTP、Filezilla
	gftp、kuftp、ftp
四、工作原理
主动模式
 
被动模式
 
五、主动被动模式比较
主动模式：
       端口：      21（命令端口）       20（数据端口）
       网络连通性：  服务器端通过 20 端口连接客户端的随机端口，对于客户端来说可能存在防火墙阻止端口的现象，而对于服务器来说只开
	   放两个固定端口更安全

被动模式：
       端口：      21（命令端口）	    随机端口（数据端口）
       网络连通性：    数据的传输由客户端主动连接，客户端不存在防火墙阻隔数据包问题。但是，服务器端开启了随机端口，不利于服务器
	   的安全管理
六、配置文件
主配置文件：/etc/vsftpd/vsftpd.conf
匿名用户的家目录：/var/ftp
                  匿名用户上传文件的位置   /var/ftp/pub/xxx
本地用户的家目录: /home/xxx
虚拟 用户的家目录：/var/ftproot
/etc/vsftpd/user_list   默认出现在此文件中的用户不能登录
/etc/vsftpd/ftpusers    默认出现在此文件中的用户不能登录,密码也不可以输


七、/etc/vsftpd/vsftpd.conf配置选项

安全选项
connect_timeout=60
accept_timeout=60
data_connection_timeout=300
idle_session_timeout=300
ftpd_banner=xxx 和 banner_file=/path/file
tcp_wrappers=YES

常见的全局配置
listen_address=192.168.1.2    设置监听的 IP 地址
listen_port=21    设置监听 FTP 服务的端口号
write_enable=YES    是否启用写入权限
download_enable=YES    是否允许下载文件
max_clients=0    限制并发客户端连接数
max_per_ip=0    限制同一 IP 的并发连接数

配置选项-匿名用户

配置选项-匿名用户

八、相关知识点
1.vsftpd限制用户的方式
       本地文件系统的限制
       程序的限制（配置文件的限制）
2./var/ftp 和/var/ftp/pub  默认是没有读（w）权限的，匿名用户在这两个目录下没有上传文件的权限（避免用户上传恶意文件）
修改为777，会报错。
3.客户端查看帮助命令：  ？
上传：put     看的是所有者权限
下载：get     看的是文件的其他人权限
4.匿名用户登录后，是否可以进入pub下目录看的是所有者权限，


九．匿名用户操作
匿名权限控制
anonymous_enable=YES    启用匿名访问
anon_umask=022    匿名用户所上传文件的权限掩码
anon_root=/var/ftp    匿名用户 FTP 的根目录
anon_upload_enable=YES    允许上传文件
anon_mkdir_write_enable=YES    允许创建目录
anon_other_write_enable=YES    允许其它写入权（可改名）
anon_max_rate=0    限制最大传输速率（字节/秒）
1.匿名用户可以下载文件的操作
   a. 开启download_enable=YES（默认开启）
   b．文件的其他人权限为读权限（w）
2.匿名用户可以上传文件的操作
   a．在/var/ftp/pub下创建目录作为匿名用户上传文件的位置
      mkdir   /var/ftp/pub/www
      chown   ftp:ftp   /var/ftp/pub/www
   b.修改配置文件
      开启anon_upload_enable=YES选项
3.用户上传上传文件后文件权限变为600，这样的话用户就不可以下载自己上传的文件了，这样是很不合理的，但是我们可以通过修改用户上传权
限的掩码，来使用户可以下载自己上传的文件
在local_umask=022下添加一行
   anon_umask=022
4.匿名用户可以创建目录
   a．在/var/ftp/pub下创建目录作为匿名用户上传文件的位置
      mkdir   /var/ftp/pub/www
      chown   ftp:ftp   /var/ftp/pub/www
   b．anon_mkdir_write_enable=YES            开启
5.匿名用户可以对www下的文件改（rename改名、delete删除）
a．在/var/ftp/pub下创建目录作为匿名用户上传文件的位置
      mkdir   /var/ftp/pub/www
      chown   ftp:ftp   /var/ftp/pub/www
    b．开启anon_other_write_enable=YES  
anonymous_enable=YES
anon_other_write_enable=YES  
十、本地用户操作本地用户权限控制
local_enable=YES    启用本地用户访问
local_umask=022    本地用户所上传文件的权限掩码
local_root=/var/ftp    设置本地用户的 FTP 根目录
chroot_local_user=YES	   是否将用户禁锢在主目录
local_max_rate=0    限制最大传输速率（字节/秒）
userlist_deny=NO    只允许出现在 user_list 文件中的用户登录
    
1.上传下载文件
本地用户的默认登录位置是自己的家目录，所以默认具有上传下载文件的权限
2.本地用户默认可以随意切换目录，这样做不是很安全，我们可以通过将本地用户禁锢在家目录进行操作
      chroot_local_user=YES	   是否将用户禁锢在主目录
虚拟用户：公司设置一个文件共享服务器，员工在此可以下载共享文件，如果公司员工较多的话，为每个用户创建账户密码的话，就比较麻烦，
这时就可以创建虚拟用户，避免麻烦。
实验一：虚拟用户
	1、创建账号信息文件
		vi /etc/vsftpd/user.list  
	2、将创建的账户信息文件修改为系统识别的数据库类型文件
		cd    /etc/vsftpd
		db_load -T -t hash -f /etc/vsftpd/user.list user.db
		chmod 600 user.* 
	3、添加虚拟映射用户
		useradd -d /var/ftproot -s /sbin/nologin virtual
		chmod 755 /var/ftproot/
       chown virtual:virtual /var/ftproot

       vim /etc/vsftpd/vsftpd.conf

# Allow anonymous FTP? (Beware - allowed by default if you comment this out).
anonymous_enable=YES   改为NO   不许匿名用户登录FTP
	4、设置认证
		cd /etc/pam.d
       cp vsftpd vsftpd.a          拷贝模板文件，进行修改
        vi vsftpd.a    
           #%PAM-1.0   (只留两行)                
  auth      required     pam_userdb.so   db=/etc/vsftpd/user
  account  required     pam_userdb.so   db=/etc/vsftpd/user
	5、在主配置文件中声明
		vi /etc/vsftpd/vsftpd.conf           
            pam_service_name=vsftpd.a     注意  .a          
            userlist_enable=YES                          
            tcp_wrappers=YES
			 guest_enable=YES
            guest_username=virtual
            user_config_dir=/etc/vsftpd/conf
	6、创建用户控制权限
        cd /etc/vsftpd/
        mkdir    conf
        cd    conf
        touch  user1  user2  user3
                                
		常见权限：						
          anon_upload_enable=YES           允许上传
		  anon_mkdir_write_enable=YES    允许用户创建目录
		  anon_other_write_enable=YES     允许其它写入权限
          anon_world_readable_only=NO  允许下载
		  
		  ftp 192.168.19.63  测试
实验二：被动模式（）
1.准备两台虚拟机v1：18.18.18.63     v2：18.18.18.64
2.在v1上安装vsftpd服务
a. yum –y install vsftpd

b.修改配置文件
   vim /etc/vsftpd/vsftpd.conf
   在最底部添加三行
pasv_enable=YES                        被动模式开启
pasv_min_port=10221                   被动模式最小连接端口
pasv_max_port=10231                   被动模式最大连接端口
c．创建新用户
useradd   zhangsan
cd  /home/zhangsan
在zhangsan的家目录下创建一个大文件
dd if=/dev/zero bs=1024 count=10000 of=test
d．service vsftpd restart
   chkconfig  vsftpd on
3.在v2上安装ftp服务
a．	yum –y install ftp
b．   登录v1主机ftp服务器
ftp  18.18.18.63

c．   下载文件test  
get  test
4.在v1上监听连接本机的端口
  netstat  –anpt
  如果监听到10000到10010的端口就算成功
实验三：
 vsftpd  +  ssl
1.在第一台主机（18.18.18.63）上安装vsftpd服务  
yum  -y  install  vsftpd
安装抓包程序
   yum  -y  install tcpdump
   开启抓包
   tcpdump port 21 –nA
2.在v2主机上登录
   ftp   18.18.18.63
3.切换到v1
   可以发现抓到很多数据包，包含刚刚v2的登录密码
4.在v1上安装加密认证
  a． yum –y  install  openssl  openssl-devel
  b． 创建加密证书
openssl    req    -new    -x509    -nodes    -out    vsftpd.pem    -keyout    vsftpd.pem
填写相关信息：
国家
                        州或省份
                        市
                        组织
                        单位
                            一般名称
                        邮件地址

  c．将证书拷贝到/etc/ssl/certs/
     mv   vsftpd.pem   /etc/ssl/certs/
  d.设置权限，防止其他人看到
     chmod   400  vsftpd.pem
5. vi    /etc/vsftpd/vsftpd.conf
在命令行尾添加授权信息
ssl_enable=YES                   启用ssl加密功能	                           
allow_anon_ssl=YES               允许匿名用户加密		              
force_local_data_ssl=YES        强制本地数据使用ssl机密                  
force_local_logins_ssl=YES  强制本地用户登录信息使用ssl加密                     
force_anon_data_ssl=YES          强制匿名本地数据使用ssl加密                
force_anon_logins_ssl=YES   强制匿名用户登录信息使用ssl加密                       
ssl_tlsv1=YES                                              
ssl_sslv2=NO                    ssl协议版本的选择2  
ssl_sslv3=NO     
rsa_cert_file=/etc/ssl/certs/vsftpd.pem
6.重启服务
  service vsftpd  restart
7.
   开启抓包
   tcpdump port 21 –nA
8.在v2上重新登录（默认不支持加密登录）
   在winscp上登录
 
9.在v1上查看
   抓到的包中查不到
zhangsan的登录密码




































































8.25                lamp环境搭建
apache  和  nginx  只能解析静态文件（IIS）
         动态文件需要用php程序解析
PHP分为两大版本：5x    可以连接数据库函数
                           7x    数据库连接函数和5x不同，性能更好   
php     web编程
java    全平台兼容，使用tomcat解析

数据库：
       关系型数据库：（数据存储在磁盘中，数据间有相互关联）
       sqlsever   oracle   MYSQL
                              mariadb   7版本
       非关系型数据库：（数据存储在内存中，数据间没有关联，便于查找）
       radis
select模型    apache使用
epoll模型     nginx使用
一、	lamp结构
linux  +  apache  + mysql  php
   1.apache
   2.MySQL
   3.PHP
二、	软件架构
1.单层架构
2.双层架构
3.多层架构

三、lamp环境搭建流程（见文档）











































8.28
SAMBA
一、	本章结构
 

二、smb  和 CIFS协议
samba：支持在线修改                            smb/CIFS  协议

vsftpd：不支持在线修改                         ftp协议

SMB协议
Server    Message   Block，服务信息块     SUN

CIFS协议
Common   Internet   File   System，通用互联网文件系统



诞生：
Andrew Tridgwell        dos     sun-unix        dec-Digital Unix 
		          微软         Unix           Unix/PATHWORKS       >   ServerMessage Block (SMB)   >    SAMBA

二、	使用方式

使用方式：
netbios	windows 访问 Linux samba ： \\UNC路径 
                                        映射本地磁盘驱动器
	Linux 访问 windows：  mount –t cifs      smbclient

netbios：主机和IP地址的映射
作用：
	分享档案与打印机服务
	可以提供用户登入 SAMBA 主机是进行身份验证
	可以进行 Windows 网络上的主机名解析（NetBIOS name）
三、	samba相关程序
A．samba服务器的主要程序
smb：提供对服务器中文件、打印资源的共享访问	139  445   TCP
nmb：提供基于NetBIOS主机名称的解析	137  138          UDP

B．samba的服务脚本
/etc/init.d/smb

C.samba的配置目录及文件
/etc/samba
/etc/samba/smb.conf		
D．配置文件检查工具：testparm
四．常见配置

常见配置项的含义：
workgroup：所在工作组
server string：服务器描述信息
Security：安全级别，可用值如下
	share	user	server	  domain
log file：日志文件位置，“%m”变量表示客户机地址
	%v：版本号  %m：客户端主机名  %N：客户端域名
	%s：客户端用户名  $i：客户端IP  %t：客户端的访问时间
max log file：日志文件的最大容量，单位为KB
passwd backend：设置共享账户文件的类型


常见共享目录配置项含义
comment：对共享目录的注释、说明信息
path：共享目录在服务器中对应的实际路径
browseable：该共享目录在“网上邻居”中是否可见
guest ok：是否允许所有人访问，等效于“public”
writable：是否可写，与 read only 的作用相反
valid users :  设置哪些用户可以访问
printable :  是否加载打印功能

实验一、匿名用户共享
yum  -y install samba
vim  /etc/samba/smb.conf
mkdir  /share
chmod  777 /share
1、修改安全等级为匿名   share
2、在文件尾部添加共享内容
[pub]
       comment = this is a sever
       path = /share
       public = yes
       writable = yes
3、Linux中查看共享 samba 服务器
smbclient    -L    服务器IP
smbclient    -L    18.18.18.63
4、下载文件进行测试
smbclient   //服务器IP/共享名称
smbclient   //18.18.18.63/pub
5、windows端查看共享
\\服务器IP
\\18.18.18.63

   可以上传文件要对共享目录/share有写权限



实验二、本地用户共享设置
    yum  -y install samba
vim  /etc/samba/smb.conf
1、修改安全等级为匿名   user
2、在文件尾部添加共享内容
[pub]
  comment = this  is  a  server
  path = /share
  public = yes
  writable = yes
3、添加用户（已存在的用户）
处理命令  pdbedit   -a   系统存在用户 
          pdbedit   -a   lisi 
查看已处理用户命令    pdbedit     -L
删除已处理用户命令    pdbedit    -x

4、在linux中的访问设置
smbclient -U samba用户 -L //服务器IP
smbclient –U  lisi –L  //192.168.19.63
5、下载
smbclient -U samba用户  //服务
smbclient –U lisi   //18.18.18.63/pub
实验三、 
yum  -y install samba
vim  /etc/samba/smb.conf
1、修改安全等级为匿名   user
2.目录权限最大，服务严格控制
A.[pub]
  comment = test
  path = /share
  public = yes
  read only = yes
  write list = zhangsan     其他用户可进来，无法进行写操作
B. [pub]
  comment = this a server
  path = /share
  public = yes
  read only = yes
  valid users = lisi，zhangsan        其他用户登录不了
[pub1]
  comment = this a server
  path = /share1
  public = yes
  read only = yes
  valid users = wangwu   
C.创建两个用户，两个用户只能查看对方的共享目录，而不能上传文件
        [pub]
        comment = this is a ser
        path = /share
        public = yes
        read only = yes
        write list = zhangsan

        [pub1]
        comment = this is a ser
        path = /share1
        public = yes
        read only = yes
        write list = lisi
     3.在linux中的访问
smbclient –U  lisi       //18.18.18.63/pub
smbclient –U  zhangsan //18.18.18.63/pub
smbclient –U  lisi       //18.18.18.63/pub1


  create mask = 0775         samba共享目录中默认不显示文件的所属组和其他人的x权限
  directory mask = 0775
清楚目录缓存： cmd   net use * /del


二服务严格控制，目录权限严格控制
通过限制文件系统的权限设置进行权限的管理

实验四、访问控制
vim /etc/samba/smb.conf
1、修改配置文件：在主配置文件的  global 区域内声明
 hosts allow = 192.168.1.	申明允许网段
 hosts allow = 192.168.1.1	申明允许 IP
 hosts deny = 192.168.1.	申明拒绝网段
 hosts deny = 192.168.1.1	申明拒绝 IP

说明：允许 allow 与拒绝 deny 不能同时出现，只能单独出现。出现 allow 代表只允许出现 IP / 网段访问，其它全部拒绝。出现 deny 代表
只拒绝出现 IP / 网段访问，其它全部允许。




实验五  易用性
1、	修改别名文件： vim /etc/samba/smbusers
                zhangsan = zs
2、启用别名文件：在主配置文件的 global 区域内声明   
username map = /etc/samba/smbusers
3、重启服务
4．smbclient  -U zs //192.168.19.63/pub
    测试
说明：samba（别的服务器） 挂载到 Linux 目录上使用 
mount -t cifs -o username=zs,password=123 //10.10.10.10/public /smb/
、//10.10.10.11 /mnt cifs default,user=zhangsan,password=123
 开机自动挂载
5、安装 samba-swat ，samba 的图形化配置
   samba-swat-tar.gz
Rpm  -qa  |  grep  xinetd 
Service xinetd restart
Chkconfig xinetd on
修改 samba-swat 的配置文件swat
   vim /etc/xinetd.d/swat

浏览器登录查看
   192.168.19.63:901

① 将“only_from=127.0.0.1”改成“only_from=0.0.0.0”，这样该服务器就可以监听所有的来访IP。
② 将“disable=yes”改成“disable=no”，这样swat子进程就可以随xinetd超级守护进程一起启动了。可以吃用chkconfig命令查看swat是否启用
了。
③ swat默认使用tcp的901端口。“port=901”，可以修改。
④ 通过web来配置samba，默认使用root账号进入。“user=root”，可以修改成其他的系统用户。
⑤ swat的执行程序默认在/usr/sbin目录下。
⑥查看端口是否开启   netstat -an | grep 901
实验六、  NFS服务器搭建方式
	1、安装 nfs 软件包
		yum install  nfs-utils-lib  nfs-utils
	2、修改 nfs 配置文件
		vim /etc/exports
			/var/www/html  10.10.10.12(rw) 
	3、重启 nfs 服务
		service nfs restart
	4、客户端挂载
		mount -t nfs 10.10.10.11:/var/www/html  /var/www/tml
实验七、web服务器共享
1.	第一台主机安装httpd
yum –y  install  httpd

2.	service  httpd  start
chkconfig  httpd   on

3.	 第二台主机安装httpd
  yum  -y  install  httpd
2.	service  httpd  start
chkconfig  httpd   on
4.	将光盘挂载到网页目录上
mount  -t  iso9660  /dev/cdrom    /var/www/html
5.	vim  /etc/http/conf/http.conf
删除Option  Idexes  后的内容删掉

6.	cd  /var/www/html  
mkdir   centos6
           7.
mount  -t  iso9660  /dev/cdrom    /var/www/html/centos6
8.浏览器访问
18.18.18.63/centos6










8.29
7、网络服务之Apache
http  +   ssl   =    https    443       http://www.baidu.com.:80
http	80

地址跳转 
curl -o /dev/null -s -w "%{http_code}" 10.10.10.11
    截取服务运行的返回码，判断服务是否正常运行


http 无状态协议     不记录连接状态

cookie机制：把用户访问的密码和所有记录记录在本地
 
cookie把用户访问的密码和所有记录记录在本地，然后发给服务器，让服务器知道用户的访问记录，（不安全） 
session将用户访问记录放在服务器上（较安全）

DSO 动态共享对象


DSO 动态共享对象  
IFmodule   模块配置区域
Directory  目录配置区域

<Directory />
  AllowOverride none		一个开关，开关的是我们的权限文件   none 表示不加载   all 表示加载
 Require all denied	    访问控制，决绝所有客户端访问
</Directory>
连起来表示我的用户不能通过浏览器访问我跟下的所有权限文件
DocumentRoot "/usr/local/apache2/htdocs"  申明网站首页文件存放路径
Options Indexes FollowSymLinks  加载一些特殊选项 
 Require all granted  允许所有客户端访问
 
 10.10.10.231 - - [17/May/2017:18:20:53 +0800] "GET / HTTP/1.1" 304 -
 用户IP    登录位置  登录用户名   下载操作  超文本传输协议1.1版本   操作代码（2.3开头基本都是请求成功的，4开头的基本都是操作
 失败的代码） 
 Nginx 
 Apache    安全
一、相关概念
1、相关概念
协议：超文本传输协议  -  HTTP协议 
核心：超文本标记语言  -  HTML语言
URL：统一资源定位符  -  http://  或  https://
如：http://www.baidu.com.:80/index.html
2、搭建
Linux  +  apache  +  mysql  +  php         LAMP Linux  +  nginx  +  mysql +  php   LNMP
windows  +  IIS  +  SQLserver  +  ASP  
二、基础知识
1、安装方式
  源码包：编译安装
  RPM包：yum  -y  install  httpd
构建 rpm 包的 lamp 架构：http、mysql、mysql-server、php、php-devel、php-mysql
2、Apache 主配置文件
  源码包：/usr/local/apache2/conf/httpd.conf
    /usr/local/apache2/conf/extra/*
  RPM包：/etc/httpd/conf/httpd.conf
3、默认网页保存位置
       源码包：/usr/local/apache2/htdocs
 RPM包安装：/var/www/html 
4、日志保存位置
源码包：/usr/local/apache2/logs
RPM包：/var/log/httpd
5、模块加载
静态加载：通过配置文件制定，开启web服务器过程中会加载相应模块
	if module 申明
	
动态加载：服务器运行中，如果需要，直接从外存中加载进内存中
	LoadModule申明：需要制定模块位置
6、请求码
a、	1xx（临时响应）表示临时响应并需要请求者继续执行操作的状态代码
100（继续）请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余
部分。
101（切换协议）请求者已要求服务器切换协议，服务器已确认并准备切换。
b、	2xx（成功）表示服务器成功处理了请求的状态代码
200（成功）服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页.如果针对您的 
robots.txt 文件显示此状态，则表示 Googlebot 已成功检索到该文件。
201（已创建）请求成功并且服务器创建了新的资源。
202（已接受）服务器已接受请求，但尚未处理。 
203（非授权信息）服务器已成功处理了请求，但返回的信息可能来自另一来源。
204（无内容）服务器成功处理了请求，但没有返回任何内容。
205（重置内容）服务器成功处理了请求，但没有返回任何内容。 与 204 响应不同，此响应要求请求者
重置文档视图（例如，清除表单内容以输入新内容）。
206（部分内容）服务器成功处理了部分 GET 请求。
c、	3xx（重定向）要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。 Google 
建议您在每次请求中使用重定向不要超过 5 次。 您可以使用网站管理员工具查看一下 Googlebot 
在抓取重定向网页时是否遇到问题。 诊断下的网 络抓取页面列出了由于重定向错误而导致 
 
Googlebot 无法抓取的网址。
300（多种选择）针对请求，服务器可执行多种操作。 服务器可根据请求者（用户代理）选择一项操
作，或提供操作列表供请求者选择。
301（永久移动）请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。 
您应使用此代码告诉 Googlebot 某个网页或网站已永久移动到新位置。
302（暂时移动）服 务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的
请求。 此代码与响应 GET 或 HEAD 请求的 301 代码类似，会自动将请求者转到不同的位置，但您不应使
用此代码来告诉 Googlebot 某个网页或网站已经移动，因为 Googlebot 会继续抓取原有位置并编入索引。
303（查看其他位置）请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代
码。 对于除 HEAD 之外的所有请求，服务器会自动转到其他位置。
304（未修改）自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。如果
网页自请求者上次请求后再也没有更改过，您应当将服务器配置为返回此响应（称为 If-Modified-Since 
HTTP 标头）。 由于服务器可以告诉 Googlebot 自从上次抓取后网页没有更改过，因此可节省带宽和开
销。
305（使用代理）请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用
代理。
307（暂时重定向）服 务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后
的请求。 此代码与响应 GET 和 HEAD 请求的 301 代码类似，会自动将请求者转到不同的位置，但您不应
使用此代码来告诉 Googlebot 某个页面或网站已经移动，因为 Googlebot 会继续抓取原有位置并编入索
引。
d、4xx（请求错误）这些状态代码表示请求可能出错，妨碍了服务器的处理
400（错误请求）服务器不理解请求的语法。
401（未授权）请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。
403（禁止）服务器拒绝请求。 如果您看到 Googlebot 在尝试抓取您网站上的有效网页时收到此状态代
码（可以在 Google 网站管理员工具诊 断下的网络抓取页面上看到此信息），可能是您的服务器或主机拒绝 
Googlebot 访问。
404（未找到）服务器找不到请求的网页。 例如，如果请求服务器上不存在的网页，服务器通常会返回
此代码。如果您的网站上没有 robots.txt 文件，而您在 Google 网站管理员工具”诊断”标签的 
robots.txt 页上看到此状态，那么这是正确的状态。 但是，如果您有 robots.txt 文件而又看到此状态，
则说明您的 robots.txt 文件可能命名错误或位于错误的位置 （该文件应当位于顶级域名，名为 
robots.txt）。如果您看到有关 Googlebot 尝试抓取的网址的此状态（在”诊断”标签的 HTTP 错误页
上），则表示 Googlebot 追踪的可能是另一个页面的无效链接（是旧链接或输入有误的链接）。
405（禁用的方法）禁用请求中指定的方法。
406（不可接受）无法使用请求的内容特性响应请求的网页。
407（需要代理授权）此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。 如果服务
器返回此响应，还会指明请求者应当使用的代理。
408（请求超时）服务器等候请求时发生超时。
409（冲突）服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。 服务器在响应
与前一个请求相冲突的 PUT 请求时可能会返回此代码，同时会附上两个请求的差异列表。
410（已删除）如果请求的资源已永久删除，服务器就会返回此响应。 该代码与 404（未找到）代码相
似，但在资源以前存在而现在不存在的情况下，有时会用来替代 404 代码。 如果资源已永久删除，您应当
使用 301 指定资源的新位置。
411（需要有效长度）服务器不接受不含有效内容长度标头字段的请求。
412（未满足前提条件）服务器未满足请求者在请求中设置的其中一个前提条件。
413（请求实体过大）服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。
414（请求的 URI 过长）请求的 URI（通常为网址）过长，服务器无法处理。
415（不支持的媒体类型）请求的格式不受请求页面的支持。
416（请求范围不符合要求）如果页面无法提供请求的范围，则服务器会返回此状态代码。417（未满足
期望要求）服务器未满足”期望”请求标头字段的要求。
e、5xx（服务器错误）：这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可
能是服务器本身的错误，而不是请求出错
500（服务器内部错误）服务器遇到错误，无法完成请求。
501（尚未实施）服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代
码。
502（错误网关）服务器充当网关或代理，从上游服务器收到无效响应。
503（服务不可用）服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。
504（网关超时）服务器充当网关或代理，但没有及时从上游服务器收到请求。
505（HTTP 版本不受支持）服务器不支持请求中所用的 HTTP 协议版本。
四、	实验
#######源码包Apache安装
yum -y install openssl openssl-devel zlib zlib-devel  pcre-devel    
cp -r /soft/apr-1.4.6 /soft/httpd-2.4.7/srclib/apr
cp -r /soft/apr-util-1.4.1 /soft/httpd-2.4.7/srclib/apr-util

./configure --prefix=/usr/local/apache2 --enable-rewrite --enable-so --enable-headers --enable-expires --with-mpm=worker 
--enable-modules=most --enable-deflate  --enable-ssl 
#########
1、身份验证 – 用户名密码验证
a、	在 /usr/local/apache2/htdocs   目录下创建文件 .htaccess
authname "welcome to apahce"  #欢迎提示信息
authtype basic  #认证类型
authuserfile /usr/local/apache2/htdocs/a.psd  #认证文件存放位置
require valid-user   #除了认证用户其它不允许登录
      
b、	添加用户，与系统用户无关
/usr/local/apache2/bin/htpasswd    -c    /usr/local/apache2/htdocs/a.psd    zhangsan
/usr/local/apache2/bin/htpasswd    -m    /usr/local/apache2/htdocs/a.psd    lisi
说明：   -c  创建密码文件，只添加第一个用户时使用   -m  创建密码文件，不限次数
c、vim  /usr/local/apache2/conf/

.conf
   AllowOverride    All
d．浏览器访问验证
2、身份验证 – 客户端验证
a、修改主配置文件，验证方式分一下两种类型               
①、	允许个别，拒绝所有     (241行)  
 AllowOverride None                            
<requireall>
      Require    all    granted
      require    ip    xx.xx.xx.xx
</requireall>            
     
②、	拒绝个别，允许所有
    <requireAll>
        Require all granted
        require not ip 10.10.10.11
    </requireAll>
3、目录别名
a、修改主配置文件（可以随意找地方添加）
       添加
alias "/a" "/usr/local/apache2/htdocs/a/b/c/d"  
含义：将访问路径由 http://IP地址/a/b/c/d 简化为   http://IP地址/a  
4、虚拟主机
A、	类型
基于  IP  的虚拟主机
基于  端口  的虚拟主机
基于  域名  的虚拟主机
B、	基于  IP  的虚拟主机 
实验环境：一台服务器，多个  IP  地址，搭建多个网站
①、	在  eth0  网卡上添加一个子接口  eth0:0
ifconfig  eth0:0  192.168.66.17:80 netmask 255.255.255.0
②、	开启主配置文件中的虚拟主机选项(取消注释)
Virtual hosts    Include etc//extra/httpd-vhosts.conf
③、	修改虚拟机配置文件添加虚拟主机              
vim /usr/local/apache2/conf/extra/httpd-vhosts.conf     
 <VirtualHost 192.168.66.16:80>
    DocumentRoot "/usr/local/apache2/htdocs/abc"
    ServerName dummy-host2.example.com（www.xdl.com）
 </VirtualHost>
 <VirtualHost 192.168.66.17:80>
    DocumentRoot "/usr/local/apache2/htdocs/def"
    ServerName dummy-host2.example.com (www.xdl.com)
  </VirtualHost>
④、	重启服务，是修改生效
C、基于  端口  的虚拟主机 
实验环境：一台服务器，搭建多个网站，每个网站使用不同的端口通讯
①、	开启主配置文件中的虚拟主机选项(取消注释)
Virtual hosts    Include etc//extra/httpd-vhosts.conf
添加监听端口
Listen  8080
②、	修改虚拟机配置文件添加虚拟主机
vim /usr/local/apache2/etc/extra/httpd-vhosts.conf 
<VirtualHost 192.168.66.16:80>
    DocumentRoot "/usr/local/apache2/htdocs/abc"
    ServerName dummy-host2.example.com（www.xdl.com）
</VirtualHost>
<VirtualHost 192.168.66.16:8080>
    DocumentRoot "/usr/local/apache2/htdocs/def"
    ServerName dummy-host2.example.com (www.xdl.com)
</VirtualHost>
③、	重启服务使配置文件生效
D、基于  域名  的虚拟主机 
实验环境：一台服务器，搭建多个网站，每个网站使用不同的域名通讯
①、	搭建一个DNS服务器
②、	开启主配置文件中的虚拟主机选项（取消注释）：        
#Virtual hosts     Include etc//extra/httpd-vhosts.conf
③、	进入虚拟主机配置文件：    
vim /usr/local/apache2/etc/extra/httpd-vhosts.conf 
<VirtualHost 192.168.66.16:80>
    DocumentRoot "/usr/local/apache2/htdocs/abc"     
ServerName www.abc.com
</VirtualHost>
<VirtualHost 192.168.66.16:80>
    DocumentRoot "/usr/local/apache2/htdocs/def"
    ServerName www.def.com
</VirtualHost>
④、	重启服务
E、个人主页
实验要求，每个用户一个单独的网页空间
①、	开启模块
取消注释    LoadModule userdir_module modules/mod_userdir.so  模块
取消注释    Include conf//extra/httpd-userdir.conf  注释文件
②、	进入配置文件
 vim  /usr/local/apache2/conf/extra/httpd-userdir.conf         不做修改退出
③、	创建用户
useradd    zhangsan            passwd    zhangsan
4、	进入用户目录创建    
cd    /home/zhangsan      mkdir public_html        vi    index.html
5、	给    public_html   家目录   网页文件   赋予执行权限
6、	通过浏览器访问进行测试，访问链接为：  http://10.10.10.11/~user1/
 
F、地址跳转
实验要求，配置完虚拟主机之后实现域名跳转的实验
①、	配置DNS
②、	vim    /usr/local/apache2/conf/httpd.conf
开启模块    LoadModule vhost_alias_module modules/mod_vhost_alias.so 开启虚拟主机
开启模块    LoadModule rewrite_module modules/mod_rewrite.so      开启网页重写模块
加载模块    Include conf/extra/httpd-vhosts.conf
③、	vim /usr/local/apache2/conf/extra/httpd-vhosts.conf 
<VirtualHost *:80>
    DocumentRoot "/usr/local/apache2/htdocs/xdl"
    ServerName www.xdl.com

</VirtualHost>
<Directory "/usr/local/apache2/htdocs/xdl">
        options indexes followsymlinks
        allowoverride All
        require all granted
</Directory>
<VirtualHost *:80>
    DocumentRoot "/usr/local/apache2/htdocs/edu"
    ServerName www.edu.com
</VirtualHost>
④、cd /htdocs/a    vi .htaccess
rewriteengine on
rewritecond %{HTTP_HOST} www.xdl.com
rewriterule .* http://www.edu.com


8.30      
 https  加密  
一、客户端获取加密证书以及与证书颁发厂商之间建立联系的过程
 
1.	服务器端生成密钥文件发给ca厂商
2.	ca厂商将证书颁给服务器（相当于公钥）
3.	client访问网站服务器
4.	服务器将证书发给客户端client
5.	client拿着证书与ca厂商去核对，
        如果正确，则继续访问网站
        如果不正确，则警告client，此网站有危险
二、server端与client端建立联系的详细过程
 


1.	client放送一个80端口的访问请求
2.	（地址跳转）server端返回数据包，强制client端以https访问（443端口）
3.	client以https形式访问
4.	server端返回一个加密证书
5.	客户端生成一个随机的秘钥（与server端确认加密方式）
6.	将生成的密钥和加密证书一起发给server端
7.	server端用本地生成的密钥文件，将加密文件打开
8.	然后开始tcp文件传输（三次握手）

三、	实验
在是实验环境下给自己颁发证书
注：在实验环境中可以用一下命令生成测试，在生产环境中必https厂商注册使用    
1)	openssl genrsa -des3 -out server.key 1024	  	
#建立服务器私钥（过程需要输入密码，请记住这个密码）生成RSA密钥
2)	openssl req -new -key server.key -out server.csr    	
#需要依次输入国家，地区，组织，email。最重要的是有一个common name，可以写你的名字或者域名。如果为了https申请，这个必须和域名
吻合，否则会引发浏览器警报。生成的csr文件交给CA签名后形成服务端自己的证书
3)	cp server.key server.key.org	
       #私钥备份  
4)	openssl x509 -req  -days 365 -sha256   -in server.csr -signkey server.key -out servernew.crt 	 
#命令生成v1版证书
5)	cp servernew.crt  /usr/local/apache2/conf/server.crt

6)	cp server.key /usr/local/apache2/conf/server.key

7)	进入apache配置文件开启相应模块
LoadModule ssl_module modules/mod_ssl.so

Include conf/extra/httpd-ssl.conf
8)	打开ssl加密配置文件修改
vim /usr/local/apache2/conf/extra/httpd-ssl.conf
修改Server name
ServerName www.example.com:443
9)	开启Apache
/usr/local/apache2/bin/apachectl start
10)	编写网页文件
echo “123” >> /usr/local/apache2/htdocs/index.html
11)	关闭listen80端口
vim /usr/local/apache2/conf/httpd.conf
12)	https://IP访问
LNMP环境搭建
一、软件说明
    Nginx  是由  Igor Sysoev  为俄罗斯访问量第二的  Rambler.ru  站点开发
一个公开版本0.1.0发布于2004年10月4日发布第一个公开版本0.1.0
Nginx是一款轻量级的  Web  服务器/反向代理服务
中国大陆使用  nginx  网站用户有：百度、京东、新浪、网易、腾讯、淘宝 ( Tengine ) 等
二、正向代理
    
三、反向代理
 
反向代理服务器的过程：
反向代理服务器位于web服务器的前端，没有配置任何数据，只配置反向代理规则。
1.	外网DNS将域名解析到反向代理服务器Nginx
2.	客户端拿解析的IP访问
3.	Nginx根据反向代理规则去访问真实服务器
4.	web服务器把真实数据返回给Nginx
5.	Nginx把数据嵌套发给客户端


使用反向代理服务器：
	1、隐藏真是web服务器
	2、更利于安全设置
	3、负载（在反向代理区域编写规则，响应不同的服务器，实现负载）
四、apache和nginx工作模式对比
Nginx   epoll                                 
	1、并发更高                            非阻塞 非监听
	2、模块相对较少，但是高性能优异

Apache	select                            
	1、相对 Nginx 更为稳定                阻塞 监听  
	2、模块众多
阻塞：一个线成提交请求，直到获取返回数据才会去执行其他任务
非阻塞：一个线成提交完请求，去执行其他任务，如果得到返回数据，再去执行刚才的那个任务
监听：提交完请求，会挂起，而不会去执行其他任务
非监听：提交完请求，再去接收下一个任务
五、lamp单层架构
 


kill –s QUIT $(cat ngin	x.pid)
正常杀死nginx进程

kill –s HUP $(cat ngin	x.pid)
平滑重启：不关闭服务，重新读取配置文件并加载

活动连接：用户正在进行一个连接，正在下载文件

非活动连接：用户正在进行一个连接，但是不进行TCP四次握手的连接状态
1000 非活动连接   几十M

nginx 和 php-fpm的开启顺序

开启：/usr/local/php5/sbin/php-fpm
       /usr/local/nginx/sbin/nginx

关闭：kill –s QUIT $(cat  /usr/local/nginx/logs/nginx.pid)
      pkill php-fpm


php-fpm作用：php文件解析
               因为nginx不识别php文件

































8.31        网络服务Nginx &&   TOMCAT
	网络服务Nginx
一、Apachee 和 Nginx差异对比
Apache                                  Nginx
配置相对复杂                             配置相对简单
原生支持动态和静态页面                   支持静态页面
模块相对安全                             高性能模块出产迅速、社区活跃
BUG相对较少，消耗资源较多               BUG相对较多，节省资源
对加密支持较好                           对反向代理支持较好
同步阻塞型应用                           异步非阻塞型应用
二、单独安装Nginx 
    
yum -y install gcc*
yum -y install pcre pcre-devel zlib*
useradd -s /sbin/nologin -M nginx
解压软件包 nginx
tar -zxvf nginx-1.2.6.tar.gz
./configure --prefix=/usr/local/nginx --user=nginx --group=nginx --with-http_stub_status_module --with-http_ssl_module   
最后一个用于https实验
make
make install
添加监控模块
vim /usr/local/nginx/conf/nginx.conf
location /abc {
stub_status on;       监控连接数的模块
}

浏览器访问查看
192.168.19.63/abc

三、Nginx实验  
1 、 Nginx  身份验证
a 、基于用户名密码
1)vi /usr/local/nginx/conf/nginx.conf

location /abc {
stub_status on;
auth_basic "Welcome to nginx!";
auth_basic_user_file /usr/local/nginx/html/a.psd;
}

2)添加用户
htpasswd -c /usr/local/nginx/html/a.psd zhangsan
htpasswd -m /usr/local/nginx/html/a.psd lisi

3）
/usr/local/nginx/sbin/nginx  -t    检查配置文件是否正确修改
kill  -s   HUP   $( cat /usr/local/nginx/logs/nginx.pid)
                                         平滑重启
4）浏览器登录查看
192.168.19.63/abc
b .基于 IP 限制访问
vim /usr/local/nginx/conf/nginx.conf
location /abc {
stub_status on;
auth_basic "Welcome to nginx!";
auth_basic_user_file /usr/local/nginx/html/a.psd;
allow 192.168.19.64; 
deny 192.168.24.0/24;               允许 250 拒绝所有
}

拒绝单个
location / {
            root   html;
            index  index.html index.htm;
        deny 192.168.19.2;
        }

/usr/local/nginx/sbin/nginx  -t    检查配置文件是否正确修改
kill  -s   HUP   $( cat /usr/local/nginx/logs/nginx.pid)
                                         平滑重启

c. 虚拟主机
server相当于虚拟主机配置区域
vim /usr/local/nginx/conf/nginx.conf
复制 server{} 区域，不同的 server  区域则是不同的虚拟主机，同 apache 拥有基于域名端口的虚拟
主机

d．基于端口
1)vi /usr/local/nginx/conf/nginx.conf   复制添加server区域
server {
        listen       80;
        server_name  localhost;
        location / {
            root   html/a;
            index  index.html index.htm;
        }
        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }
    }

    server {
        listen       8080;
        server_name  localhost;
        location / {
            root   html/b;
            index  index.html index.htm;
        }
        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }
     }


2)创建网页文件
cd /usr/local/nginx/html

rm –rf *

mkdir  a  b
chown  nginx:nginx  *      修改所有网页目录的所有者所属组为nginx
echo "123" >> a/index.html
echo "456" >> b/index.html

3)检查配置文件的修改并重启
/usr/local/nginx/sbin/nginx   -t
kill  -s  HUP  $( cat /usr/local/nginx/logs/nginx.pid)

4)查看访问不同端口时的网页内容
curl  192.168.19.63
curl  192.168.19.63:8080

e.基于域名
1)在第二台主机（192.168.19.64）上配置DNS
yum  -y  install bind
#
vim /etc/named.conf   
      两个  any
#
cp –a  /etc/named.rfc1912zones  /etc/named.rfc1912zones.back

vim /etc:/named.rfc1912zones   
    zone "xdl.com" IN {
        type master;
        file "xdl.localhost";
        allow-update { none; };
};

zone "edu.com" IN {
        type master;
        file "edu.localhost";
        allow-update { none; };
};

#
cd /var/named/
cp –a named.localhost  xdl.localhost
cp –a named.localhost  edu.localhost

vim xdl.localhost
$TTL 1D
@       IN SOA  xdl.com. rname.invalid. (
                                        0       ; serial
                                        1D      ; refresh
                                        1H      ; retry
                                        1W      ; expire
                                        3H )    ; minimum
        NS      dns.xdl.com.
www     A       192.168.19.63
dns     A       192.168.19.64

vim edu.localhost

$TTL 1D
@       IN SOA  edu.com. rname.invalid. (
                                        0       ; serial
                                        1D      ; refresh
                                        1H      ; retry
                                        1W      ; expire
                                        3H )    ; minimum
        NS      dns.edu.com.
www     A       192.168.19.63
dns     A       192.168.19.64

#service named restart

2)修改nginx配置文件
vim /usr/local/nginx/conf/nginx.conf


server {
        listen       80;
        server_name  www.xdl.com;
        location / {
            root   html/a;
            index  index.html index.htm;
        }
        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }
    }

    server {
        listen       80;
        server_name  www.edu.com;
        location / {
            root   html/b;
            index  index.html index.htm;
        }
        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }
     }


检查配置文件的修改并重启
/usr/local/nginx/sbin/nginx   -t
kill  -s  HUP  $( cat /usr/local/nginx/logs/nginx.pid)
3)在第三台虚拟机（192.168.19.66图形化）测试

配置DNS指向第二台主机  192.168.19.64

浏览器访问测试(使用本机时要插网线)

www.xdl.com
www.edu.com

f 、 Nginx 的反向代理功能
说明：反向代理的实现过程是，当客户端访问请求道 nginx 服务器是，nginx充当客户端去真正的服务端去
数据，返回给client端，这个过程称之为反向代理
实验环境说明：192.168.1.3 安装了lamp环境，192.168.1.2 安装了 nginx 程序，实现 nginx 完全的反向代理 lamp
location / {
proxy_pass http://192.168.19.64:80;
}
1)在第一台主机192.1681.19.63搭建nginx，并修改配置文件
location / {
           proxy_pass http://192.168.19.64:80;
        }
2)在第二台主机上安装apache
yum –y install  httpd

echo  “apache” >> /var/www/html/idex.html

3)浏览器访问测试
192.168.19.63

g. 负载调度的用法
1)安装nginx
2)在server区域外创建一个 upstream 区域，此区域中编写的内容为负载群
upstream xdl.com {
ip_hash;
#调度算法，默认 rr 轮训，hash常用语解决session共享的问题
server 192.168.19.64:80 weight 1;
server 192.168.19.65:80 weight 1;
server 192.168.19.66:80 weight 1 backup;
#backup 表示机器处于热备状态，weight代表权重，权重越高代表使用越多
}
3)在 / 的区域内设置反向代理
location / {
proxy_pass http://xdl.com;
} 

4）在另外两台主机上安装 httpd
  a．yum   -y  install  httpd  
     echo   "123" > /var/www/html/index.html
  b.yum    -y  install  httpd
     echo   "456" > /var/www/html/index.html
5)访问www.xdl.com

h.地址跳转
1.第一台主机搭建nginx并修改配置文件
 #gzip  on;
    server {
    listen 80;
    server_name www.xdl.com;
    rewrite ^(.*)$ http://www.edu.com permanent;
}

 server {
        listen       80;
        server_name  www.edu.com;
        location / {
            root   html/b;
            index  index.html index.htm;
        }
        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }
     }
}

 2.编写www.edu.com的网页文件
   
3.第二台搭建DNS正向解析
    解析www.xdl.com 和www.edu.com
4.第三台图形化界面访问www.xdl.com

I HTTPS 加密访问
在上个实验基础上直接进行实验
普通加密：
      server {
          listen       443;
          ssl on;
          ssl_certificate server.crt;
          ssl_certificate_key server.key;
          ssl_session_timeout 5m;
          ssl_protocols TLSv1;
          ssl_ciphers HIGH:!RC4:!MD5:!aNULL:!eNULL:!NULL:!DH:!EDH:!EXP:+MEDIUM;
          ssl_prefer_server_ciphers on;
          location / {
              root   html;
              index  index.html index.htm;
          }
          error_page   500 502 503 504  /50x.html;
          location = /50x.html {
              root   html;
          }
      }
  }

跳转加密：
1)在需要使用https加密访问的 server{} 区域内添加一下内容开启 SLL 加密

cd /usr/local/nginx/conf

cp   -a   nginx.conf.default  nginx.conf

server {
listen 80;
server_name www.xdl.com;
rewrite ^(.*)$ https://www.xdl.com permanent;
} 

server {
        listen       443;
        server_name  www.xdl.com;
		
        ssl on;
        ssl_certificate server.crt;
        ssl_certificate_key server.key;
        ssl_session_timeout 5m;
        ssl_protocols TLSv1;
        ssl_ciphers HIGH:!RC4:!MD5:!aNULL:!eNULL:!NULL:!DH:!EDH:!EXP:+MEDIUM;
        ssl_prefer_server_ciphers on;
		
         location / {
            root   html/a;
            index  index.html index.htm;
        }
        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }
    }
}


2)将本站点的 server.pem 以及 server.key 放入 nginx 的 conf/ 目录下
注：在实验环境中可以用一下命令生成测试，在生产环境中必须要在https厂商注册使用
openssl genrsa -des3 -out server.key 1024 #建立服务器私钥（过程需要输入密码，请记住这个密码）生成
RSA密钥
openssl req -new -key server.key -out server.csr #需要依次输入国家，地区，组织，email。最重要的是有
一个common name，可以写你的名字或者域名。如果为了https申请，这个必须和域名吻合，否则会引发
浏览器警报。生成的csr文件交给CA签名后形成服务端自己的证书
cp server.key server.key.org
openssl x509 -req -days 365 -sha256 -in server.csr -signkey server.key -out servernew.crt  # # 命令生成v1版证书
cp servernew.crt /usr/local/nginx/conf/server.crt
cp server.key /usr/local/nginx/conf/server.key
3)第三台进行测试
   https：//www.xdl.com
   
   

J.  只有主机1配置https，访问其他三台负载主机也是https加密
1）	第一台主机安装nginx并修改配置文件
#gzip  on;
upstream xdl.com {                         ——————负载
    server 192.168.19.64;
    server 192.168.19.65;
}
    server {
    listen 80;
    server_name www.xdl.com;
    rewrite ^(.*)$ https://$host$1 permanent;
}

    server {
        listen       443;
        server_name  www.xdl.com;
        ssl on;
        ssl_certificate server.crt;
        ssl_certificate_key server.key;
        ssl_session_timeout 5m;
        ssl_protocols TLSv1;
        ssl_ciphers HIGH:!RC4:!MD5:!aNULL:!eNULL:!NULL:!DH:!EDH:!EXP:+MEDIUM;
        ssl_prefer_server_ciphers on;

        location / {
        proxy_pass http://xdl.com;      ————反向代理
        }
        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }
    }
}
2）	在其他两台主机上安装apache并编写网页文件
    echo 123 > /var/www/html/index.html  (192.168.19.64)
	echo 123 > /var/www/html/index.html   (192.168.19.65)
3）	测试    www.xdl.com




LTMJ
一、	结构
 

二、软件说明
Tomcat是Apache 软件基金会（Apache Software Foundation）的Jakarta 项目中的一个核心项目，由Apache、Sun 和其他一些公司及个人共同
开发而成。由于有了Sun 的参与和支持，最新的Servlet 和JSP 规范总是能在Tomcat 中得到体现，Tomcat 5支持最新的Servlet 2.4 和JSP 
2.0 规范。因为Tomcat 技术先进、性能稳定，而且免费，因而深受Java 爱好者的喜爱并得到了部分软件开发商的认可，成为目前比较流行的
Web 应用服务器。



JDK是 Java 语言的软件开发工具包，主要用于移动设备、嵌入式设备上的java应用程序。JDK是整个java开发的核心，它包含了JAVA的运行环境
，JAVA工具和JAVA基础的类库。

三、单层架构
 

四、	搭建（见文档）
tomcat端口  8080
文档chkconfig  nginx  on
改为chkconfig  mysqld on

SYNC

copy单线成
rsync多线成，效率更高

一、一款快速增量备份工具
    Remote Sync，远程同步
    支持本地复制，或者与其他SSH、Sync主机同步
    官方网站：http://rsync.samba.org/
	
	
    Sync（remote synchronize）是一个远程数据同步工具，可通过 LAN/WAN 快速同步多台主机之间的文件，也可以使用 Rsync 同步本地硬盘
	中的不同目录
    Rsync 是用于取代 rcp 的一个工具，Rsync 使用所谓的 “Rsync 算法”来使本地与远程两个主机之间的文件达到同步，这个算法只传送两
	文件的不同部分，而不是每次都整份传送，因此速度相当快。
    Rsync支持大多数的类 Unix 系统，无论是 Linux、Solaris 还是 BSD 上都经过了良好的测试。此外，它在 windows 平台下也有相应的版本，
	比较知名的有 cwRsync 和 Sync2NAS
特点：
	能更新整个目录和树文件系统：
    有选择性的保持符号链接、硬链接、文件属于、权限、设备以及时间等；

    对于安装来说，无任何特殊权限的要求：
    对于多个文件来说，内部流水线减少等待的延迟；
    能用 rsh 、 ssh 或直接端口作为传输入端口；
    支持匿名 rsync 同步文件，是理想的镜像工具；
	
同步源与发起端
    Sync同步源：
	指备份操作的远程服务器，也称为备份源
	主要包括两种：Rsync源   程序自己开放一个端口
	              SSH源      借用SSH的22号端口

	服务器端（RSYNC或ssh同步源）<—————————— 上行同步（上传）<——————————————（RSNYC客户机，发起端）
	                             ——————————>下行同步 （下载）—————————————> 
二、网络时间协议NTP（Network Time Protocol）是用于互联网中时间同步的标准互联网协议。NTP的用途是把计算机的时间同步到某些
时间标准。目前采用的时间标准是世界协调时UTC（Universal Time Coordinated）。
    服务器上必须进行的操作：NTP时间同步
	                        本地yum源
软件包：ntp
主配置文件：/etc/ntp.conf
启动脚本：/etc/init.d/ntpd

三、RSNYC基础知识
    
一、基础知识
1 、 Sync ： 利用 sync 算法进行数据同步的工具，在多平台下使用。可以跟新整个目录和文件系统备份，可以选择性
保留符号链接，不需要特殊的权限要求。
2 、 ssh  工具中 scp  与 sync  有什么差距： scp  传输过程中使用的是单线程。而 sync  使用的是多线程
3 、 Rsync  命令常用用法
基本格式： rsync  【选项】 原始位置 目标位置
常用选项：
-a ：归档模式，递归保留对象属性，等同于 -rlptgoD
-v ：显示同步过程的详细信息（ verbose ）信息
-z ：在传输文件是进行压缩（ compress ）
-H ：保留硬链接文件
-A ：保留 ACL  属性信息
--delete ：删除目标位置有而原始位置没有的文件
-r ：递归模式，包含目录和子目录中所有文件
-l ：对于符号连接文件仍然复制为符号连接文件
-p ：保留文件的权限标记
-t ：保留文件的时间标记
-g ：保留文件的属主标记（仅超级用户使用）
-o ：保留文件属主标记（仅超级用户使用）
-D ：保留设备文件及其他特殊文件
三、 同步实验
1 、时间同步服务器（ C/S ）
a 、服务器端
yum -y install ntp 安装时间同步服务器 ntp
vim /etc/ntp.conf 修改 ntp  服务器配置文件
    # Hosts on local network are less restricted.
      restrict 192.168.63.0 mask 255.255.255.0 nomodify notrap
                                     标识为 192.168.63.0网段提供服务， nomodify 标识禁止修改服务器时间， notrap 标识禁止抓包，
									 直接添加
    #server 0.rhel.pool.ntp.org iburst 注释（相当于官方时间同步服务器）
    #server 1.rhel.pool.ntp.org iburst
    #server 2.rhel.pool.ntp.org iburst
    #server 3.rhel.pool.ntp.org iburst(下方添加两行)                           
    server 127.127.1.0               标识时间服务器是本机
    fudge 127.127.1.0 stratum 10     标识时间服务器的级别， 0-15 级别一半设为中间 10
service ntpd start                   开启 ntp  服务以及开机自启动
chkconfig ntpd on
ntpq -p                              查看时间服务器状态
ntpstat                              查看时间服务器工作状态
	
b 、客户端
    ntpdate -u 192.168.19.63     主动从时间服务器同步时间
2 、基于 SSH验证的同步源
a 、密钥对认证(不用输密码)
    ssh-keygen -t rsa
    ssh-copy-id root@ 对方 IP 地址
b 、下载： rsync -avz root@ 服务器 IP:/ 对方文件位置 / 保存位置
c 、上传： rsync -avz 本地文件 root@ 服务器 IP:/ 保存位置
    (1)服务端：mkdir /server 
	        cd /server 
			touch {1..10}.txt
	(2)客户端：mkdir /client
	(3)服务端上传：
	        rsync -avz /server/ root@192.168.19.64:/client
			 下载：
			rsync -avz root@/192.168.19.64:/client /server
			
	如果在客户端的/client下新创建一个文件
	 客户端       touch 11.txt）
	 服务端       rsync -avz --delete /server root@192.168.19.64:/client
	              注：--delete 完全相同与服务器，删除与本地不同的
				  
	如果在服务端的/server下新创建一个文件
	              rsync -avz --delete root@/192.168.19.63:/server /client
	


3 、基于 RSYNC 的同步源
a 、服务端
（1）mkdir -p /server/rsync
    cd !$
    touch {1..10}.txt
    vim /etc/rsyncd.conf       创建配置文件，直接生成，原本没有
    use chroot = yes           进入宿主目录
    address = 192.168.19.63    申明服务器 IP 地址
    port 873                  申明端口号，默认就是 873
    log file = /var/log/rsync.log 指定日志文件位置
    pid file = /var/rsyncd.pid 指定 PID 文件位置
    [pub]                                申明目录
    comment = rsync server
    path = /server/rsync                 服务器目录
    read only = yes                      只读
    dont compress = *.gz *.tgz *.bz2     申明哪些文件不进行压缩，已经压缩文件不进行压缩
    auth users = aaa                     指定在使用 sync 的用户名密码，虚拟的不真实存在
    secrets file = /etc/rsyncd_users.db  存放虚拟用户密码文件
   
    vim /etc/rsyncd_users.db             创建验证文件
    aaa:123456
    chmod 600 /etc/rsyncd_user.db        给予验证文件 600 权限 ***** 必须
    rsync --daemon 开启服务
    kill -s QUIT $( cat /var/rsyncd.pid)
    netstat -anpt | grep :873               查看端口

b 、客户端
mkdir -p /client/rsync
cd !$
export RSYNC_PASSWORD=123456 申明全局变量， sync 验证时先搜寻变量在输入密码
rsync -avz 服务器虚拟用户名 @ 服务器地址 :: 共享名 保存目录
--delete 完全相同与服务器，删除本地不同的
example ： rsync -avz aaa@192.168.19.63::pub /client/rsync
           下面两种命令也可以
           rsync -avz rsync://aaa@10.10.10.11/pub   /client    下行(客户端)
		   使用rsync -avz /client/ rsync://aaa@192.168.19.63/pub 上传时报错 ，因为配置文件中声明了共享目录可读，所以这时我们
           需要将read only = yes 改成 no ，并且让aaa对共享目录/server/rsync有写入权限（aaa在这里虚拟出来的，相当于nobody用户）
                 setfacl -m u:nobody:rwx /server/rsync		   
[root@CentOS-4 ~]# rsync -avz /client/ rsync://aaa@192.168.19.63/pub   上行（客户端）
sending incremental file list
ERROR: module is read only
rsync error: syntax or usage error (code 1) at main.c(866) [receiver=3.0.6]
rsync: read error: Connection reset by peer (104)
rsync error: error in rsync protocol data stream (code 12) at io.c(759) [sender=3.0.6]
		   
		   
           rsync -avz /client/*   rsync://aaa@192.168.19.63/pub   上行(客户端)
		   
4 、实时同步 Rsync+Inotify 单向
    服务器上配置密钥对（不用输密码）
    ssh-keygen -t rsa
    ssh-copy-id root@对方 IP 地址

a 、服务器端
①、安装 inotifiy
    tar -zxf inotify-tools-3.14.tar.gz 解包
    ./configure
    make make install
②、优化，调整内核参数（可以不添加，数据大最好优化）
    vim /etc/sysctl.conf 末尾添加
    fs.inotify.max_queued_events = 16384               队列大小
    fs.inotify.max_user_instances = 1024               实例大小
    fs.inotify.max_user_watches = 1048576              每个实例监控的最大的文件数
说明：此参数为红帽 6 版本的，其它版本需查询，版本不同参数不同
    sysctl -p 刷新内核参数
③、开启监控（测试）
    inotifywait -mrq -e create,delete /server/rsync  为监控目
	      inotifywait		持续监控，发生变化及通知
          inotifywatch	    临时监控，任务完成以后发送报告 
④、脚本连接
vim 1.sh
#!/bin/bash
a="inotifywait -mrq -e create,delete / /server/rsync "
b="rsync -avz --delete /server/rsync root@192.168.19.64:/client"
$a | while read DIRECTORY EVENTFILE
do
  $b
done
⑤、启动脚本
chmod 777 1.sh
./1.sh &

可以将脚本写到/etc/rc.local中   开启自启动
     vim  /etc/rc.local
     bash /sh/1.sh	 
5 、实时同步 Unison + Inotify 双向
a 、服务器和客户端都需配置秘钥对
    ssh-keygen -t rsa
    ssh-copy-id root@192.168.19.63
说明：基于 ssh 实现不需要密码同步方式
b 、安装 ocaml unison inotify
①、安装 inotify
    tar -zxf inotify-tools-3.14.tar.gz
    ./configure
    make && make install
    vim /etc/sysctl.conf 末尾添加
       fs.inotify.max_queued_events = 16384
       fs.inotify.max_user_instances = 1024
       fs.inotify.max_user_watches = 1048576
       sysctl -p                           刷新内核参数
②、安装 ocalml
    tar -zxf ocaml-3.10.1.tar.gz
    cd ocaml-3.10.1
    ./configure
    make world opt
    make install
③、安装 unison
    tar -zxf unison-2.13.16.tar.gz
    cd unison-2.13.16
    make UISTYLE=text THREADS=true static=true
    cp unison /usr/local/bin/
④、创建文件夹
mkdir xxx
                                    setfacl -m u:root:rwx /wangyang/
⑤、配置脚本
#!/bin/bash
a="inotifywait -mrq -e create,delete / 本地目录 "
b="/usr/local/bin/unison -batch /server1/ ssh://root@10.10.10.11//server2"
$a | while read DIRECTORY EVENTS FILE
do
$b
done






PXE装机
	1、安装环境
	yum -y install     vsftpd     dhcp     tftp    syslinux   tftp-server

2、拷贝镜像文件到 ftp 服务器目录
	cd /var/ftp/pub
	mkdir dvd
	chown ftp:ftp dvd
	cp -rf /mnt/cdrom/*  dvd/

3、配置 DHCP 服务
	cp	/usr/share/doc/dhcp-4.1.1/dhcpd.conf.sample	 /etc/dhcp/dhcpd.conf
	vi /etc/dhcp/dhcpd.conf
		subnet 192.168.16.0 netmask 255.255.255.0 {
		  range 192.168.16.66 192.168.16.77;
		  option routers 192.168.16.2;
		  next-server 192.168.16.130; #tftp server的ip
		  filename "pxelinux.0"; 
		}

4、开启 tftp 服务
	vi /etc/xinetd.d/tftp
		service tftp
		{
				socket_type             = dgram
				protocol                = udp
				wait                    = yes
				user                    = root
				server                  = /usr/sbin/in.tftpd
				server_args             = -s /tftpboot       设置默认工作目录
				disable                 = no         设置开机自启动
				per_source              = 11
				cps                     = 100 2
				flags                   = IPv4
		}
	mkdir /tftpboot    

5、创建相关目录并拷贝所需文件	
	mkdir -p /tftpboot/pxelinux.cfg  
	cp /var/ftp/pub/dvd/isolinux/isolinux.cfg /tftpboot/pxelinux.cfg/default
	cp /usr/share/syslinux/pxelinux.0  /tftpboot/
	chmod 644  /tftpboot/pxelinux.cfg/default 
	cp /var/ftp/pub/dvd/isolinux/* /tftpboot/

6、开启相关服务并设置为自动启动
	service dhcpd restart
	chkconfig dhcpd on
	service xinetd restart
	chkconfig xinetd on
	service vsftpd restart
	chkconfig vsftpd on

7、配置 kisckstart 无人值守安装脚本
	yum   -y    install    system-config-kickstart
	system-config-kickstart 
	cp   ks.cfg    /var/ftp/pub/
	vi   /tftpboot/pxelinux.cfg/default（添加）
		label linux
		  menu label ^Install or upgrade an existing system
		  menu default
		  kernel vmlinuz
		  append initrd=initrd.img  ks=ftp://192.168.66.1/pub/ks,cfg
		label vesa
	
	
	
	Postfix服务器
	
	
	*Postfix概念以及原理
    *Postfix配置文件解析
    *邮件服务器端配置与客户端使用
    *dovecot的使用
    *extmail和extman
一、邮件服务器概述
    1.邮件服务器概念
	    电子邮件服务器是处理邮件交换的软硬件设施的总称，包括电子邮件程序、电子邮箱等。它是为用户提供基于E-mail服务的电子邮件
		系统，人们通过访问服务器实现邮件的交换。
	2.常见的邮件服务器：
	  LINUX端：Sendmail、Qmail、Postfix、Zmailer 
	          （Zmailer现在比较火使用率不是很高，目前用的最多的还是Postfix,Postfix是从Send中单独分出来的一个模块，但Postfix性能
			    更优异，Qmail的社区十年没有更新，163.com就是从Qmail的基础上开发的，安装包最小Sendmail性能比较优异但是对当前网
				络的支持不是很好，权限设置比较复杂）
				如果要使用以上服务器，需要公司具备一定的二次开发能力

	  Windows： Exchange（MS）、Notes/Domino（IBM）
      微软          IBM（只支持IBM）页面）
	  国产：Coremail(收费)  U-mail
	  
二、邮件服务器发展阶段
1、第一阶段有两台主机，computer1和computer2，每台机器上有两个进程:smtp和smtpd，张三想发信给lisi，smtp进程会先向lisi的smtpd发送一
个数据包，确认lisi在不在，如果在，然后把邮件发给smtpd。lisi接收到邮件后，会通过mda模块（邮件分发代理）判断邮件是否要存储到本地的，
如果是，需要把邮件交给mda判断，如果是发送给外域的，则直接发送给外域服务器，如果是发送给本域的，则存储到本地邮箱里（mailbox）
给用户发信还要确定对方在不在，这是很不合理的，所以邮件服务器就发展到了第二阶段，采用了C/S架构。
2.有一个客户端（MUA），和一个服务器端（MTA），用户需要配置好邮件服务器smtp。张三给lisi发信时。
   a．客户端先把邮件发给邮件服务器smtp，先把邮件发给MTA的smtpd
   b．MTA端会有一个SASL函数（处理垃圾邮件），通过查询lib库，调用数据库mysql（存储用户信息密码）判断邮件是否是发送给本域的，
如果不是，MDA直接发送给外域分服务器端
      如果发送给本地用户，比如lisi，会通过MDA存储在本地邮件箱
   c．客户端是无法直接登录mailbox的，这时会直接通过MRA（邮件收信）代理，去mailbox中获取邮件，并发给用户。

SASL函数：解决垃圾邮件问题

          数据库保存用户信息

三、邮件系统角色
    
MUA（邮件用户代理）：Outlook、Foxmail                           相当于客户端
MTA （邮件传输代理）：Postfix、Coremail、Sendmail               相当于服务器端
MDA（邮件分发代理）：基本集成的邮件服务器中，比如：maildrop     服务器端
MRA（邮件获取代理）：替用户去获取自己的邮件 ，比如：dovecot     服务器端


发送协议：SMTP：简单邮件传输协议  TCP 25 端口，   加密时使用 TCP 465 端口
收信协议：POP3：第三版邮局协议    TCP 110 端口    加密时使用 TCP 995 端口
                不会与服务器进行交互，比如标记邮件已读删除
          IMAP4：第四版互联网消息访问协议   TCP 143端口     加密时使用 TCP 993 端口
                与服务器进行交互，比如本地删除邮件，服务器也会删除邮件
四、邮件发送原理图
   
五、Postfix(rpm包搭建的邮件服务器)
rh centos5 之前：linux默认安装sendmail
centos6后：                      postfix
1、	安装DNS解析mail.xdl.com
并修改客户端的DNS1，并重启网卡
service network restart
2、	修改postfix主配置文件            
vi    /etc/postfix/main.cf
myhostname = mail.xdl.com      75行                     邮件服务器主机名
mydomain = xdl.com             83行                     邮件域
myorigin = $myhostname         98                  允许发送邮件的地址（取消注释） 
myorigin = $mydomain           99
inet_interfaces = all               113                监听的地址(取消注释)     net_interfaces = localhost（注释）
mydestination = $myhostname, localhost.$mydomain, localhost, $mydomain           165         设置允许接受邮件的地址
home_mailbox = Maildir/                419             邮件存放位置
service postfix restart
chkconfig  postfix restart 
3.测试
useradd zhangsan
useradd lisi 
yum    -y    install    telnet            安装telnet
telnet    mail.xdl.com    25            链接邮件服务器
helo    mail.xdl.com            申明域名
mail from: zhangsan@xdl.com
rcpt to：lisi@xdl.com
data
	dkasjdklasjkdjaklsjdlajskdla
	.
quit


3、安装 dovecot
yum -y install dovecot

service dovecot start
chkconfig dovecot start

netstat -an | grep 110 \ 143

telnet  mail.xdl.com 110
user lisi
pass 123

list  列出邮件

retr 1 使用序号进行查看邮件



六、企业级邮箱配置
    见文档
	
	









09.05      数据库
一、数据库
常见数据库
    ORACLE SQLserver DB2（IBM开发的） redis  Mysql
	达梦数据库
	
二、数据库管理数据存在的问题
                        nginx七层负载的好处:可以识别URL
    数据冗余性和不一致性    冗余:文件在负载的子服务器上重复存储   不一致:当修改一个文件内容时（其他服务器中同样的文件内容不会发送改变）
    数据访问困难            不同类型的文件需要不同的库去解析
    数据相对独立            文件之间相对分散，文件之间没有对应关系
    完整性和原子性          数据整体完整性                             原子性：保持两条记录都正确执行，如果有一条不正确执行，就返回，都不执行   
    并发访问异常
    安全性问题              权限的限制性弱
	
三、数据库概念        
                          元数据
    数据库：指的是以一定的方式存在一起、能为多个用户共享、具有尽可能小的冗余度的特点、是与应用程序彼此独立的数据集合
    功能：
    实现数据共享
    减少数据的冗余度
    数据实现集中控制
    数据的一致性	
    故障恢复
	
四、数据库类型
    DBMS（Database Management System）：数据库管理系统
	
    层次模型：按照层次结构的形式组织数据库数据的模型
	缺点：拥有大量的冗余数据  （IMS）

    网状模型：按照网状结构的形式组织数据库数据的模型
	缺点：后期维护困难 （DBTG）

    关系模型（RDBMS：Relational Database Management System）：按照数据关系的形式组织数据库数据的模型

五、关系模型
    E-R模型(美籍华人陈平山)：
    实体（Entities）
    属性（Attributes）
    关系（Relationships）

    E-R图见课件
	
六、SQL语句
    结构化查询语言(Structured Query Language)简称SQL，结构化查询语言是一种数据库查询和程序设计语言，
	用于存取数据以及查询、更新和管理关系数据库系统；最早诞生于 IBM SYSTEM R 操作系统之上。
	
七、发展史（见课件）

八、SQL语句的操作类型
    DML：数据操作语言，操作数据库中数据的命令         select  insert update  delete
    DDL：数据库描述语言，建立数据库、定义数据关系     create   drop
    DCL：数据库控制语言，控制数据库组件的权限	      grant
	
九、关系型数据库的结构
    文件的逻辑关系
	    上层：逻辑方式保存文件
		底层：数据块的方式以二进制的形式存储在硬盘
		中间层:文件系统（EXT3：对大文件的查询有影响 EXT4:centos6  xfs:扩展性与磁盘的使用效率）
		
	数据库逻辑关系
	    上层：数据表
		底层：逻辑方式保存的文件
		中间层：存储引擎
		
	存储引擎：存储数据、建立索引以及更新和查询数据等技术的实现方法
	
十、Mysql存储引擎MyISAM        数据库最小存储单位
	MYSQL 默认存储引擎，诞生即存在，插入和查询数据较快。不支持事物、行级锁以及外键约束等功能
	锁：行级锁（InnoDB）、表级锁（MyISAM）、页级锁（DBD）锁定相邻数据
	约束：域约束、外键约束

    InnoDB
	支持事物、行级锁以及外键约束等功能，相对于 MyISAM 更快

    MEMORY
	运行在内存中、使用 hash 索引，数据存取速度非常快。但是数据不能持久化，适用于缓存

十一、MYSQL - 数据的存储和查询
    存储管理器：通过  数据描述语言（DDL）来创建表的结构，在通过 数据操作语言（DML） 来保存 SQL 语句产生的数据的数据库组件
        权限及完整性管理器
        事物管理器        解决完整性、原子性问题
        文件管理器
        缓冲区管理器      先加载到内存中（优化）
   查询管理器：接收用户的查询请求、理解查询请求、并将请求提交给存储管理器的数据库组件
        DDL 和 DML 解释器
        查询执行引擎
		
十二、MYSQL - 数据的存储和查询的结构
      （见文档）

十三、MYSQL - 数据后台工作模式
      Apache:
	        Prefork:多子进程，每个子进程只有一个线程，一个线程维持一个连接 （默认使用的工作方式）  更稳定
			
			Worker:多子进程，每个子进程会有多个线程，每个线程维持一个连接                          不稳定，但效率更高（使用率低）
	  MySQL：单进程多线程的工作模式，每个线程维持一个连接
	        守护线程：MySQL 不需要跟用户进行交互
            应用线程：MySQL 需要跟用户进行交互
			
	     补充：连接超时，三次握手之后，还未与客户端断开连接，服务器就关机，此时客户端的连接还未中断，此时的状态就是连接超时
			
十四、MYSQL - 优化方案
      垂直扩展     替换成性能（磁盘I/O）更高的服务器（不常用）
      水平扩展                                          常用      水平扩展不是无限的，负责负载的服务器的压力越来越大，会出现性能瓶颈
      缓存                                             redis、squid   老化时间
      线程重用                            一旦线程创建，如果还有用户来访问，不关闭这个线程重新创建，而是直接给这个用户使用
      ..........分区、分表、读写分离      每个服务器负责单个类型的服务，减小单个服务器的压力

	  
十五、MYSQL - 优点：开源免费、支持多种数据库引擎
      MYSQL - 缺点：（单个请求）不支持一次多线成调用
      SMP 对称多处理器结构：一次多线成调用
	  
	  
	  
	  
	  

sql语句

一、安装数据库
1 、 SQL ：结构化查询语句
          DML ：数据操作语言
          DDL ：数据描述语言
          DCL ：数据控制语言
2 、安装方式
    RPM  包： yum -y install mysql mysql-server
    源码包：编译安装
3 、基本信息
主配置文件： /etc/my.cnf
端口： 3306
数据目录： /var/lib/mysql
           ib_logfile0  ib_logfile1  实务日志
           mysql.sock 数据库套接字文件    (判断服务是否正常启动)
	/var/lib/mysql/mysql/
	.frm 数据包的格式
	.MYD 数据表中的真实数据
	.MYI 数据的索引
	
修改密码：
1 、登录
    mysql -u  用户名 -p  密码 -h  服务器地址 -P  端口 -S 套接字（/var/lib/mysql/mysql.sock判断服务是否启动）
    mysql -u root -p mima -h localhost -P 3306 -S /var/lib/mysql/mysql.sock
    创建密码 mysqladmin -uroot password 123（本地用户登录不用加-h 服务器地址 和-P 端口）
2 、创建用户
    create user ' 用户名 '@' 登录地址 ' identified by ' 密码 ';         localhost 只允许本地登录
    create user 'zhangsan'@'%' identified by '123';                     % 只允许除本地外的其他用户登录（本地也不允许登录）
                                                                    IP（只允许固定IP的主机登录_)
    grant   all    on *.* to 'lisi'@'%' identified by '123';  创建并授权 lisi 用户允许在任何地方登陆给予最大   
          最大权限   库.表                                 
3 、修改密码
管理员
mysqladmin -uroot password  密码
    set password=password("123456");
    set password for ' 用户名 '@' 登录地址 '=password(" 密码 ");
普通用户
    set password=password("123456");
管理员找回密码
   ①、关闭数据库服务
   ②、修改主配置文件，在 mysqld  区域中添加记录
       skip-grant-table
   ③、重启服务
   ④、登录 mysql  使用命令修改密码
       update mysql.user set password=password("123") where user='root';
       vim /etc/my.cf  删除skip-grant-table（防止别的用户修改密码）
  
  
三、 SQL 语句
1 、增
    create database xx;                                  创建新数据库
    create table 表名 (x1 int(3));                       创建表
    insert into 表名 （ x1 ） values ('1');              向表中插入数据
    insert into a1 (id, name) values (2, 'lisi');     insert into a1 values (2, 'lisi');  （插入默认字段的数据，字段名可省略）
    insert into a1 (id, name) values (3, 'zhangsan'),(4, 'wanger');  插入多个数据
    insert into a1 (id) values (2);                                  插入单个数据

    create table 表名 （
    id int unsigned not null auto_increment,             第一个字段为id，不允许是字符，不为空，自增长
    name char(40) not null default ' 未知 ' ，           第二个字段为name，字符型（长度40），不为空，默认参数，
    age int not null default '0',                        第三个字段为age ，整形，不为空，默认值 0，
    primary key (id));                                   组键（相当于唯一标示符、与其他表建立联系);

    insert into  表 1 ( x1 ) select x1 from  表 2; 将表 2 中的 x1  字段信息插入到表 1 中去

2 、删
    drop database 库名 ;              删除数据库
    drop table 表名 ;                 删除表
    delete from 表 where 字段=数值 ;  删除表中字段等于数值的记录

3 、改
    update 表名 set 字段1= 数值1 where  字段2= 数值2;          更新表字段2等于数值2的所有字段1的数值为数值1
        eg:  update a2 set age=80 where id=1;
    update 表名 set 字段1= 数值1 where 字段2 between 1 and 5;  更新表字段2在1到5之间的所有字段1的数值为数值1
        eg:  update a2 set age=80 where id between 1 and 4;
    alter table 表1名 rename 表2名 ;  将表1名称修改为表2

    alter table xinxi modify age int(20);                                  将 xinxi 表 age 字段参数修改为 int(20)

    alter table xinxi change name username char(40) not null default ' ';  将 xinxi 表字段名 name 修改为username

    alter table xinxi add date year;                                       将 xinxi 表中添加一个字段

    alter table xinxi drop date;                                           删除 xinxi 表中的 date 字段

    alter table xinxi add date year first;                                 将 xinxi 表中添加到第一个字段

    alter table xinxi add date year after age;                             将 xinxi 表中添加一个 data 字段添加到 age 之后

4 、查
    show databases;     查看数据库
    show tables;        查看数据库中的表
    describe 表名 ;     查看表结构
    select */字段1,字段2   from   表名  where  字段="值"；  查看表中的数据
eg：select user,password from user where user='root';
 
5 、授权
    grant all on *.* to 'zhangsan'@'%';                  授权一个已存在的 zhangsan 用户允许在任何地方登陆并给予最大权限
	
    grant all on *.* to 'lisi'@'%' identified by '123';  创建并授权 lisi 用户允许在任何地方登陆给予最大,权限并设置密码为 123
          (权限类型)create 、 delete 、 drop 、 select 、 all 、 grant 、 slave
		   
    show grants for 'zhangsan'@'%';                      查看 zhangsan 用户在远程登陆的权限
	
    revoke create on test.* from 'zhangsan'@'%';         取消 zhangsan 在远程创建使用 test 库的权限

四、数据库备份
1 、冷备份：离线执行，必须终止读写执行操作
    cp scp rsync
	
2 、软件备份
    LV lvsnap 逻辑快照
    Navicat
	
3 、逻辑备份
① mysqldump
   mysqldump ：通过 sql  语句的批量操作进行数据库的导入导出
     
   mysqldump 数据库名 > 备份文件名                          备份数据库
       mysqldump aa -uroot -p > aa.sql
   mysql  数据库名 < 备份文件                               还原数据库到 test (还原之前要创建aa)
       mysql -uroot -p aa < aa.sql                         
	   
   mysqldump 数据库名 表 1 > 备份文件名                     备份数据库并且之备份表 1
       mysqldump aa dgt -uroot -p > dgt.sql                 还原:   mysql -uroot -p aa < dgt.sql
	   
   mysqldump --databases 数据库1  数据库2 > 备份文件        将数据库1 与数据库2 同时备份到备份文件
       mysqldump --databases aa xdl -uroot -p  > data.sql   还原：  mysql -uroot -p < data.sql
	   
   mysqldump --all-databases > 备份文件                     将所有的数据库进行备份
       mysqldump --all-databases > data2.sql                还原：  mysql -uroot -p < data2.sql
	   
	   
② mysqlhotcopy
   mysqlhotcopy --flushlog -u='root' -p='123' --regexp=^a /root 通过正则表达式匹配 a 开头数据库进行备
份(库中必须有表才能执行)

③ mysqldump  与 mysqlhotcopy  区别
   前者是一个 sql  语句的集合，后者是快速文件意义上的备份
   前者可以使用 MyISAM  和 InnoDB  引擎，后者只适用 MyISAM
   前者可以远程操作，后者只支持本地操作

4 、日志备份
①类型
   错误日志                /var/log/mysqld.log
   查询日志（记录查询记录）/var/run/mysqld/mysqld.log
   慢查询日志              /var/run/mysqld/slow.log
   二进制日志              /var/lib/mysql/mysql-bin.000001           mysql-bin.index索引文件
   事物日志
   中继日志
       show global variables like '%log%';  查询系统开启的日志信息
	   
②一般查询日志             /var/lib/mysql/ON
    开启一般查询日志
    修改主配置文件/etc/my.cnf添加
	symbolic-links=0(在这行之后添加)
    general_log=ON
    log=ON
   
③慢查询日志          （用户向数据库提交查询请求，如果在规定的时间内，数据库没有返回请求，就会被记录到慢查询日志中）
   开启慢查询日志
   修改主配置文件/etc/my.cnf添加
   log-slow-queries=/var/run/mysqld/slow.log
        show global variables like '%long%';  查询慢查询时间
   修改慢查询时间
   修改主配置文件添加
   long_query_time=4

④二进制日志：记录所有更改数据库状态的操作
   修改主配置文件/etc/my.cnf添加
   log-bin=mysql-bin
   show binary logs;  查看当前正在使用的二进制日志文件名
   show binlog events in 'mysql-bin.000001';
   mysqlbinlog mysql-bin.000001 通过工具查看 mysql  二进制日志
   
   binlog 数据恢复（恢复的是命令）
   
时间（mysqlbinlog mysql-bin.000001    首先查询二进制日志   查看更改数据库状态的操作的时间点）
  mysqlbinlog --start-datetime '2017-05-17 20:06:00' --stop-datetime '2017-05-17 20:01:54' mysql-
  bin.000001 | mysql -uroot -p
大小
  mysqlbinlog --start-position 106 --stop-position 185 mysql-bin.000001 | mysql -uroot -p
  
  
  
  
  
数据库集群
一、 主从 -  服务器
从服务器主动同步主服务器的修改
1 、安装服务 -  开启服务
    yum -y install mysql mysql-server
    service mysqld start
	
2 、修改配置文件： /etc/my.cnf （主、从都需添加）
    log-bin=mysql-bin 开起二进制日志文件
    server-id=xx 申明本台 mysql 服务器 ID
	mysql_install_db    初始化数据库
    service mysql restart 修改了配置文件，重新启动
	
3 、进入数据库（主服务器）
    grant replication slave on *.* to ' 用户 '@'%' identified by ' 密码 '; 创建从服务器用户
	      grant all on *.* to '63'@'%' identified by '123';
    show master status; 查看二进制文件名，以及大小
	
4 、进入数据库（从服务器）
change master to master_host=' 主服务器 IP',master_user=' 用户 ',master_password=' 密码 ',master_log_file=' 二进制文
件 ',master_log_pos= 文件空间大小 ; 确定从主服务器同步
     change master to master_host='192.168.19.63',master_user='63',master_password='123',master_log_file='mysql-bin.000005',
	 master_log_pos=229;

     show slave status\G; 查看同步服务开启状态
     start slave; 如果同步状态没有启动，则开启

二、主主从 - 服务器备份
多个主服务器备份到一台从服务器（两台主服务器一台从服务器） mysqld-mulit 在一台服务器上启动多个 mysq 进程

1.从服务器65
     vi /etc/my.cnf ( 底部添加）
     [mysqld_multi]
     mysqld=/usr/bin/mysqld_safe
     mysqladmin=/usr/bin/mysqladmin
     log=/tmp/multi.log
2.主 1 服务器
     vi /etc/my.cnf ( 添加）
     log-bin=mysql-bin
     server-id=63           （id 号）
     service mysqld start
3.主 2 服务器
     vi /etc/mysql.cnf ( 添加）
     log-bin=mysql-bin
     server-id=64            （id 号）
     service mysqld start
4.主 1 服务器
     mysqladmin -uroot password 123
	 mysql -uroot -p
     msyql 登入数据库
     grant replication slave on *.* to ' zhangsan'@'%' identified by ' 密码 ';  创建从服务器用户
     show master status ； 查看二进制文件名，以及大小
5.主 2 服务器
     mysqladmin -uroot password 123
	 mysql -uroot -p
     msyql 登入数据库
     grant replication slave on *.* to 'lisi'@'%' identified by ' 密码 ';  创建从服务器用户
     show master status ； 查看二进制文件名，以及大小
6.从服务器
     vi /etc/my.cnf ( 底部添加）
    [mysqld651]                                                   名字随便，一般 mysql+ip
    port=3306
    pid-file=/var/lib/mysqla/mysqld.pid
    atadir=/var/lib/mysqla
    socket=/var/lib/mysqla/mysql.sock
    server-id=651                                不能和主服务器id一样      服务器 id 主 1 服务器设置的 id ，一般为 ip（）
    user=mysql
    [mysqld652]                                                   名字随便，一般 mysql+ip
    port=3307
    pid-file=/var/lib/mysqlb/mysqld.pid
    datadir=/var/lib/mysqlb
    socket=/var/lib/mysqlb/mysql.sock            不能和主服务器id一样
    server-id=652                                                           服务器 id 主 2 服务器设置的 id ，一般为 ip
    user=mysql
mysql_install_db --datadir=/var/lib/mysqla --user=mysql  初始化 mysqla 数据库
mysql_install_db --datadir=/var/lib/mysqlb --user=mysql  初始化 mysqlb 数据库
cd /var/lib
chown -R mysql /var/lib/mysqla/  修改文件权限
chown -R mysql /var/lib/mysqlb/  修改文件权限                
mysqld_multi --defaults-file=/etc/my.cnf start  651                         主 1id 号，开起数据库 01 ，为主 1 备份
netstat -anpt 查看饰扣开启了 3306 端口如果开启则说明开启成功
mysqld_multi --defaults-file=/etc/my.cnf start  652                         主 2id 号，开起数据库 02 ，为主 2 备份
netstat -anpt 查看饰扣开启了 3307 端口如果开启则说明开启成功
         mysqladmin -uroot password 123 -S /var/lib/mysqla/mysql.sock         设置密码
         mysql -uroot -p -P 3306 -S /var/lib/mysqla/mysql.sock                登录数据库 01
		 
		 mysqladmin -uroot password 123 -S /var/lib/mysqlb/mysql.sock         设置密码
         mysql -uroot -p -P 3307 -S /var/lib/mysqlb/mysql.sock                登录数据库 02
		 
mysql -P 3306 -S /var/lib/mysqlb/mysql.sock  登录数据库 01	 
change master to master_host=' 主服务器 IP',master_user='zhangsan',master_password=' 密码 ',master_log_file=' 二进制文件 ',master_log_pos= 文件空间大小； 确定从主服务器同步
show slave status\G; 查看同步服务开启状态
start slave; 如果同步状态没有启动，则开启
exit  离开数据库

mysql -P 3307 -S /var/lib/mysqlb/mysql.sock  登录数据库 02
change master to master_host=' 主服务器 IP',master_user='lisi',master_password=' 密码 ',master_log_file=' 二进制文件 ',master_log_pos= 文件空间大小； 确定从主服务器同步
show slave status\G; 查看同步服务开启状态
start slave; 如果同步状态没有启动，则开启
exit  离开数据库


注意主从数据库之间的 ID 一定不能相同


三、主主 - 服务器
两个服务器之间互为主从，互相同步
1 、安装服务 - 开启服务
    yum -y install mysql mysql-server
    service mysqld start
2 、保持 mysql  版本和数据的一致性： 由主 1 服务器拷贝到主 2 服务器
主 1 服务器：（192.168.19.64）
flush tables with read lock;  锁定数据库的写入操作，为只读
mysqldump -u root -p --all-databases > 1.sql  备份主 1 数据库，还原到主 2 ，保持两台服务器的一致性
scp 1.sql root@ 主 2 服务器地址：保存位置 主 2 服务器还原，确保 mysql 数据一致性
unlock tables ； 取消锁定
主 2 服务器：
mysql -uroot -p < 备份文件


3 、
a.修改配置文件： /etc/my.cnf       (主）
    log-bin=mysql-bin  开启二进制日志文件
    server-id=xx 服务器 ID
                                                                    replicate-do-db=test  需要同步的数据库
                                                                    binlog-ignore-db=mysql 不需要同步的数据库
                                                                    binlog-ignore-db=information_schema  不需要同步的数据库
                                                                    auto-increment-increment=2  为了保证含有自增长的不会冲突
                                                                    auto-increment-offset=1 为了保证含有自增长的不会冲突
    service mysqld restart  修改了配置文件，重新启动
	
b.修改配置文件： /etc/my.cnf       (从）
    log-bin=mysql-bin  开启二进制日志文件
    server-id=xx 服务器 ID
                                                                    replicate-do-db=test  需要同步的数据库
                                                                    binlog-ignore-db=mysql 不需要同步的数据库
                                                                    binlog-ignore-db=information_schema  不需要同步的数据库
                                                                    auto-increment-increment=2  为了保证含有自增长的不会冲突
                                                                    auto-increment-offset=1 为了保证含有自增长的不会冲突
    service mysqld restart  修改了配置文件，重新启动
	
4 、进入数据库（主服务器）
    grant replication slave on *.* to '用户'@'%' identified by ' 密码 ';             创建从服务器用户
    show master status ； 查看二进制文件名，以及大小
	
5 、进入数据库（从服务器）
    change master to master_host=' 主服务器 IP',master_user=' 用户 ',master_password=' 密码 ',master_log_file=' 二进制文
件 ',master_log_pos= 文件空间大小； 确定从主服务器同步
show slave status\G; 查看同步服务开启状态
start slave; 如果同步状态没有启动，则开启

6 、进入数据库（从服务器）
    grant replication slave on *.* to ' 用户 '@'%' identified by ' 密码 ';  创建从服务器用户
    show master status ； 查看二进制文件名，以及大小
7 、进入数据库（主服务器）
    change master to master_host=' 主服务器 IP',master_user=' 用户 ',master_password=' 密码 ',master_log_file=' 二进制文
    件 ',master_log_pos= 文件空间大小； 确定从主服务器同步
    show slave status\G; 查看同步服务开启状态
    start slave; 如果同步状态没有启动，则开启
	
	测试（创建库的时候不能为数字）


四、 mysql  读写分离
主 —  从 — amoeba
1 、安装 amoeba（192.168.19.63）

   yum -y install gcc*
   mkdir /amoeba
   tar -zxf jdk-7u40-linux-x64.gz -C /amoeba/
   vim /etc/profile （添加）
   JAVA_HOME=/amoeba/jdk
   export JAVA_HOME
   PATH=$JAVA_HOME/bin:$PATH
   export PATH
   CLASSPATH=.:$JAVA_HOME/lib/tools.jar:$JAVA_HOME/lib/dt.jar:$CLASSPATH
   export CLASSPATH
   cd /amoeba/
   
ln -s jdk1.7.0_40/ jdk
. /etc/profile 刷新全局变量     java -version
echo $PATH 查看是否添加成功


2 、建立两台数据库的主从关系
安装服务 - 开启服务（主、从 =mysql mysql-server ， amoceba=mysql ）
yum -y install mysql mysql-server
service mysqld start

修改配置文件： /etc/my.cnf （主、从都需添加）
log-bin=mysql-bin  开起二进制日志文件
server-id=xx  申明本台 mysql 服务器 ID

service mysqld restart  修改了配置文件，重新启动

进入数据库（主服务器）
grant all privileges on *.* to 'zhangsan'@'%' identified by '123'; 
创建从服务器认证用户
为amoeba用户授权
grant all on *.* to 'amoeba'@'%' identified by '123'
show master status ； 查看二进制文件名，以及大小

进入数据库（从服务器）
change master to master_host=' 主服务器 IP',master_user=' 用户 ',master_password=' 密码 ',master_log_file=' 二进制文
件 ',master_log_pos= 文件空间大小； 确定从主服务器同步
show slave status\G; 查看同步服务开启状态
start slave; 如果同步状态没有启动，则开启
grant all on *.* to 'amoeba1'@'%' identified by '123'
为amoeba用户授权



三、配置 amoeba  服务器
进入 amoeba 服务器
   


unzip amoeba-mysql-1.3.1-BETA.zip -d /usr/local/amoeba
chmod -R a+x /usr/local/amoeba/bin/
cd /usr/local/amoeba/conf/
vim amoeba.xml



<!DOCTYPE amoeba:configuration SYSTEM "amoeba.dtd">
<amoeba:configuration xmlns:amoeba="http://amoeba.meidusa.com/">
<server>
  <!-- proxy server°ó¶¨µÄ¶Ë¿Ú -->
  <property name="port">9000</property>                                        设置运行端口
  <!-- proxy server°ó¶¨µÄIP -->
  <property name="ipAddress">192.168.19.63</property>                          设置 amoeba 服务器 IP 地址
  <!-- proxy server net IO Read thread size -->
  <property name="readThreadPoolSize">20</property>
  <!-- proxy server client process thread size -->
  <property name="clientSideThreadPoolSize">30</property>
....................
....................
-->
<property name="tcpNoDelay">true</property>
<!-- ¶ÔÍâÑéÖ¤µÄÓÃ»§Ãû -->
<property name="user">root</property> 设置连接 amoeba 服务器用户名密码
<!-- ¶ÔÍâÑéÖ¤µÄÃÜÂë -->
<property name="password">123</property>                                     设置登录密码
<!-- query timeout( default: 60 second , TimeUnit:second) -->
<property name="queryTimeout">60</property>
....................
....................




</dbServerList>


<dbServer name="server1">                                                    服务器 1 名称

   <!-- PoolableObjectFactoryÊµÏÖÀà -->
   <factoryConfig class="com.meidusa.amoeba.mysql.net.Mysql ServerConnectionFactory">
     <property name="manager">defaultManager</propert y>

       <!-- ÕæÊµmysqlÊý¾Ý¿â¶Ë¿Ú -->
       <property name="port">3306</property> 运行端口

      <!-- ÕæÊµmysqlÊý¾Ý¿âIP -->
      <property name="ipAddress">192.168.19.64</proper ty>                      主服务器 IP 地址
      <property name="schema">xdl</property>                                   同步的数据库
	    
      <property name="user">amoeba</property>                                      允许amoeba登录的账号
      <!-- ÓÃÓÚµÇÂ½mysqlµÄÓÃ»§Ãû -->                         


      <!-- ÓÃÓÚµÇÂ½mysqlµÄÃÜÂë -->
      <property name="password">123</property>                                     主服务器授权密码

</factoryConfig>

                        <!-- ObjectPoolÊµÏÖÀà -->
                        <poolConfig class="com.meidusa.amoeba.net.poolable.PoolableObjectPool">
                                <property name="maxActive">200</property>
                                <property name="maxIdle">200</property>
                                <property name="minIdle">10</property>
                                <property name="minEvictableIdleTimeMillis">600000</property>
                                <property name="timeBetweenEvictionRunsMillis">600000</property>
                                <property name="testOnBorrow">true</property>
                                <property name="testWhileIdle">true</property>
                        </poolConfig>
                     </dbServer>
       

将以上区域复制一份并修改其中的重要参数，端口号都是一样的，只是连接使用 65 行


                <dbServer name="server2">

                        <!-- PoolableObjectFactoryÊµÏÖÀà -->
                        <factoryConfig class="com.meidusa.amoeba.mysql.net.MysqlServerConnectionFactory">
                                <property name="manager">defaultManager</property>

                                <!-- ÕæÊµmysqlÊý¾Ý¿â¶Ë¿Ú -->
                                <property name="port">3306</property>

                                <!-- ÕæÊµmysqlÊý¾Ý¿âIP -->
                                <property name="ipAddress">192.168.19.65</property>
                                <property name="schema">xdl</property>

                                <!-- ÓÃÓÚµÇÂ½mysqlµÄÓÃ»§Ãû -->
                                <property name="user">amoeba1</property>

                                <!-- ÓÃÓÚµÇÂ½mysqlµÄÃÜÂë -->


                                <property name="password">123</property>


                        </factoryConfig>

                        <!-- ObjectPoolÊµÏÖÀà -->
                        <poolConfig class="com.meidusa.amoeba.net.poolable.PoolableObjectPool">
                                <property name="maxActive">200</property>
                                <property name="maxIdle">200</property>
                                <property name="minIdle">10</property>
                                <property name="minEvictableIdleTimeMillis">600000</property>
                                <property name="timeBetweenEvictionRunsMillis">600000</property>
                                <property name="testOnBorrow">true</property>
                                <property name="testWhileIdle">true</property>
                        </poolConfig>
                     </dbServer>
					 
					 
					 
					 
					 
					 
					 
					 
<dbServer name="master" virtual="true">
                        <poolConfig class="com.meidusa.amoeba.server.MultipleServerPool">
                                <!-- ¸ºÔØ¾ùºâ²ÎÊý 1=ROUNDROBIN , 2=WEIGHTBASED , 3=HA-->
                                <property name="loadbalance">1</property>

                                <!-- ²ÎÓë¸Ãpool¸ºÔØ¾ùºâµÄpoolNameÁÐ±íÒÔ¶ººÅ·Ö¸î -->
                                <property name="poolNames">server1</property>
                        </poolConfig>
                </dbServer>


                <dbServer name="slave" virtual="true">
                        <poolConfig class="com.meidusa.amoeba.server.MultipleServerPool">
                                <!-- ¸ºÔØ¾ùºâ²ÎÊý 1=ROUNDROBIN , 2=WEIGHTBASED , 3=HA-->
                                <property name="loadbalance">1</property>

                                <!-- ²ÎÓë¸Ãpool¸ºÔØ¾ùºâµÄpoolNameÁÐ±íÒÔ¶ººÅ·Ö¸î -->
                                <property name="poolNames">server1,server2,server2,server2</property>    负载
                        </poolConfig>
                </dbServer>

	</dbServerList>

				
				
				
				
					 

<queryRouter class="com.meidusa.amoeba.mysql.parser.MysqlQueryRouter">
<property name="ruleConfig">${amoeba.home}/conf/rule.xml</property>
<property name="functionConfig">${amoeba.home}/conf/functionMap.xml</property>
<property name="ruleFunctionConfig">${amoeba.home}/conf/ruleFunctionMap.xml</property>
<property name="LRUMapSize">1500</property>
<property name="defaultPool">master</property>                                            默认池
<property name="writePool">master</property>                                              写池
<property name="readPool">slave</property>                                                读池
<property name="needParse">true</property>
</queryRouter>vi




cd /usr/local/amoeba/bin/
vim amoeba
#DEFAULT_OPTS="-server -Xms256m -Xmx256m -Xss128k"
DEFAULT_OPTS="-server -Xms256m -Xmx256m -Xss256k"
nohup bash -x /usr/local/amoeba/bin/amoeba & 启动命令
ps aux | grep amoeba 如下图则正确


mysql -u root -p -h 192.168.19.63 -P 8066














































非关系型数据库

一、关系型数据库的优缺点
    优点：
	     保持数据的一致性和原子性
		 数据的更新的开销很小
		 可以进行JOIN等发杂处理
		 存在较多成熟案例和模板信息
	     
    缺点：
        大量的数据写入
        表结构的变更
        查询速度

二、
1）NOSQL
         NOSQL：NOT ONLY SQL	弥补关系型数据库的不足
		 
	优点：
        易于数据分散，数据间相对独立，没有关联
        提升性能和扩展，是水平扩展的解决方案
        速度较快，绝大多数数据存储在内存之中
2）	NOSQL种类
         面向键值的数据库:处理数据较快
		         临时性：通过内存保存数据（memcache）
				 永久性：通过硬盘保存数据（flar、rona）
				 临时+永久：通过内存保存数据，当满足条件时再将数据写入硬盘（redis）
				 
		 面向文档的数据库：不定义表结构、支持复杂的查询条件（mangodb）


         面向列的数据库：cassandra、hbase
         面向行的数据库，对少量行进行读取和更新时速度较快
         面向列的数据库，对大量行进行读取时，速度较快，对所有行的特定列进行同时更新时速度较快

三、Redis
    中文支持网站：www.redis.cn
    基于缓存，速度快，支持多种数据结构
    消耗内存相对较少，支持数万的QPS
    支持持久化存储
	
	Redis 实验步骤
一、安装部署 Redis 数据库
1、安装 Redis 数据的依赖软件 tcl
2、解压并进行编译安装
   make
   make test
   make PREFIX=/usr/local/redis install
   cd /usr/local/redis
   cp /root/redis-3.0.3/redis.conf .
   vi redis.conf
   # By default Redis does not run as a daemon. Use 'yes' if you need it.
   # Note that Redis will write a pid file in /var/run/redis.pid when daemonized.
   daemonize yes
3、开启以及链接测试
   cd /usr/local/redis 进入 redis 安装目录
   ./bin/redis-server ./redis.conf 开启 redis 服务
   ./bin/redis-cli -h localhost -p 6379 连接 Redis 数据库
   
二、基本命令
1、数据类型
   string 字符串类型
   hash 散列类型
   list 链表类型
   set 集合类型
   zset 有序集合类型
   
2、字符串类型： string 一个字符串，对应一个数据
   keys * 查看所有键值
   set 名称 键值 创建键值
   get 名称 查看键值
   setnx 名称 键值 创建键值（防覆盖，有则不创建，无则创建）
   setex 名称 消失时间 键值 创建键值（给键值赋予有效期 , 到期后消失）
   ttl 名称 查看键的生命周期
   -1 永久生效
   -2 目标键不存在
   mset 名称 键值 名称 2 键值 2 ....... 创建键值（一次创建多个）
   mget 名称 名称 2 名称 3 ........ 查看键值（一次性查看多个）
   msetnx 名称 1 键值 1 名称 2 键值 2 ...... 创建键值（一次性创建多个，防止键的覆盖）
setrange 名称 修改位置 修改值 替换键值
getset 名称 修改键值 查看原有键值并修改新值
getrange 名称 起始位置 终止位置 查看一个键值的部分，从起始位置到终止位置的键值   0 -1 :所有
   localhost:6379> set s1 feioronvurilkdjio
   OK
   localhost:6379> setrange s1 3 xldlxldlfl   （这里的3是第四个字母的意思，在这也就是o）
   (integer) 17
   localhost:6379> get s1
   "feixldlxldlfldjio"

   incr 名称 给键值每次 +1
   incrby 名称 增长值 给键值以增长值每次进行增长
   decr 名称 给键值每次 -1
   decreby 名称 减少值 给键值以减少至每次进行减少
   strlen 名称 统计键值长度
   append 名称 增加的字符 给键值后面增加字符
   del 名称 删除键
   
   
3、哈希类型：hash 一个字符，有多个字段。每个字段拥有独立的键值
   hset 名称 字段 键值 创建指定字段的值
   hmset 名称 字段1 键值1 字段2 键值2 .... 设置哈希类型一次性创建多个字段及键值
   hget 名称 字段 查看指定字段的值
   hsetnx 名称 字段 键值 创建指定字段的值（防覆盖）
   hmget 名称 字段 1 字段 2 字段 3 .... 一次查看键中多个字段的值
   hlen 名称 查看一个键中有几个字段
   hvals 名称 查看一个键中所有字段的值
   hgetall 名称 查看指定键中的字段和值
   hdel 名称 字段 删除指定键中的指定字段
   hkeys 名称 查看之间键中有哪些字段
   hincrby 名称 字段 增长值 增加指定字段的值
   
   
4、双向队列：list 将多个字符排序起来
   右序号顺序以数字1、2、3、4..... 从右到左序号顺序以数字-1、-2、-3......
   lpush 名称 1 数值 1 创建队列并写入数值 1 ，默认从左往右插入
   rpush 名称 2 数值 1 数值 2 数值 3 创建队列并写入多个数值，默认从左往右插入
   lrange 名称 数值的下标 1 数值的下标 2 查看键下标 1 到下标 2 的值
   linsert 名称 before/after 数值 新值 在数值下标的 之前 / 之后 插入新值
   lset 名称 数值的下标 新值 将键的固定数值下标之后的原有值改为新值
   lrem 名称 -+/1234 已有数值 删除键中多个重复的元素
   ltrim 名称 0 1 删除表中除了第一个和第二个所有的元素（保留）
   lpop 名称 删除左边第一个值
   rpop 名称 删除右边第一个值
   rpoplpush 名称 1 名称 2 将制定队列 1 中的最后一个元素，移动到新队列 2 中
   llen 名称 查看队列长度
   lindex 名称 队列序号 查看指定序号的内容
4、集合：set 交集、并集、补即
   sadd 名称 值 添加集合
   smembers 名称 查看集合中所有元素
   srandmember 名称 随机调取一个数据
   spop 名称 随机删除一个数据
   srem 名称 值 删除指定集合中指定序号的值
   scard 名称 查看集合中有几个元素
   sismember 名称 数值 查看数值是否在这个集合之中
   sdiff 集合 1 集合 2 查看两个集合的差集只看集合 1 的差集
   sdiffstore 集合 3 集合 1 集合 2 将两个集合的差集保存到集合 3 之中
   sinter 集合 1 集合 2 查看两个集合的交集
   sinterstore 集合 3 集合 1 集合 2 将两个集合的交集并保存到集合 3
   sunion 集合 1 集合 2 查看两个集合的并集
   sunionstore 集合 3 集合 1 集合 2 将两个集合的并集保存到集合 3
   smove 集合 1 集合 2 值 1 将集合 1 中的值到集合 2
5 、 zset 有序集合 相当于集合每个元素之后增加一个数字（必须为数字）相当于分数
   zadd 名称 数值 （必须是数字） 元素 1 ........ 创建有序集合
   zrange 名称 下标 1 下标 2 查看集合下标 1 到下标 2 的元素 zrange 名称 0 -1 相当于查看所有
   zrange 名称 下标 1 下标 2 withscores 查看集合下标 1 到下标 2 的元素。以及分值，从小到大排列
   zrevrange 名称 下标 1 下标 2 withscores 查看集合下标 1 到下标 2 的元素。以及分值，从大到小排列
   zrangebyscore 名称 数字 1 数字 2 withscores 查看从数字 1 到数字 2 范围的值
   zrem 名称 元素 删除有序集合指定的值
   zincrby 名称 数字 元素 每次以数字增加大小，如果没有这个集合，则创建
   zrank 名称 元素 按照元素的数值从小到大的顺序排列取值的下标
   zrevrank 名称 元素 按照元素的数值从大到小的顺序排列取值得下标
   zcard 名称 统计集合的元素个数
   zcount 名称 数字 1 数字 2 统计数字 1 到数字 2 之间的元素个数，两数之间的个数
   zremrangebyrank 名称 下标 1 下标 2 删除从下标 1 到下标 2 的元素
   zremrangbyscore 名称 数字 1 数字 2 删除从数字 1 到数字 2 之间的元素
   zinterstore 名称 3 集合数 名称 1 名称 2 取名称 1 和名称 2 的交集保存在名称 3 之中，取出集合之后分数叠加
   zunionstore 名称 3 集合数 名称 1 名称 2 取名称 1 和名称 2 的并集保存在名称 3 之中，取出集合之后分数叠加
   
   
6 、全局命令
   dbsize 统计键的数量
   exists 键名称 查看键是否存在
   expire 键名称 时效时间 将键变为定时失效
   rename 键名称 键新名称 将键改名
   type 键名称 查看键是什么类型的键
   info 查看数据库的版本信息
   select 数字 切换数据库（ 0-15 ）
   move 键名称 1 数据库号 将当前键移动到别的数据库
   flushdb 清空当前数据库
   flushall 清空所有数据库
   
   
三、设置密码
   cd /usr/local/redis
   vi redis.conf
   requirepass 123456
   pkill redis 关闭 redis
   ./bin/redis-server ./redis.conf 启动 redis  ，关闭后开启相当于重启
   ./bin/redis-cli
   auth 12345 输入密码 或 ./bin/redis-cli -a 12345


四、数据备份
   vi /usr/local/redis/redis.conf 修改备份文件保存位置，默认在登录目录保存，文件为 dunp.rdb
   dir /usr/local/redis
   /usr/local/redis/bin/redis-cli -a 12345
   save 保存，默认保存在当前目录下，可修改文件设置
   exit 退出数据库
   pkill redis 关闭 redis
   /usr/local/redis/bin/redis-cli -a 12345 登录 redis


五、主从同步
rpm -ivh tcl-8.5.7-6.el6.x86_64.rpm
tar -zxf redis-3.0.3.tar.gz
cd redis
make
make test
make PREFIX=/usr/local/redis install
cd /usr/local/redis
cp /root/redis-3.0.3/redis.conf .
vi redis.conf
# By default Redis does not run as a daemon. Use 'yes' if you need it.
# Note that Redis will write a pid file in /var/run/redis.pid when daemonized.
daemonize yes
cd /usr/local/redis 进入 redis 安装目录
./bin/redis-server ./redis.conf 开启 redis 服务

./bin/redis-cli -h localhost -p 6379 连接 Redis 数据库
cd /usr/local/redis/
cd ..
cp -r redis/ redis-slave/
vim redis-slave/redis.conf
pidfile=/usr/local/redis-slave/redis.pid
port ： 6380
dir /usr/local/redis-slave
slaveof 127.0.0.1 6379 主服务器 IP 主服务器端口号
masterauth 123456 主服务器密码
分别启动主从服务器 启动从服务器的时候用 -p  指定端口号
/usr/local/redis-slave/bin/redis-cli -p 6380 

六、Redis + Mysql

moun -o loop mr.iso /iso
yum -y install gcc*
eject
yum -y install *


1.配置基本网站
vim /etc/nginx/conf.d/default.conf
server {
listen 80;
server_name www.xdl.com;
location / {
root /www/;
index index.php index.html index.htm;
}
location ~ \.php$ {
root /www/;
fastcgi_pass 127.0.0.1:9000;
fastcgi_index index.php;
fastcgi_param SCRIPT_FILENAME /www/$fastcgi_script_name;
include fastcgi_params;
}
}
修改 FPM 配置：
sed -i 's/apache/nginx/g' /etc/php-fpm.d/www.conf
开启服务
service php-fpm start
service mysqld start
mkdir /www
chown -R nginx:nginx /www/
service nginx start
授权
mysqladmin -uroot password ‘123’
测试
vim /www/index.php
<?php
phpinfo();
?>


2.安装 redis
rpm -ivh tcl-8.5.7-6.el6.x86_64.rpm
tar -zxf redis-3.0.3.tar.gz
cd redis
make
make test
make PREFIX=/usr/local/redis install
cd /usr/local/redis
cp /root/redis-3.0.3/redis.conf .
vi redis.conf
# By default Redis does not run as a daemon. Use 'yes' if you need it.
# Note that Redis will write a pid file in /var/run/redis.pid when daemonized.
daemonize yes
cd /usr/local/redis 进入 redis 安装目录
./bin/redis-server ./redis.conf 开启 redis 服务
./bin/redis-cli -h localhost -p 6379 连接 Redis 数据库


3.安装 php 扩展   moun -o loop mr.iso /iso
unzip phpredis-master.zip
cd phpredis-master
phpize 检测模块
./configure --with-php-config=/usr/bin/php-config
make && make install
vim /etc/php.ini 末尾加
extension=redis.so
/etc/init.d/php-fpm restart  或 service php-fpm restart
mysql -u root -p123456
create database mytest;
use mytest;
use mytest;
CREATE TABLE test (id int NOT NULL AUTO_INCREMENT, name char(8) DEFAULT NULL, PRIMARY KEY (id)) ENGINE=InnoDB
AUTO_INCREMENT=10 DEFAULT CHARSET=utf8;
mysql> INSERT INTO test VALUES (1,'a1'),(2,'a2'),(3,'a3'),(4,'a4'),(5,'a5');
mysql> select * from mytest.test;


vim /www/1.php
<?php
$redis = new Redis();
$redis->connect('127.0.0.1',6379) or die ("could net connect redis server");
$query = "select * from test limit 4";
for ($key = 1; $key < 4; $key++)
{
if (!$redis->get($key))
{
$connect = mysql_connect('127.0.0.1','root','123');
mysql_select_db(mytest);
$result = mysql_query($query);
while ($row = mysql_fetch_assoc($result))
{
$redis->set($row['id'],$row['name']);
}
$myserver = 'mysql';
break;
}
else
{
$myserver = "redis";
$data[$key] = $redis->get($key);
}
}
echo $myserver;
echo "<br>";
for ($key = 1; $key < 4; $key++)
{
echo "number is <b><font color=#FF0000>$key</font></b>";
echo "<br>";
echo "name is <b><font color=#FF0000>$data[$key]</font></b>";
echo "<br>";
}
?>





















集群
集群的使用背景：随着访问压力的增加，单个服务器已经不能满足访问需求，这时候就需要对服务器进行性能扩展，搭建集群。
性能扩展的方法：
	垂直扩展：
		     性价比低
		     业务的持续访问（单台服务器在切换的时候会导致业务中断）
		     有瓶颈（单台服务器性能有限的）
	水平扩展:
		     DNS
			 缓存服务器
			 DNS冗余
集群概念：集群是一组协同工作的服务器，对外表现为一个整体
分类：
负载均衡集群LBC：将用户请求按照定义好的规则进行均衡的分担到后端真实节点之上
高可用集群 HAC: 尽可能的保证服务的持久性
	  高性能运算集群 HPC：使用多台机器组合形成一台服务器不能达到的性能



一、让内网服务器集群访问外网：
   1.公网备案
     2.集群搭建完毕
     3.让网络支持人员把服务器的内网ip 10.10.10.100 映射一个外网ip
     4．去域名供应商注册，解析服务器的ip
二、通过DNS达到水平扩展的原理
      
1. DNS中有若干条记录，分别将服务器域名解析若干各不同的IP对应不同的服务器，客户端发来访问请求，第一次访问，dns将域名解析成第一个IP，此时就访问第一台服务器，第二次访问dns就将域名解析成第二个IP，访问第二台，以此类推达到水平扩展的目的。
     缺点：
公司通常会搭建缓存服务器，此时客户端访问，就不会找DNS，而是直接找缓存服务器，一旦缓存服务器一旦保存了第一条记录，客户端来访问时，大量访问量将会集中在第一台服务器，从而使得负载不均衡。
           后端健康状态检查，如果第一台服务器坏了，会报访问中断
           dns坏了，需要做冗余

           这种方式已经不常用

2.CDN（Content Delivery Network，即内容分发网络）
  
 CDN：公司在不同的地方部署缓存DNS服务器，客户端来访问主站服务器时，主DNS会判断客户端IP的地址，离哪个服务器近，就将请求转交给哪个服务器。
       缺点：搭建困难，费用较大
3.agent端：(集群)
   
   客户端发来一个访问请求,DNS会将客户要访问的IP解析到agent端的外网IP，在agent上编写一定的规则，将访问请求分发给不同的服务器，达到水平扩展和负载的作用。
   每个服务器进行同样的配置，分担访问压力。（这里拿lamp环境举例），每台服务器搭建lap，并且搭建一个mysql服务器给三个服务器使用，用来存储文字数据。并且搭建RHCS（红帽集群套件）服务器，将每台服务器挂载在RHCS上，将数据零散地分布在每台服务器上，但这样会使RHCS的磁盘I/O压力增大，还可以通过RSYNC+inotify实现数据同步，达到分担磁盘I/O的作用。
三、集群分类

1.负载均衡集群
概念：将用户请求按照定义好的规则进行均衡的分担到后端真实节点之上
	构成
		负载调度器
		后端节点
		共享存储
	实现
		硬件
			F5 big-ip
			思捷、恩瑞科技
		软件（负载调度器）
			LVS  Nginx （upstream）   amoeba  RAC（mysql）

   一台服务器用于主服务器，一台用于备份服务器，当主服务器损坏，备份服务器开启充当主服务器处理请求，后端搭建共享服务器进行数据共享。
       主服务器和备份服务器之间状态检测机制：heartbeat，添加独立网卡进行心跳检测（发送数据包）
                                             通过串口线进行心跳检测
       检测到主服务器损坏，备份服务器就会开启
2. 高可用集群 HAC:尽可能的保证服务的持久性
                                            高可用集群级别：
	                                        99%      99			
	                                        99.9%	 999
	                                        99.99%   9999
	                                        99.999%  99999
	
      实现（硬件）：ROSE
                   F5  
      实现方式：
                   vrrp      虚拟路由冗余协议（keepalived项目）
                   heartbeat（命令行）      （Linux-HA项目）
		
	  缺点：脑分裂  
		    数据损坏（当主服务器和备份服务器之间的连接中断，两服务器都向共享服务器中插入数据会使数据损坏）
		    服务终止
		
	  解决方案：
		    增加冗余   预防机制
		    电源交换机	绝对隔离
3.高性能集群：（运用较少，一般用于大型的计算项目，如气象预测等）
概念：使用多台机器组合形成一台服务器不能达到的性能
LBC：增加单位时间处理的任务数		相同请求     10
HPC：减少单个任务处理时间          1    1s

       hadoop
		      mapreduce  
		      hdfs   分布式文件系统

四、负载均衡集群
组成
		负载调度器
		后端节点
		共享存储
		
	实现方式
		硬件
			f5 思捷 安瑞
		
		软件
			Nginx  LVS  mysqlproxy   amoeba
			
	差异：
		工作层级
			二层：数据链路层	不同网路
			
			四层：传输层   port IP 
			
			七层：应用层  uRL
		
实现原理
			七层：tcp两次完整连接   客户端到服务器   服务器到后端真实节点
                   
                   进行两次tcp连接：客户端先与负载调度器进行第一次握手，然后与后端节点进行第二次握手，获取数据，最后将数据返回服务器端，四次握手完成，断开连接。
			四层：tcp建立一个完整连接	客户端到后端真实服务器
			
	安全性  ddos
			 七层：可以拦截 syn 攻击（在调度器上写防火墙规则，当一个ip连续访问次数过多，就拒绝该ip的访问）
			
             四层：不可拦截（直接发起syn包攻击真实服务器）

	业务逻辑：
			四层：ip port			大访问量的单个网站（只识别ip和端口，客户端来）
                                    客户端访问服务器问www1.com，负载调度器只判断ip和端口，然后将请求随机分配到后端节点，客户端并不能真正访问
                                    到www1.com(一个服务器ip对应多个公司网站)，可能访问到www2.com
			七层：URL hostname  	小访问量的多个网站（可识别url 、hostname）
			                        客户端访问，先和负载调度器进行tcp连接，判断客户端访问的网站，（服务器定义了一个服务器池）如果是访问www1.com
                                    就直接交给www1服务器。
                                     
			www.jd.com   www.jd.hk   ip   不同域名

          四层七层结合
















LVS:
       ipvs
       ipvsadm：命令行管理工具
工作在内核
架构：

lvs服务器工作在内核空间，上有两块网卡，一块连接外网，一块连接内网，用于连接内网真实服务器节点。
外网客户端发起访问，外网网卡接收到数据包，lvs内核层，通过钩子函数（ipvs）判断数据包是访问上层应用还是集群
                                                      访问的是上层应用，通过input函数把数据包发给上层应用
                                                      访问的是集群，把数据包发给内网网卡，转发给指定的集群服务器
钩子函数:内核中的一种机制，在数据包到达固定位置前强行获取进行检测，拥有最高优先级




一、lvs工作方式：
NAT模式
DR模式
tun模式
1.NAT模式：
   
客户端c访问服务器（源IP：CIP目的IP：VIP），负载调度器的第一块网卡接收到数据包，钩子函数检测目标IP是自己，将目标IP修改为RS1（通过算法将请求轮询给真实服务器）。
RS1响应，修改源IP目标 IP为（RS1 CIP），RS1将网关指向D1，进行源地址转换（SNAT），源IP目标IP为（S:VIP D:CIP）,然后将数据包返回给客户端。

             1 、负载调度器必须是Linux，后端真实节点可以是任意操作系统
	2、相应入站请求以及出站请求
	3、负载调度器工作在真实服务器以及客户端之间相当于一个路由器，负载调度器真实服务器必须在一个网络内，后端真实服务器必须将网关指向负载调度器，而不是网络环境中的真实路由器
	4、支持端口映射
	因为处理入站以及出站请求性能在三中模式中属于中间地位，一般后端负载节点为 10 个左右

外网测试机 网关 内网服务 1 内网服务 2 内网 nfs 共享
route add default gw IP 地址 所有内网主机全部要指网关
nfs 服务器搭建 网络文件系统
mkdir /share
vim /etc/exports 修改 nfs 配置文件
共享的目录 客户端地址（共享的权限） example ： /share 192.168.1.2(ro,sync 只读访问，同步 )
service rpcbind start 开启 rpcbind
service nfs start 开启 nfs 服务
#service portmap restart 如果不行开启服务
showmount -e 本机 IP 地址 查看共享的 nfs 服务器

1.第一台网站服务器
route add default gw 192.168.19.62
yum -y install httpd 安装 apache
showmount -e 192.168.1.2 （ nfs 服务器地址） 查看是否有 nfs 共享目录
mount 192.168.7.250 ： /share （共享目录） /var/www/html （挂载点） 将 nfs 共享文件挂在到 /var/www/html 上
service httpd start 启动 apache 服务
chkconfig httpd on 设置 apache 的开机自启动

2.第二台网站服务器 第二台网页服务器为了测试效果不采用 nfs 共享的方式，但在实际工作中通通采用 nfs 共享的方式
route add default gw 192.168.19.62
yum -y install httpd 安装 apache
cd /var/www/html 进入网页存放目录
vi index.html 创建并编辑网页文件
www.diertaiapache.com


3.网关服务器
添加外网网卡：
cp –a ifcfg-eth0 ifcfg-eth1
vim ifcfg-eth1 DEVICE=eth1
TYPE=Ethernet
ONBOOT=yes
BOOTPROTO=none
IPADDR=192.168.20.62
service network restart

LVS 安装
modprobe ip_vs 测试是否加载，如果没有得到任何信息，则已经加载
cat /proc/net/ip_vs 查看版本信息，以检测是否已经开始正常工作
cd /mnt/cdrom/Packages/ 进入光盘挂载目录
rpm -ivh ipvsadm-1.26l......... 安装 ipvsadm 管理工具
vi /etc/sysctl.conf 作为网关服务器，需要开启路由转发功能
......
net,ipv4.ip_forward=1
sysctl -p 刷新内核参数

iptables -t nat -A POSTROUTING -s 192.168.7.0/24( 内网网段） -o eth0 （外网口网卡名称） -j SNAT --to-source
172.16.16.172  （外网口的网卡地址） 添加防火墙规则
iptables -t nat -A POSTROUTING -s 192.168.19.0/24 -o eth1 -j SNAT --to-source 192.168.20.62
iptables -t nat -L 查看添加的规则
ipvsadm -A （添加一个负载调度器） -t 172.16.16.172:80  （集群地址，在 NAT' 模式下，就等于是外网口地址） -s rr （代表采用的
算法， rr 代表轮询） 添加一个调度器规则
ipvsadm -A -t 192.168.20.62:80 -s rr 

### iptables -D -t IP:80 清除调度规则
ipvsadm -a （集群服务器 ) -t 172.16.16.172:80 （集群地址） -r 192.168.7.21:80 （集群服务器地址） -m （代表调度模式， -m 代表
NAT 模式） 添加一个集群服务器信息，一台需要添加一条
ipvsadm -a -t 192.168.20.62:80 -r 192.168.19.63:80 –m 
ipvsadm -a -t 192.168.20.62:80 -r 192.168.19.64:80 -m


ipvsadm -Ln 查看已设规则
service ipvsadm save 保存策略
chkconfig ipvsadm on 设置为开机自启动
如果没有轮询，检查内网主机默认路由的添加

2.DR模式


客户端发送请求（S:CIP D:VIP），先经过路由器，再经过交换器S(S:CIP D:VIP DMAC:RS1)，将SYN包拆开到4层。
负载调度器和真实服务器在同一环境下，通过MAC地址通信，请求发到RS1，负载调度器和RS1是同一个IP，真实服务器上配置router，网关指向负载调度器。
将数据包给本地回环网卡处理，修改源IP，目标IP为（S:VIP D:CIP），然后将数据发给客户端。
3.tun模式

1、负载调度器以及真实节点必须拥有外网IP或能够被外网访问
2、负载调度器以及真实节点必须支持二次封装
3、负载调度器处理入站请求并且进行二次封装，后端真实服务器处理出站请求并且支持二次封装
4、性能在三种模式之间最低
	
总结：三种模式，NAT配置最简单，DR模式最常使用，TUN模式最特殊基本不用

二、算法
1.固定算法（静态调度算法）：只根据算法本身去调度，不考虑服务器本身。
2.动态算法（动态调度算法）:除了考虑算法本身，还考虑服务器状态

三、静态调度算法
   1.RR轮询：将每次用户的请求分配给后端的服务器，从第一台服务器开始到第N台结束，然后循环。
   2.WRR轮询：加权轮询，按照权重比例实现在多台主机之间进行调度
                
   3.SH（source hash）源地址散列，将同一个IP的用户请求，发给同一个服务器
   4.DH（destination hash）目标地址散列，将同一个目标地址的用户请求，发给同一个真实服务器（提高缓存的命中率）
          
         这种模式会在负载调度器上创建一个hash表，记录用户的访问信息（CIP SIP），下一次，同一个用户来访问直接把请求交给hash表中记录的上次用户访问的服务器。这样提高了缓存命中率，但是后端服务器压力分配不均衡，需要搭建后端的session共享服务器。
5.LC(lest-connection)最少连接：将新的连接请求，分配给最少的服务器， 活动连接*256 + 非活动连接
6.WLC加权最少连接：特殊的最少连接算法，权重越大承担的请求数越多（活动连接*256 + 非活动连接）/权重
7.SED最短期望延迟，特殊的WLC算法  （活动连接 + 1）*256/权重
8.NQ永不排队，特殊的SED算法，无需等待，如果有真实服务器的连接数等于0就直接分配，不需要运算
9.LBLC特殊的DH算法既能提高缓存命中率，又要考虑服务器的性能



















9.18            DR模式集群搭建、keepalived     
  
DR模式            
一、	DR模式搭建原理图


1.	客户端IP：20.20.20.12,客户端访问www.xdl.com时DNS将其解析为一个外网IP：20.20.20.11（实际上访问的是路由器的IP）
2.	访问请求到达公司路由器R，通过DNAT（目标地址转换）将20.20.20.11转换为集群的IP：10.10.10.100  端口：80（目的是用于公司内网集群通信）
3.到达交换机此时CIP：20.20.20.12   DIP：10.10.10.100,然后数据包继续传发给负载调度器D
4.负载调度器IP：10.10.10.11(关闭网卡重定向功能，减少不必要的请求，提高服务器性能)
   网卡子接口IP（集群IP）：10.10.10.100
   数据包拆到4层，判断数据包是否访问集群的，如果是访问集群，修改2层目的mac为当前的集群子节点RS1，将数据包丢到广播域中
5.集群子节点IP都是10.10.10.100，不做设置不能正确的把数据包发给RS1！此时需要指定一个vhost（route add -host  虚拟 IP dev lo:0），相当于网关，因为数据包没指网关，是发不出去的，会被丢弃。
RS1IP：10.10.10.12（目的：用于为客户端返回数据）
  开启回环网卡子接口lo：0(为什么不用eth0？答：arp通讯行为是用网卡设置的，如果用eth0会影响本机的正常通信)，并关闭其响应级别和通信级别（目的：因为集群字节点IP都是一样的，这样做是避免IP冲突）
  数据包交给回环网卡处理，处理完转发给eth0，然后发给外网客户端

二、	搭建

  



* 虚拟网卡的 IP 与真实网卡的 IP 需在同 一网段，且子网掩码为 255.255.255.255, 且主机虚拟网卡与其他服务器虚拟网卡 IP 相同
负载调度器
service NetworkManager stop                                         启动虚拟借口，必须关闭此服务（字符界面默认没安装）
cd /etc/sysconfig/network-scripts/
cp ifcfg-eth0 ifcfg-eth0:0
vim ifcfg-eth0:0                                                       配置虚拟借口
DEVICE=eth0:0
IPADDR= 虚拟 IP
NETMASK=255.255.255.0
ifup eth0:0                                                             启动虚拟网卡
vim /etc/sysctl.conf 修改内核参数。防止相同网络地址广播冲突，如果有多快网卡需要设置多行 net.ipv4.conf.eth0.send_redirects = 0
net.ipv4.conf.all.send_redirects = 0
net.ipv4.conf.default.send_redirects = 0
net.ipv4.conf.eth0.send_redirects = 0
sysctl -p                                                               刷新内核参数
modprobe ip_vs                                                         查看内核是否加载，无法应则以加载
cat /proc/net/ip_vs                                                   参看版本，确认知否正确加载
cd /mnt/cdrom/Packages/                                              进入光盘挂载目录
rpm -ivh ipvsadm-1.26l.........                                    安装 ipvsadm 管理工具
ipvsadm -v
ipvsadm -A -t  虚拟 IP:80 -s rr
ipvsadm -a -t  虚拟 IP:80 -r  网站 1:80 -g
ipvsadm -a -t  虚拟 IP:80 -r  网站 2:80 -g
ipvsadm -Ln
service ipvsadm save
chkconfig ipvsadm on

网站 1
service NetworkManager stop
cd /etc/sysconfig/network-scripts/
cp ifcfg-lo ifcfg-lo:0
DEVICE=lo:0
IPADDR= 虚拟 IP
NETMASK=255.255.255.255
vim /etc/sysctl.conf
net.ipv4.conf.all.arp_ignore = 1
net.ipv4.conf.all.arp_announce = 2
net.ipv4.conf.default.arp_ignore = 1
net.ipv4.conf.default.arp_announce = 2
net.ipv4.conf.lo.arp_ignore = 1
net.ipv4.conf.lo.arp_announce = 2
sysctl –p                一定要先刷新再开启网卡
ifup lo ： 0
route add -host  虚拟 IP dev lo:0
echo “123” >> /var/www/html/index.html                &&             mount -t nfs  共享存储 : 共享目录 /var/www/html
service httpd start

网站 2
service NetworkManager stop
cd /etc/sysconfig/network-scripts/
cp ifcfg-lo ifcfg-lo:0
vi ifcfg-lo ： 0
DEVICE=lo:0
IPADDR= 虚拟 IP
NETMASK=255.255.255.255
vim /etc/sysctl.conf
net.ipv4.conf.all.arp_ignore = 1
net.ipv4.conf.all.arp_announce = 2
net.ipv4.conf.default.arp_ignore = 1
net.ipv4.conf.default.arp_announce = 2
net.ipv4.conf.lo.arp_ignore = 1
net.ipv4.conf.lo.arp_announce = 2
sysctl –p
ifup lo：0
route add -host  虚拟 IP dev lo:0
vim /var/www/html/index.html
service httpd start

共享存储
vim /etc/exports
/share 内网网段 (ro,sync)
servie rpcbind restart
service nfs restart






keepalived
一、	LVS+keepalived
负载均衡+高可用群集、
作用：
针对LVS调度器实现双机热备
能够管理服务器池，自动隔离失效节点

二、LVS+keepalived搭建原理图
    















三、搭建流程
准备：四台虚拟机，两台做LVS+高可用，两个后端节点

1.	搭建负载（可以在原有集群的基础之上的实验）

MASTER（主调度）服务器


service NetworkManager stop                                         启动虚拟借口，必须关闭此服务（字符界面默认没安装）
cd /etc/sysconfig/network-scripts/
cp ifcfg-eth0 ifcfg-eth0:0
vim ifcfg-eth0:0                                                       配置虚拟借口
DEVICE=eth0:0
IPADDR= 虚拟 IP
NETMASK=255.255.255.0
ifup eth0:0                                                             启动虚拟网卡
vim /etc/sysctl.conf 修改内核参数。防止相同网络地址广播冲突，如果有多快网卡需要设置多行 net.ipv4.conf.eth0.send_redirects = 0
net.ipv4.conf.all.send_redirects = 0
net.ipv4.conf.default.send_redirects = 0
net.ipv4.conf.eth0.send_redirects = 0
sysctl -p                                                               刷新内核参数
modprobe ip_vs                                                         查看内核是否加载，无法应则以加载
cat /proc/net/ip_vs                                                   参看版本，确认知否正确加载
cd /mnt/cdrom/Packages/                                              进入光盘挂载目录
rpm -ivh ipvsadm-1.26l.........                                    安装 ipvsadm 管理工具
ipvsadm -v
ipvsadm -A -t  虚拟 IP:80 -s rr
ipvsadm -a -t  虚拟 IP:80 -r  网站 1:80 -g
ipvsadm -a -t  虚拟 IP:80 -r  网站 2:80 -g
ipvsadm -Ln
service ipvsadm save
chkconfig ipvsadm on

网站 1
service NetworkManager stop
cd /etc/sysconfig/network-scripts/
cp ifcfg-lo ifcfg-lo:0
DEVICE=lo:0
IPADDR= 虚拟 IP
NETMASK=255.255.255.255
vim /etc/sysctl.conf
net.ipv4.conf.all.arp_ignore = 1
net.ipv4.conf.all.arp_announce = 2
net.ipv4.conf.default.arp_ignore = 1
net.ipv4.conf.default.arp_announce = 2
net.ipv4.conf.lo.arp_ignore = 1
net.ipv4.conf.lo.arp_announce = 2
sysctl -p
ifup lo ： 0
route add -host  虚拟 IP dev lo:0
echo “123” >> /var/www/html/index.html                &&             mount -t nfs  共享存储 : 共享目录 /var/www/html
service httpd start

网站 2
service NetworkManager stop
cd /etc/sysconfig/network-scripts/
cp ifcfg-lo ifcfg-lo:0
vi ifcfg-lo ： 0
DEVICE=lo:0
IPADDR= 虚拟 IP
NETMASK=255.255.255.255
vim /etc/sysctl.conf
net.ipv4.conf.all.arp_ignore = 1
net.ipv4.conf.all.arp_announce = 2
net.ipv4.conf.default.arp_ignore = 1
net.ipv4.conf.default.arp_announce = 2
net.ipv4.conf.lo.arp_ignore = 1
net.ipv4.conf.lo.arp_announce = 2
sysctl –p 
ifup lo ： 0
route add -host  虚拟 IP dev lo:0
vim /var/www/html/index.html
service httpd start

2.	高可用
MASTER服务器（主调度器）
yum -y install kernel-devel openssl-devel popt-devel gcc*
更换光盘，拷出 keepalived
cd /usr/src                                                 必须将源码包文件拷贝到 /usr/src 下面安装
tar -zxf keepalived.....
cd keep.....
./configure --prefix=/ --with-kernel-dir=/usr /src/kernels/2.6.32........./
make
make install
ls -l /etc/init,d/keepalived
chkconfig --add keepalived
chkconfig keepalived on
vi /etc/keepalived/keepalived.conf
global_defs {
router_id R1                                                命名主机名
}
vrrp_instance VI--1 {
state MASTER                                                设置服务类型主 / 从（ MASTER/SLAVE ）
interface eth0                                              指定那块网卡用来监 听
virtual_router_id 66                                      设置组号，如果是一组就是相同的 ID 号，一个主里面只能有一个主服务器和多个从服务器
priority 100                                                 服务器优先级，主服务器优先级高
advert_int 1 心跳时间，检测对方存活
authenticetion { 存活验证密码
auth_type PASS
auth_pass 1111
}
virtual_ipaddress {
192.168.19.100                                              设置集群地址
}
}
virtual_server 192.168.19.100 80 {                      设置集群地址 以及端口号
delay_loop 6                                                 健康检查间隔
lb_algorr                                                     使用轮询调度算法
lb_kind DR                                                    DR 模式的群集
protocol TCP                                                  使用的协议
real_server 192.168.19.63 80 {                            管理的网站节点以及使用端口
weight 1                                                       权重，优先级 在原文件基础上删除修改
TCP_CHECK {                                                   状态检查方式
connect_port 80                                              检查的目标端口
connect_timeout 3                                           连接超时（秒）
nb_get_retry 3                                               重试次数
delay_before_retry 4                                        重试间隔（秒）
}
real_server 192.168.19.64  80 {                        管理的第二个网站节点以及使用端口
weight 1                                                    权重，优先级 在原文件基础上删除修改
TCP_CHECK {                                                状态检查方式
connect_port 80                                           检查的目标端口
connect_timeout 3                                         连接超时（秒）
nb_get_retry 3                                            重试次数
delay_before_retry 4                                     重试间隔（秒）
}
}
}



多余删除
scp keepalived.conf xx.xx.xx.xx ： /etc/keepalived/
SLAVE（新备用调度器）
   cp ifcfg-eth0 ifcfg-eth0:0
vim ifcfg-eth0:0                                                       配置虚拟借口
DEVICE=eth0:0
IPADDR= 虚拟 IP
NETMASK=255.255.255.0
ifup eth0:0                                                             启动虚拟网卡
如果启动报错
 vim ifup-eth
注释247-251行
vim /etc/sysctl.conf 修改内核参数。防止相同网络地址广播冲突，如果有多快网卡需要设置多行 net.ipv4.conf.eth0.send_redirects = 0
net.ipv4.conf.all.send_redirects = 0
net.ipv4.conf.default.send_redirects = 0
net.ipv4.conf.eth0.send_redirects = 0
sysctl -p                                                               刷新内核参数
modprobe ip_vs                                                         查看内核是否加载，无法应则以加载
cat /proc/net/ip_vs                                                   参看版本，确认知否正确加载
cd /mnt/cdrom/Packages/                                              进入光盘挂载目录
rpm -ivh ipvsadm-1.26l.........                                    安装 ipvsadm 管理工具
ipvsadm -v
ipvsadm -A -t  虚拟 IP:80 -s rr
ipvsadm -a -t  虚拟 IP:80 -r  网站 1:80 -g
ipvsadm -a -t  虚拟 IP:80 -r  网站 2:80 -g
ipvsadm -Ln
service ipvsadm save
chkconfig ipvsadm on

yum -y install kernel-devel openssl-devel popt-devel gcc*
更换光盘，拷出 keepalived
cd /usr/src                                                 必须将源码包文件拷贝到 /usr/src 下面安装
tar -zxf keepalived.....
cd keep.....
./configure --prefix=/ --with-kernel-dir=/usr /src/kernels/2.6.32........./
make
make install
ls -l /etc/init,d/keepalived
chkconfig --add keepalived
chkconfig keepalived on
vi /etc/keepalived/keepalived.conf
global_defs {
router_id R2                                               命名主机名
}
vrrp_instance VI--1 {
state SLAVE                                                 设置服务类型主 / 从（ MASTER/SLAVE ）
interface eth0                                              指定那块网卡用来监 听
virtual_router_id 66                                      设置组号，如果是一组就是相同的 ID 号，一个主里面只能有一个主服务器和多个从服务器
priority 100                                                 服务器优先级，主服务器优先级高
advert_int 1 心跳时间，检测对方存活
authenticetion { 存活验证密码
auth_type PASS
auth_pass 1111
}
virtual_ipaddress {
192.168.19.100                                              设置集群地址
}
}
virtual_server 192.168.19.100 80 {                      设置集群地址 以及端口号
delay_loop 6                                                 健康检查间隔
lb_algorr                                                     使用轮询调度算法
lb_kind DR                                                    DR 模式的群集
protocol TCP                                                  使用的协议
real_server 192.168.19.63 80 {                            管理的网站节点以及使用端口
weight 1                                                       权重，优先级 在原文件基础上删除修改
TCP_CHECK {                                                   状态检查方式
connect_port 80                                              检查的目标端口
connect_timeout 3                                           连接超时（秒）
nb_get_retry 3                                               重试次数
delay_before_retry 4                                        重试间隔（秒）
}
real_server 192.168.19.64  80 {                           管理的第二个网站节点以及使用端口
weight 1                                                       权重，优先级 在原文件基础上删除修改
TCP_CHECK {                                                   状态检查方式
connect_port 80                                              检查的目标端口
connect_timeout 3                                            连接超时（秒）
nb_get_retry 3                                               重试次数
delay_before_retry 4                                        重试间隔（秒）
}
}
}
多余删除
service keepalived start
service ipvsadm start
用的检测命令：
ipvsadm -Ln                                     查看设置的 ipvsadm
ipvsadm –Ln –-stats                           查看连接状态
























9.19            4层+7层负载、heartbeat

——4层+7层负载

一、	背景 
4层负载并发量更大，支持的后端节点更多，但是它只能靠IP和MAC识别访问请求，而不能识别，FQDN域名，但是七层负载却可以。
一般公司都会有多个主营业务，并不仅限于www业务，可能还会有mail业务等，此时就需要搭建两个lvs集群。原理图如下。

  



这样的话机会，资源就会很浪费，所以我们可以采用4层+7层的模式：








	
二、搭建
 1.搭建LVS
D负载调度器
service NetworkManager stop                                         启动虚拟借口，必须关闭此服务（字符界面默认没安装）
cd /etc/sysconfig/network-scripts/
cp ifcfg-eth0 ifcfg-eth0:0
vim ifcfg-eth0:0                                                       配置虚拟借口
DEVICE=eth0:0
IPADDR= 虚拟 IP
NETMASK=255.255.255.0
ifup eth0:0                                                             启动虚拟网卡
vim /etc/sysctl.conf 修改内核参数。防止相同网络地址广播冲突，如果有多快网卡需要设置多行 net.ipv4.conf.eth0.send_redirects = 0
net.ipv4.conf.all.send_redirects = 0
net.ipv4.conf.default.send_redirects = 0
net.ipv4.conf.eth0.send_redirects = 0
sysctl -p                                                               刷新内核参数
modprobe ip_vs                                                         查看内核是否加载，无法应则以加载
cat /proc/net/ip_vs                                                   参看版本，确认知否正确加载
cd /mnt/cdrom/Packages/                                              进入光盘挂载目录
rpm -ivh ipvsadm-1.26l.........                                    安装 ipvsadm 管理工具
ipvsadm -v
ipvsadm -A -t  虚拟 IP:80 -s rr
ipvsadm -a -t  虚拟 IP:80 -r  网站 1:80 -g
ipvsadm -a -t  虚拟 IP:80 -r  网站 2:80 -g
ipvsadm -Ln
service ipvsadm save
chkconfig ipvsadm on

RS1
service NetworkManager stop
cd /etc/sysconfig/network-scripts/
cp ifcfg-lo ifcfg-lo:0
DEVICE=lo:0
IPADDR= 虚拟 IP
NETMASK=255.255.255.255
vim /etc/sysctl.conf
net.ipv4.conf.all.arp_ignore = 1
net.ipv4.conf.all.arp_announce = 2
net.ipv4.conf.default.arp_ignore = 1
net.ipv4.conf.default.arp_announce = 2
net.ipv4.conf.lo.arp_ignore = 1
net.ipv4.conf.lo.arp_announce = 2
sysctl -p
ifup lo ： 0
route add -host  虚拟 IP dev lo:0
echo “123” >> /var/www/html/index.html                &&             mount -t nfs  共享存储 : 共享目录 /var/www/html
service httpd start

RS2
service NetworkManager stop
cd /etc/sysconfig/network-scripts/
cp ifcfg-lo ifcfg-lo:0
vi ifcfg-lo ： 0
DEVICE=lo:0
IPADDR= 虚拟 IP
NETMASK=255.255.255.255
vim /etc/sysctl.conf
net.ipv4.conf.all.arp_ignore = 1
net.ipv4.conf.all.arp_announce = 2
net.ipv4.conf.default.arp_ignore = 1
net.ipv4.conf.default.arp_announce = 2
net.ipv4.conf.lo.arp_ignore = 1
net.ipv4.conf.lo.arp_announce = 2
sysctl -p
route add -host  虚拟 IP dev lo:0
vim /var/www/html/index.html
service httpd start

共享存储
vim /etc/exports
/share 内网网段 (ro,sync)
servie rpcbind restart
service nfs restart

 2.搭建nginx负载（RS1、RS2都要搭建）
 yum -y install gcc*
yum -y install pcre* zlib*
useradd -M -s /sbin/nologin nginx
解压软件包 nginx
./configure --prefix=/usr/local/nginx --user=nginx --group=nginx 
make && make install

vim /usr/local/nginx/conf/nginx.conf

upstream www.xdl.com {			             server 192.168.19.65:80;			             server 192.168.19.66:80;
}			            upstream mail.xdl.com {			                  server 192.168.19.67:80;		 
} 

server {
        listen       80;
        server_name  www.xdl.com;
        location / {
        proxy_pass http://www.xdl.com
        }
        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }
    }

server {
        listen       80;
        server_name  mail.xdl.com;
        location / {
        proxy_pass http://mail.xdl.com
        }
        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }
    }
			
 
 3.搭建后端真实节点(65、66、67)
192.168.19.65
         yum –y install httpd
         ehco  “www1” > /var/www/html/index.html

192.168.19.66
         yum –y install httpd
         ehco  “www2” > /var/ww192.168.19.65

192.168.19.67
         yum –y install httpd
         ehco  “mail” > /var/www/html/index.html 

4.开图形化测试
   vim /etc/hosts
   192.168.19.100 www.xdl.com  
   192.168.19.100 mail.xdl.com

     www.xdl.com
     mail.xdl.com
    这里的是LVS集群的虚拟IP


上面这种模式，后端apache的第一个节点的压力将会非大，如果有上百台apache，上面那种模式就不适用了，所以可以采用以下模式。








	

我们可以在上一个实验的基础上略作修改

upstream www.xdl.com {			             server 192.168.19.65:80;			             server 192.168.19.66:80;
}			            upstream mail.xdl.com {			                  server 192.168.19.64:80;     将这里的IP改为，第二台nginx的IP		 
} 

同理第二台nginx的配置文件也要修改
 upstream www.xdl.com {			             server 192.168.19.63:80;    将这里的IP改为，第一台nginx的IP			             
}			            upstream mail.xdl.com {			                  server 192.168.19.67:80;     		 
} 


这样一来，用户访问mail.xdl.com ,轮询到第一台nginx，nginx下的houduan节点并没有mail服务，但是通过负载跳转到第二台nginx，对其下的mail服务器进行访问


——heartbeat

Heartbeat
一、软件包
软件包版本为 Centos6 系列，如果使用其它版本可以配置 eperl 源下载安装
二、环境准备
1) 配置时间同步服务
2) 配置主机名解析
三、安装

   vim  /etc/hosts    （主和备都要修改）
   10.10.10.11 www.centos1.com
   10.10.10.12 www.centos2.com
   
   这里的解析的记录要和主机FQDN一致，否则会报错。
1) 基础准备，主备节点都需安装
tar -zxvf hearbeat.tar.gz
cd hearbeat
yum -y install *
cd /usr/share/doc/heartbeat-3.0.4/
cp ha.cf authkeys haresources /etc/ha.d/ 配置文件需拷贝到默认目录下
2) 认证服务，节点之间的认证配置，修改 /etc/ha.d/authkeys ，在主上修改
dd if=/dev/random bs=512 count=1 | openssl md5 #生成密钥随机数

vim authkeys
auth 1
1 md5 a4d20b0dd3d5e35e0f87ce4266d1dd64

chmod 600 authkeys
3) heartbeat 主配置文件，修改 /etc/ha.d/ ha.cf ， 在主上修改
bcast eth0                                       通过这块网卡进行发包测试
node www.centos1.com 一主一备节点，需注意能后被两台主机之间解析(212行)
node www.centos2.com
4) 配置 haresources 文件，在主上修改                通过eth0：0进行同步
    在最底下添加
www.centos1.com IPaddr::10.10.10.100/24/eth0:0
这里的Ipaddr是一个脚本，作用相当于开了一个网卡子接口：ifconfig eth0:0 10.10.10.100 netmask 255.255.255.0
5) 将主三个配置文件拷贝到从上
cd /etc/ha.d/
scp ha.cf authkeys haresources root@www.centos1.com:/etc/ha.d/
6)编写网页文件用于测试
   echo “123” > /var/www/html/index.html
   echo “456” > /var/www/html/index.html
7)启动服务进行验证
主：service httpd start
主：service heartbeat start
备：service httpd start
备：service heartbeat start

#!/bin/bash

function check_code {
    url=$1
    curl -o /dev/null  -s -w %{http_code} $url
}

web_code=$( check_code 10.10.10.100 )

if [ "$web_code" != "200" ]
    then
        service heartbeat stop
fi

我们可以通过这个脚本写成定时任务，检测heartbeat服务器的开启状况，如果httpd关闭，将会通过这个脚本关闭heartbeat,作用相当于：service heartbeat stop。这中方式相当于主动关闭，备用服务器切换更快

而心跳检测，需要先检测才能切换，会更慢。



























                                     ————squid

squid  缓存服务器守护进程
	
GUN/GPL 协议开发		 开放源代码，可以二次开发，但是二次开发的产物必须继续遵循 GPL 协议
ASL 2.0   apache协议
开放源代码，可以二次开发，并且二次开发产物可以闭源
   
   常用缓存服务器：
       squid和varnish
      	varnish：子文件数目多单个文件小处理速度更快，不适应现在大多数生产环境=，比如在线报纸
squid :  子文件数目较少文件较大型，
           
squid存储文件的机制：磁盘 分区 目录 object
squid 存储文件的时候，会将分区格式成ufs格式

squid通过digest table 和 hash  table索引文件
       digest：记录的是目录下缓存的对象（文件）
       hash table：记录的是分区中缓存的目录

一、	缓存服务器基本模型

代理的基本类型：
传统代理：适用于Internet，需明确指定服务端
透明代理：适用于共享上网网关，不需指定服务端
反向代理：位于网站前端，代理web接受客户端的请求


使用代理的好处：
提高Web访问速度
隐藏客户机的真实IP地址
2.代理的类型详解：
  (1)代理传统
      
（2）透明代理
      
（3）反向代理
     

二、squid工作机制
1.对外网进行缓存
  

           


















 在内网中搭建squid服务器，内网用户在浏览器上指明squid服务器的IP地址和端口，可以加速内部人员访问的速度。
 也可以在squid上写一些规则，来限制内部用户访问的速度或者下载文件的大小。

2.对内网进行缓存
   


















web服务器在内网中，并搭建squid服务器，设置路由器，为外网用户提供访问。
squid服务器不会缓存session信息
3.	CDN（内容分发系统）













    
如果服务分别搭在联通和电信网络上，它们之间的访问就会很慢。
         这时就需要利用CDN技术，在联通搭建squid服务器，将其反向代理到电信客户端，如果有人访问squid，缓存有数据就会直接返回数据，如果没有进行反向代理请求网站


CDN核心
（1）.反向代理+缓存服务器
squid   首选
vanish
nginx+memcache

squid 模型
   
















squid搭建集群，用户访问第一个squid，没有得到数据。这个sqiud会去找同城的另一个相邻squid，squid之间都是相互同步的。vanish没这种功能。

（2）.智能DNS
   view  bind9.0
   dnspod    腾讯
      联通  ip
      电信  ip


三、squid搭建
    Squid服务端
软件包：squid-2.6.STABLE21-6.el5
系统服务：squid
主程序：/usr/sbin/squid
主配置文件：/etc/squid/squid.conf
默认监听端口：TCP 3128
默认访问日志：/var/log/squid/access.log

http_port 3128
access_log /var/log/squid/access.log squid
cache_mem 64 MB
cache_dir ufs /var/spool/squid 100 16 256
visible_hostname proxy.benet.com
dns_testnames www.google.com www.163.com
maximum_object_size 4096 KB
reply_body_max_size  10 MB




9.20    传统代理、透明代理、反向代理实验
ACL控制
    ACL（ Access Control List ，访问控制列表）：
根据源地址、目标URL、文件类型等定义列
acl  列表名称  列表类型  列表内容 ... 
针对已定义的acl列表进行限制
allow或deny  列表名称 
... [root@localhost ~]# vi /etc/squid/squid.conf
……
acl all src 0.0.0.0/0.0.0.0
http_access deny all
[root@localhost ~]# service squid reload

列表类型
src   		源地址
dst   		目标地址
port   		目标地址
dstdomain    	目标域
time   		访问时间
maxconn   		最大并发连接
url_regex   		目标URL地址
Urlpath_regex   	整个目标URL路径


     	
http_accesACL 规则：	
如果 acl 匹配没有 http_access ,默认全部拒绝	
没有匹配到 http_access 默认拒绝，但是会根据最后一个的http_access的反向进行处理s  
######传统代理实验
       Nginx 和 squid 反向代理调度器
	
1、Nginx 识别 url 进行固定调度	 2、Nginx 对后端节点主机进行健康状态检测	 3、Squid 可以对客户端访问数据进行缓存	 4、Nginx 有众多负载调度算法

分布式存储解决方案   RHCS  MFS				                           


内网
router add default gw 192.168.1.1 添加默认路由
网关（两块网卡）
cp ifcfg-eth0 ifcfg-eth1

yum -y install squid 安装 squid 服务
vim /etc/squid/squid.conf
http_port 3128
下方添加
visible_hostname www.xdl.com
service squid start
vi /etc/sysctl.conf
net.ipv4.ip_forward = 1 开启路由转发
外网
vi /var/www/html/index.html
zheshi ceshi ye!
service httpd start
内网

浏览器 —— 编辑 —— 首选项 —— 高级 —— 链接 —— 设置 —— 手动代理 —— 网关内网 IP——3128
直接访问外网
如果字符页面访问
vi /etc/profile 下方添加
HTTP_PROXY=HTTP ： //192.168.1.1:3128
export HTTP_PROXY
. /etc/profile 重新加载全局配置文件
yum -y install elinks

测试 elinks 10.0.0.1（外网IP）



######透明代理实验

       内网
router add default gw 192.168.1.1 添加默认路由
网关
yum -y install squid 安装 squid 服务
vim /etc/squid/squid.conf
http_port 192.168.1.1：3128 transparent        ip 为网关内网 IP
visible_hostname www.xdl.com
service squid start
vi /etc/sysctl.conf
net.ipv4.ip_forward = 1 开启路由转发
iptables -t nat -A PREROUTING -i eth0( 内网网卡 ) -s 192.168.1.0/24 -p tcp --dport 80 -j REDIRECT --to-ports
3128                   添加路由规则
外网
vi /var/www/html/index.html
zheshi ceshi ye!
service httpd start
下载限制测试
cd /var/www/html
dd if=/dev/zero of=1.txt bs=1M count=15
vim /etc/squid/squid.conf
reply_body_max_size 1024x1024x20
reply_body_max_size 20 MB

wget http://192.168.19.64:/var/www/html/1.txt

######反向代理实验
      

内网 1
router add default gw 192.168.1.1 添加默认路由
vi /var/www/html
111111111111
service httpd start

内网 2
router add default gw 192.168.1.1 添加默认路由
vi /var/www/html
2222222222222
service httpd start

网关（两块网卡）
yum -y install squid 安装 squid 服务
vim /etc/squid/squid.conf
http_access allow all
http_port 10.0.0.1:80( 网关外网口地址 ) vhost
visible_hostname www.xdl.com
cache_peer 192.168.1.2 （内网中网页服务器 IP ） parent 80 0  （网络中是否还有其他代理） originserver round-robin （节
点以轮询的方式）
cache_peer 192.168.1.3 parent 80 0 originserver round-robin

service squid start
vi /etc/sysctl.conf
service squid reload

http_accesACL 规则：	
如果 acl 匹配没有 http_access ,默认全部拒绝	
没有匹配到 http_access 默认拒绝，但是会根据最后一个的http_access的反向进行处理（需要关闭http_access deny all）





iscsi实验
网络磁盘   nfs   不基于虚拟化   vcent(exsi组件)   		 windows server  vcent    需要在安装windows server管理	                                            卫星服务器	  kvm

普通的磁盘阵列
    I/O不高（raid5只有3-5块盘组成，而网络磁盘可能由几十上百块盘组成）
    安全性不高


原理图
    








scsi硬盘采用的scsi协议，当使用scsi硬盘时，发送的是scsi命令，而不是发送的数据
                                                  如果是网络磁盘，会在scsi指令外嵌套一个tcp包

freenas   家庭存储


1、lvm整合
pvcreate /dev/sdb     创建物理卷
vgcreate vg0 /dev/sdb     创建卷组
lvcreate -L（创建的大小） 1G -n（创建名称） lv0 vg0（从哪里创建） 创建逻辑卷
mkfs -t ext4 /dev/vg0/lv0  对创建的逻辑卷进行格式化
partprobe /dev/sdb 强制重读分区表
mkdir /lv
mount /dev/vg0/lv0 /lv

2、在 target 端创建 IQN 标签
yum -y install scsi-target-ut	 yum安装包，创建iSCSI对象
service tgtd start	 开启服务
netstat -anpt | grep tgtd
查看服务是否开启
tgtadm -L（指定驱动类型） iscsi -o（制定操作类型） new -m（制定管理的对象） target -t （制定当前存储资源id号）1    -T（制定iqn标签，命名规则：iqn.创建年-月.域名反写：自定义） iqn.2016-2.com.xdl.www:lvm
example：tgtadm -L iscsi -o new -m target -t 1 -T iqn.2016-2.com.xdl.www:lvm

tgtadm -L iscsi -o show -m target
查看target创建的信息

3、绑定 IQN 标签到存储设备
tgtadm -L（指定驱动类型） iscsi -o new -m（管理的对象） logicalunit -t （tat标签）1 -l（逻辑存储单元的标签） 1 -b（设备名称） /dev/vg0/lv0
tgtadm -L iscsi -o bind -m target -t 1 -I 192.168.19.0/24

4、客户端配置
yum -y install iscsi-initiator-utils
iscsiadm -m discovery -t st -p（指定服务器IP地址） 192.168.19.64  
iscsiadm -m node -T iqn.2017-8.com.xdl.www:lvm --login  在客户端进行挂载
fdisk /dev/sdb
mkfs -t ext4 /dev/sdb1  格式化
partprobe /dev/sdb 强制重读分区表
mkdir /lv
mount /dev/sdb1 /lv    
iscsiadm -m node -T iqn.2016-2.com.xdl.www:lvm --logout  在客户端进行卸载
vi /etc/fstab    修改自动挂载文件
           /dev/sdb        /mnt    ext4    defaults,_netdev        0 0  （添加）
       5配置文件修改
vim /etc/tgt/targets.conf
<target iqn.2017-8.com.dgt.www:lvm>
               backing-store /dev/vg0/lv0
               initiator-address 192.168.19.64
</target>

9.21  RHCS  、 MFS（分布式存储）
 ####RHCS
一、原理
（1）定义：RHCS（红帽集群套件）：基于iscsi服务开发的分布式存储系统。
（2）工作原理：
     server端作为一个源站（target端），所有写入的文件最终会存储到这里，相当于一个备份节点（主调度器），客户端需要进行一系列配置才可以使用，客户端写入文件的同时，target端会将写入的文件打散到各个服务器节点，优点是利用了所有客户端磁盘的I/O。
     target端，有完整的数据，另一份数据被打散到各个节点。









（3）RHCS套件包含的服务 
         iscsi   块共享驱动
           cman   集群管理器    用于各个节点通讯
                   ccs 集群配置管理器
           cmanager  集群控制器
           GFS2   第二版全局文件系统  （用户可以一起使用，而块级文件系统不能同时使用同一个文件）
           GLVM   集群逻辑卷组
           
         (4)搭建

####MFS
一、	MFS定义
MFS：MooseFS是一个具备冗余容错功能的分布式网络文件系统，它将数据分别存放在多个物理服务器或单独磁盘或分区上，确保一份数据有多个备份副本，然而对于访问MFS的客户端或者用户来说，整个分布式网络文件系统集群看起来就像一个资源一样，从其对文件系统的情况看MooseFS就相当于UNIX的文件系统
  二、MFS特性
      a.高可靠性：每一份数据可以设置多个备份（多分数据），并可以存储在不同的主机上
b.高可扩展性：可以很轻松的通过增加主机的磁盘容量或增加主机数量来动态扩展整个文件系统的存储量
c.高可容错性：我们可以通过对mfs进行系统设置，实现当数据文件被删除后的一段时间内，依旧存放于主机的回收站中，以备误删除恢复数据
d.高数据一致性：即使文件被写入、访问时，我们依然可以轻松完成对文件的一致性快照
  三、MFS的缺点
master目前是单点，虽然会把数据信息同步到备份服务器，但是恢复需要时间
master服务器对主机的内存要求略高
默认metalogger复制元数据时间较长（可调整）

内存使用问题：
对于master服务器来说，资源型要求就是内存大小，为了整个系统访问更快，mfs会把所以访问的元数据metadada信息放在内存中提供用户访问，因此，当文件数量增加时，内存使用量就方说法，处理一百万个文件chunkserver，大概需要300M会增加，根据官的内存空间。据此，推算如果未来要出来1个亿的文件chunkserver，大概需要30G内存空间

应用场景：
大规模高并发的线上数据存储及访问（小文件，大文件都适合）
大规模的数据处理，如日志分析，小文件强调性能不用HDFS
四、MooseFS的结构以及原理


    

管理服务器 managing server 简称 master ：
	这个组件的角色是管理整个mfs文件系统的主服务器，除了分发用户请求外，还用来存储整个文件系统中每个数据文件的metadata信息，metadate（元数据）信息包括文件（也可以是目录，socket，管道，块设备等）的大小，属性，文件的位置路径等
             官方对master的要求是：上raid5，双通道内存，双电源。
云数据备份服务器 Metadata backup servers 简称metalogger：
	这个组件的作用是备份管理服务器master的变化的metadata信息日志文件，文件类型为changelog_ml.*.mfs。以便于在管理服务器出问题时，可以经过简单的操作即可让新的主服务器进行工作。

数据存储服务器组data servers（chunk servers）简称data：
	这个组件就是真正存放数据文件实体的服务器了，这个角色可以有多台不同的物理服务器或不同的磁盘及分区来充当，当配置数据的副本多于一份时，据写入到一个数据服务器后，会根据算法在其他数据服务器上进行同步备份。
                真实节点存储数据原理：以数据块的形式，每个块的大小64M
         
                    
客户机服务器组（client servers）简称 client：
这个组件就是挂载并使用mfs文件系统的客户端，当读写文件时，客户端首先会连接主管理服务器获取数据的metadata信息，然后根据得到的metadata信息，访问数据服务器读取或写入文件实体，mfs客户端通过fuse mechanism实现挂载mfs文件系统的，因此，只有系统支持fuse，就可以作为客户端访问mfs整个文件系统

对数据的操作类型

修改/占用  C > ms > 查询 > 返回节点IP以及访问路径 > 新建块（目的：写入新文件） 创建*.swp
文件  > 如果修改数据  会将*.swp  改为* 并删除之前副本以及备份副本
        如果不是修改数据  会删除*.swp并删除块设备 

删除  C > server > 查询对应存储块 > 选择一个把数据放在垃圾箱 > 删除对应块

新建  C > server > 找一个节点创建块设备  写入文件并记录数据库

查询  C > server > 返回元数据

文件系统崩溃修复命令： fsck –y
9.22  MFS搭建   cacti搭建
MFS分布式文件系统
一、MFS分布式文件系统说明
1、MFS文件系统共有4个角色，分别是
   管理服务器 --- Master Server
   元数据日志服务器 --- Metalogger
   数据存储服务器 --- Chunk Server
   客户端 --- Client
2、角色作用
   管理服务器--mfsmaster： 有时也称为元数据服务器，负责管理各个数据存储服务器，调度文件读写，回收文件空间以及恢复多节点
   拷贝。
   元数据服务器-mfsmetalogger： 负责备份管理服务器的变化日志，文件类型为changelog_ml.*.mfs，以便于在管理服务器出现问
   题时接替期进行工作。这类服务器是在mfs1.6版本后新增的服务，可以把元数据日志保留在管理服务器中，也可以单独存在一台服务器
   中。为保证数据的安全性和可靠性，建议单独使用一台服务器来存放元数据日志，需要注意的是，元数据日志守护进程跟管理服务器在同
   一个服务器，备份元数据日志服务器作为它的客户端，从管理服务器取得日志文件进行备份。
   数据存储服务器-mfschunkserver： 这类是真正存储用户数据的服务器。在存储文件时，首先把文件分成块，然后把这些块在数据
   存储服务器之间互相复制，同事，数据存储服务器还负责连接管理服务器，听从管理服务器调度，并为客户提供数据传输。数据存储服务
   器可以有多个，并且数量越多，可靠性越高。MFS可用的磁盘空间也越大。
   客户端-mfsclient： 客户端通过fuse内核接口挂载远程服务器上所管理的数据存储服务器，使共享的文件系统和使用本地linux文件
   系统的效果看起来一样的。
二、实验环境说明
1、关闭防火墙、selinux
2、所有节点配置时间同步服务器
3、节点说明
   192.168.19.62 MfsMaster
   192.168.19.63 Mfsmetadata
   192.168.19.64  192.168.19.65  MfsChunkServer
   192.168.19.66.67  192.168.19.66 MfsClient
4、源码包下载地址：源码包下载地址是：http://ppa.moosefs.com/src/moosefs-3.0.84-1.tar.gz




三、源码包安装
1、192.168.19.62 安装 master server 管理服务器
   [root@localhost tmp]# tar zxf moosefs-3.0.84-1.tar.gz
   [root@localhost tmp]# cd moosefs-3.0.84
   [root@localhost moosefs-3.0.84]# useradd -M mfs -s /sbin/nologin
   [root@localhost moosefs-3.0.84]# ./configure --prefix=/usr/local/mfs --with-default-user=mfs --with-default-group=mfs
   [root@localhost moosefs-3.0.84]# make && make install
   mfsmaster.cfg
   [root@localhost moosefs-3.0.84]# chmod a+x /usr/local/mfs/sbin/*
   [root@localhost mfs]# ln -s /usr/local/mfs/sbin/* /usr/local/sbin/
   [root@localhost moosefs-3.0.84]# cd /usr/local/mfs/etc/mfs
   [root@localhost mfs]# cp -a mfsmaster.cfg.sample mfsmaster.cfg 无需修改

！配置文件说明
   WORKING_USER = mfs
   WORKING_GROUP = mfs
   SYSLOG_IDENT = mfsmaster # 在 syslog 中的表示，说明这是 mfsmaster 产生的
   LOCK_MEMORY = 0 #  是否执行 mlockall() 以避免 mfsmaster 内存溢出（默认为 0 ）
   NICE_LEVEL = -19 #  运行的优先级（默认 -19 ，注意，这进程必须是 root 启动 ）
   DATA_PATH = /usr/local/mfs/var/mfs # 数据存放路径，该目录下有三大类文件， changelog,sessions,stats
   EXPORTS_FILENAME = /usr/local/mfs/etc/mfs/mfsexports.cfg # 被挂载目录以及其权限控制文件的存放位置
   BACK_LOGS = 50 # 元数据的改变日志文件数量（默认是 50 ）
   MATOML_LISTEN_HOST = * #  元数据日志服务器监听的 IP 地址（默认是 * ，代表任何 IP ）
   MATOML_LISTEN_PORT = 9419 #  元数据日志服务器监听的端口地址，默认是 9419
   MATOCS_LISTEN_HOST = * #  用于存储服务器（ Chunk Server ）连接的 IP 地址
   MATOCS_LISTEN_PORT = 9420 #  是存储服务器（ Chunk server ）连接的端口地址
   REPLICATIONS_DELAY_INIT = 300 #  延迟复制的时间（默认是 300 ）
   CHUNKS_LOOP_MIN_TIME = 300 # chunks  的回环率
   CHUNKS_SOFT_DEL_LIMIT = 10
   CHUNKS_WRITE_REP_LIMIT = 2,1,1,4 在一个循环里复制到一个 CHUNK Server 的最大 chunks 数目
   CHUNKS_READ_REP_LIMIT = 10,5,2,5
   MATOCL_LISTEN_HOST = *
   MATOCL_LISTEN_PORT = 9421
   
   
   mfsexports.cfg
   [root@localhost mfs]# cp mfsexports.cfg.sample mfsexports.cfg
   [root@localhost mfs]# vim mfsexports.cfg
           192.168.19.0/24 . rw,alldirs,maproot=0    (在最后一行添加)
   ！配置文件说明
   192.168.19.0/24
   . 表示MFSMETA文件系统
   rw.alldirs,maproot=0 表示客户端拥有的权限。
   权限部分选项如下：
   ro 只读模式共享
   rw 读写方式共享
   alldirs 允许挂载任何指定的子目录
   maproot 映射为root用户还是指定的用户
   password 指定客户端密码
   
   metadata.mfs
   [root@localhost mfs]# cp /usr/local/mfs/var/mfs/metadata.mfs.empty /usr/local/mfs/var/mfs/metadata.mfs
   启动master server
   [root@localhost mfs]# mfsmaster start
   [root@localhost mfs]# netstat -lnpt # 查看监听端口，确保启动成功 
   Active Internet connections (only servers)Proto Recv-Q Send-Q Local Address Foreign Address
   State PID/Program name '''tcp 0 0 0.0.0.0:9419 0.0.0.0:* LISTEN
   5944/mfsmaster tcp 0 0 0.0.0.0:9420 0.0.0.0:* LISTEN
   5944/mfsmaster tcp 0 0 0.0.0.0:9421 0.0.0.0:* LISTEN
   5944/mfsmaster '''
说明：停止master server，安全停止master server是非常必要的，千万不要kill，而是利用自带的命令mfsmaster来安全停止master server ， mfsmaster
stop ，我们安装后采用默认的配置，没有做任何更改，所以默认的日志是写入/var/log/messages。

mfscgiserv start   开启（python编写de）测试网页

测试：   浏览器访问  IP：9425
2、192.168.19.63 安装元数据日志服务器
   [root@localhost moosefs-3.0.84]# useradd mfs -s /sbin/nologin
   [root@localhost moosefs-3.0.84]# ./configure --prefix=/usr/local/mfs --with-default-user=mfs --with-default-group=mfs
   [root@localhost moosefs-3.0.84]# make && make install
   
    mfsmetalogger.cfg
   [root@localhost mfs]# cp mfsmetalogger.cfg.sample mfsmetalogger.cfg
   root@localhost mfs]# vim mfsmetalogger.cfg
   META_DOWNLOAD_FREQ = 2          39行
MASTER_HOST = 192.168.19.62 # master server  的地址    52行
#  元数据备份文件下载请求频率，默认是 24 小时，即每 2 小时从 master server 上下载一个
   metadata.mfs 文件，当元数据服务器关闭或者故障的时候， metadata.mfs.back 文件将消失，此时需要从元数据日志服务器中取得这个文件。注
意，这个文件和日志文件共同使用才能恢复整个已损坏的分布式文件系统 ... 只需要更改上面 2 行就行了，其他保持默认即可如果没有特殊要求。
MASTER_HOST = 192.168.19.62 # master server  的地址
启动元数据服务器
   [root@localhost moosefs-3.0.84]# chmod a+x /usr/local/mfs/sbin/*
   [root@localhost mfs]# ln -s /usr/local/mfs/sbin/* /usr/local/sbin/
   [root@localhost mfs]# mfsmetalogger start #  启动命令
   [root@localhost mfs]# lsof -i :9419 #  确保端口在使用中 COMMAND
       PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEmfsmetalo 7446 mfs 8u IPv4 19768 0t0 TCP
       172.16.160.192:48103->172.16.160.191:9419 (ESTABLISHED)
   [root@localhost mfs]# cd /usr/local/mfs/var/mfs/ #  查看工作目录下是否有元数据文件
   
3、192.168.19.64(192.168.19.65) 安装数据存储服务器（Chunk Server）
   [ root@salt moosefs-3.0.84]# useradd mfs -s /sbin/nologin
   [root@salt moosefs-3.0.84]# ./configure --prefix=/usr/local/mfs --with-default-user=mfs --with-default-
      group=mfs && make && make install
	  
   mfschunkserver
   [root@salt moosefs-3.0.84]# cd /usr/local/mfs/etc/mfs/
   [root@salt mfs]# cp mfschunkserver.cfg.sample mfschunkserver.cfg
   [root@salt mfs]# vim mfschunkserver.cfg
       MASTER_HOST = mfsmaster #  指明 master server 服务器地址    71行
       MASTER_PORT = 9420 # 指明 master server  端口                 75行
       HDD_CONF_FILENAME = /usr/local/mfs/etc/mfs/mfshdd.cfg #  这个指明哪个配置文件来配置共享磁盘的   33行
	   
    mfshdd
   [root@salt etc]# mkdir /mnt/sdb1
   [root@salt mfs]# vim /usr/local/mfs/etc/mfs/mfshdd.cfg
       /mnt/sdb1       最后一行添加
   [root@salt etc]# fdisk /dev/sdb
   [root@salt etc]# partprobe
   [root@salt etc]# mkfs.ext4 /dev/sdb1
   [root@salt etc]# mount /dev/sdb1 /mnt/sdb1/
   [root@salt etc]# chown -R mfs.mfs /mnt/sdb1/
   
   启动服务
[root@localhost moosefs-3.0.84]# chmod a+x /usr/local/mfs/sbin/*
   [root@localhost mfs]# ln -s /usr/local/mfs/sbin/* /usr/local/sbin/

   [root@salt etc]# mfschunkserver start
   [root@salt etc]# ps -ef | grep mfsmfs
          405681002:14 ? 00:00:00 mfschunkserver startroot 4062517565002:15 pts/000:00:00grep mfs
		  
3、192.168.19.66(192.168.19.67)安装数据存储服务器（ fuse ）
   [root@localhost libfuse-master]# yum -y install fuse fuse-devel fuse-libs
   [root@localhost tmp]# tar zxf moosefs-3.0.84-1.tar.gz
   [root@localhost tmp]                    useradd mfs -s /sbin/nologin   
   [root@localhost tmp]# cd moosefs-3.0.84
   [root@localhost tmp]
   [root@localhost tmp]# ./configure --prefix=/usr/local/mfs --with-default-user=mfs --with-default-group=mfs
   --disable-mfsmaster --disable-mfschunkserver && make && make install
    [root@localhost tmp]mkdir /www                 创建www目录用于挂载
     [root@localhost tmp]chmod mfs.mfs /www
   [root@localhost tmp]# /usr/local/mfs/bin/mfsmount /www -H 10.10.10.12
   -H  指定 master server IP
   
   
   一、误删除处理，垃圾回收站机制
   mfssettrashtime 64800 /mnt/mfs/test1	设置保存时间
   mkdir /back
   chown mfs.mfs /back
   mfsmount -m /back -H 10.10.10.11
   tree . 定位删除文件目录
   mv 002/00000002\|1.txt /back/trash/undel/
   查看恢复文件
		
   二、快照功能
   mkdir  bb
   chown  mfs.mfs bb/
   mfsmakesnapshot 1.txt bb/
   cd bb/
   ll
	
   三、冗余 goal 设置
   mfssetgoal 3 /mnt/mfs/test1 
   mfssetgoal  /mnt/mfs/test1 
   mfsfileinfo  /mnt/mfs/test1
	
   四、还原 master
   mfsmaster -a
   
   
   
   
   
cacati搭建

一、安装环境
   yum -y install httpd mysql mysql-server mysql-devel libxml2-devel mysql-connector-odbc perl-DBD-Mysql unixODBC 
   php php-mysql php-pdo

   service httpd start
   service mysqld start

   yum -y install 
   net-snmp net-snmp-utils net-snmp-libs lm_sensors

二、安装rrdtol
   tar -zxf rrdtool-1.4.5.tar.gz
   cd rrdtool
   ./configure --prefix=/usr/local
   make && make install 

   如出错，按以下步骤解决
   第1步
   tar zxvf cgilib-0.5.tar.gz
   cd cgilib-0.5  
   make
   cp libcgi.a /usr/local/lib
   cp cgi.h /usr/include
   第2步
   yum –y install libart_lgpl-devel
   第3步
   yum –y install pango-devel* cairo-devel*

三、部署cacti，设置数据库连接
   1、部署源码包，并安装补丁文件
   tar -zxf cacti-0.8.7g.tar.gz
   mv cacti-0.8.7g/ /var/www/html/cacti
   cd !$
   patch -p1 -N <root/cacti/data_source_deactivate.patch
   patch -p1 -N <~/graph_list_view.patch
   patch -p1 -N <~/html_output.patch
   patch -p1 -N <~/ldap_group_authenication.patch
   patch -p1 -N <~/script_server_command_line_parse.patch
   patch -p1 -N <~/ping.patch
   patch -p1 -N <~/poller_interval.patch
   
  2、添加检测数据的用户账户，更改权限，保证读写数据正常
   useradd runct
   chown -R root.root ./
   chown -R runct.runct rra/   log/
   
  3、授权数据库用户,导入初始化数据
   mysql -u root -p
   create database cactidb default character set utf8;
   grant all on cactidb.* to 'cactiuser'@'localhost' identified by 'pwd@123';
   quit
   mysql -u cactiuser -p cactidb < cacti.sql
   
  4、修改cacti配置文件
   vim include/config.php
   mysql
   cactidb
   localhost
   cactiuser
   pwd@123
   3306
   
  5、调整http配置
   vim /etc/httpd/conf/httpd.conf
     Listen 80
     DocumentRoot "/var/www/html/cacti"
     <Directory "/var/www/html/cacti">
     options None
     AllowOverride None 
     Order allow,deny
     Allow from all
     </Directory>
     DirectoryIndex index.php index.html
     AddDefaultCharset utf-8

     service httpd restart

四、安装
     http://192.168.216.16/install


五、客户端配置
     yum -y install net-snmp net-snmp-utils lm_sensors

     vim /etc/snmp/snmpd.conf
        41 服务器地址 默认为default    共同体名称  默认为public
        62 开放所有的SNMP查询权限 all 默认为SystemView
        85 支持各种查询与访问 取消注释符号


六、收集数据
     su - runct
     php /var/www/html/cacti/poller.php

     crontab -e 
        */5 * * * *  /usr/bin/php  /var/www/html/cacti/poller.php &>/dev/null

     exit
     service crond start 

七、安装插件
     cd ~
     tar -zxf cacti-plugin-0.8.7g-PA-v2.8.tar.gz
     mysql -u cactiuser -p cactidb < cacti-plugin-arch/pa.sql
     cd /var/www/html/cacti
     patch -p1 -N < ~/cacti-plugin-arch/cacti-plugin-0.8.7g-PA-v2.8.diff

     cd /var/www/html/cacti/plugins
     tar -zxf ~/monitor-0.8.2.tar.gz
     tar -zxf ~/settings-0.5.tar.gz
     tar -zxf ~/thold-0.4.3.tar.gz
     mysql -u cactiuser -p cactidb < monitor/monitor.sql
     mysql -u cactiuser -p cactidb < thold/thold.sql

八、配置识别插件
     Utilities -- User Management -- admin -- Plugin Management -- save

     Configuration -- Plugin Management -- Actions 添加插件 （thold需单独点击）

     未出现图标，则：
     Utilities -- User Management -- admin -- View Thresholds 和 View Monitoring 打钩


九、配置Monitor
    

Configration -- setting -- misc -- 将最后一行改为Tiles – save






















------9.25                                   Nagios
一、Nagios简介
Cacti: 收集数据、图型展现
偏重网络流量
SNMP、OID、SNMP  Agent
    Nagios: 偏重主机、服务的状态
Agent
脚本
    
    监控对象: 主机、主机组（自动发现规则）
服务/资源，服务组
联系人，联系人祖（用于发送报警信息）
时段（定义一个时段，发送报警信息）
命令（通过配置不同的命令监控不同的对象）

二、原理
可以通过插件、脚本、客户端等多种方式进行检测。	
    B/S + C/S 机构	
    

1.plugin：插件管理器  通过脚本获取客户端service端数据
2.客户端也安装plugin插件，检测本机信息，然后服务器端通过sshd守护进程收集信息
3.nrpe：最常用的，nagios默认不支持，需要重新定义命令
4.同过snmp协议收集客户端信息
5.NSCA：不常用,主动向服务器提交数据。如果客户端较多，如果所有服务器同时向服务器发送数据，服务器压压力增大，建立不了大量的tcp连接。
       






        NDOUtils函数：判断是否为垃圾邮件


监控windows客户端：







1.nagios和客户端位于同一个广播域，连在同一个交换机上，互相ping不通的原因:
交换机上配置了vlan（隔离广播域）。
VLAN(Virtual Local Area Network)的中文名为"虚拟局域网"。
虚拟局域网(VLAN)是一组逻辑上的设备和用户，这些设备和用户并不受物理位置的限制，可以根据功能、部门及应用等因素将它们组织起来，相互之间的通信就好像它们在同一个网段中一样，由此得名虚拟局域网。VLAN是一种比较新的技术，工作在OSI参考模型的第2层和第3层，一个VLAN就是一个广播域，VLAN之间的通信是通过第3层的路由器来完成的。与传统的局域网技术相比较，VLAN技术更加灵活，它具有以下优点: 网络设备的移动、添加和修改的管理开销减少;可以控制广播活动;可提高网络的安全性。
在计算机网络中，一个二层网络可以被划分为多个不同的广播域，一个广播域对应了一个特定的用户组，默认情况下这些不同的广播域是相互隔离的。不同的广播域之间想要通信，需要通过一个或多个路由器。这样的一个广播域就称为VLAN。
2.flapping(定义发送报警的级别)
软状态：发送数据包1-3 次，不回应会记录到日志中（但不会发送警告信息）
硬状态：4次以上，发送警告信息

nagios监控等级：

        OK：正常    Warning：警告  Unknown：未知  Critical：严重警告  Pending：准备状态

三、搭建流程

安装前的准备工作

(1)解决安装Nagios的依赖关系：
# yum -y install httpd gcc glibc glibc-common php php-mysql mysql mysql-server mysql-devel
  cd /mnt/Package
  yum -y install *gd*


（2）所需要安装组件：

服务端所用的安装包为 nagios nagios-plugins ndoutils(非必须)
linux客户端 nrpe
windows客户端 NSClient++

（3）
进行selinux设置，或者关闭selinux

开始搭建：
1.添加nagios运行所需要的用户和组：
# groupadd nagcmd
# useradd -m nagios
# usermod -a -G nagcmd nagios

# usermod -a -G nagcmd apache


2、编译安装nagios：


# tar zxf nagios-3.3.1tar.gz 
# cd nagios-3.3.1
# ./configure --with-command-group=nagcmd --enable-event-broker 

# make all
# make install
# make install-init
# make install-config
# make install-commandmode



# vim /usr/local/nagios/etc/objects/contacts.cfg 
email        nagios@localhost       #这个是默认设置

# make install-webconf

# htpasswd -c /usr/local/nagios/etc/htpasswd.users nagiosadmin
  
# service httpd restart


3、编译、安装nagios-plugins

# tar zxf nagios-plugins-1.4.14.tar.gz 
# cd nagios-plugins-1.4.14
# ./configure --with-nagios-user=nagios --with-nagios-group=nagios --with-mysql --enable-perl-modules

# make
# make install

4、配置并启动Nagios

# chkconfig --add nagios
# chkconfig nagios on

# /usr/local/nagios/bin/nagios -v /usr/local/nagios/etc/nagios.cfg   检测配置文件

# service nagios start

http://your_nagios_IP/nagios


登录时需要指定前面设定的web认证帐号和密码。

##################################################################

windos端
1.被监控端安装NSClient++-0.3.8-x64.msi
2.安装完成后修改配置文件NSC.ini把需要的库都打开


3.在监控服务器上修改nagios配置文件nagios.cfg
去掉注释cfg_file=/usr/local/nagios/etc/objects/windows.cfg
定义windows.cfg

define host{
        use             windows-server  ; Inherit default values from a template
        host_name      winserver       ; The name we're giving to this host
        alias           My Windows Server       ; A longer name associated with the host
        address         192.168.19.70   ; 你主机的IP
        }
%s/winserver/mywindows/g
#################################################################
linux端

1.yum –y install openssl openssl-devel
被监控端
先添加nagios用户
useradd nagios
为了安装nrpe，先安装nagios-plugins-1.4.14.tar.gz 插件
# tar zxf nagios-plugins-1.4.14.tar.gz 
# cd nagios-plugins-1.4.14
# ./configure --with-nagios-user=nagios --with-nagios-group=nagios
# make all
# make install

tar -zxvf nrpe-2.8.1.tar.gz
cd nrpe-2.8.1.tar.gz
./configure --enable-ssl --with-ssl-lib=/usr/lib64/
make all
make install-plugin
make install-daemon
make install-daemon-config

2.配置nrpe信息
vim /usr/local/nagios/etc/nrpe.cfg
allowed_hosts=192.168.19.62,127.0.0.1  //允许监控的IP
/usr/local/nagios/bin/nrpe -c /usr/local/nagios/etc/nrpe.cfg –d


服务端
3.安装NRPE
cd nagios-nrpe_2.8.1
./configure   #默认自动添加了openssl


#因为传送过程要加密,如果后面make报错,加如下参数
rpm -qa| grep ssl
openssl-devel-0.9.7a-43.17.el4_6.1
rpm -ql openssl-devel-0.9.7a-43.17.el4_6.1 | more

 ./configure --enable-ssl --with-ssl-lib=/usr/lib64/ (当然前提要有openssl)
make all
make install-plugin
---安装check_nrpe脚本

4.commands.cfg定义外部构件nrpe
vim /usr/local/nagios/etc/objects/commands.cfg
#添加
#check nrpe
define command{
        command_name check_nrpe
        command_line $USER1$/check_nrpe -H $HOSTADDRESS$ -c $ARG1$
        }

定义 mylinux.cfg
cd /usr/local/nagios/etc/objects/
cp windows.cfg linux.cfg
vim linux.cfg

define host{
           use             linux-server
          host_name       mylinux
          alias            mylinux
          address        192.168.19.63(客户端IP既被监控的IP)
		  
		  
多余的删除		  
               }
define service{
        use                      generic-service
        host_name             mylinux
        service_description     check-load
       check_command         check_nrpe!check_load
               }

define service{
        use                      generic-service
        host_name             mylinux
       service_description     check-users
       check_command        check_nrpe!check_users
               }
define service{
        use                    generic-service
        host_name           mylinux
        service_description  otal_procs
        check_command     check_nrpe!check_total_procs
} 

#################################################################################---------------------

在主配置文件nagios.cfg 中定义linux.cfg
vim nagios.cfg
cfg_file=/usr/local/nagios/etc/objects/linux.cfg


service httpd restart
service nagios restart




叮叮
配置网卡保证虚拟机能上网
    cp  -a  ifcfg-eth0  ifcfg-eth1
	
vim  ifcfg-eth1
	      设置IP为dhcp自动获取
	
shutdown  -h  now   
	
添加网卡   NAT模式

1.下载钉钉软件
   点创建---发起聊天---创建群名称---点击钉钉机器人----设置名称----复制webhook用于linux端脚本
   
   查看设置说明----查看自定义机器人消息检测脚本模板
   替换webhook
   
2.编写脚本
  vim  aa.sh
#！/bin/bash
 curl 'https://oapi.dingtalk.com/robot/send?access_token=xxxxxxxx' -H 'Content-Type: application/json'    -d '
   {"msgtype": "text",    
   "text": {        
   "content": "我就是我, 是不一样的烟火" 
   }  
   }' 
3.bash  aa.sh


apache 监控
    mkdir /usr/local/script
    mv jiankong /usr/local/script
    vim 80.sh
    将URL行的IP改成本机IP
    service httpd stop
    bash 80.sh



向所有人发送消息
    bash dingdingapi.sh aaaaaaaaaaaaaa
###########################################################################################################

./check_mysql -H 10.10.10.13 -u nagios -p 123 -d nagios

define service{
        host_name mysql
        check_period 24x7
        max_check_attempts 2
        normal_check_interval 1
        retry_check_interval 1
        contact_groups admins
        notification_interval 5
        notification_period 24x7
        notification_options w,u,c,r
        check_command check_mysql
        }
		
`curl -o /dev/null -s -w "%{http_code}" "${URL}"`














































------9.26                    Zabbix
一、Zabbix原理
zabbix	 是一个基于WEB界面的提供分布式系统监视以及网络监视功能的企业级的开源解决方案 ( 基于 GPL V2：开发者可以做二次开发，开发完还得以源码卖给客户	zabbix由 2 部分构成，zabbix server与可选组件zabbix agent

工作结构：
    


        IPMI：智能平台管理系统
Zabbix进程构成
zabbix 安装完成后会产生 5 个程序：zabbix_agentd、zabbix_get、zabbix_proxy、zabbix_sender、zabbix_server，zabbix_java_gateway是可选，这个需要另外安装
zabbix_agentd：客户端守护进程，此进程收集客户端数据，例如 cpu负载、内存、硬盘使用情况等
zabbix_get：zabbix 工具，单独使用的命令，通常用于排错
zabbix_sender：zabbix工具，用于发送数据给 server 或者 proxy ，在脚本完成之后使用 sender 主动将数据提交
zabbix_server：zabbix 服务端守护进程，所有的数据都是被提交或主动提交到  zabbix_server 端

zabbix_proxy：zabbix代理守护进程。功能类似server，唯一不同的是它只是一个中转站，它需要把收集到的数据提交/被提交到server里
zabbix_java_gateway：zabbix2.0之后引入的一个功能。顾名思义：Java网关，类似agentd，但是只用于Java方面。需要特别注意的是，它只能主动去获取数据，而不能被动获取数据。它的数据最终会给到server或者proxy。

二、Zabbix搭建（CentOS7）

1、初始化系统设置	 systemctl stop firewalld
systemctl disable firewalld
setenforce 0
sed -i "s/SELINUX=enforcing/SELINUX=disabled/g" /etc/selinux/config

2、安装 LAMP 环
wget http://mirrors.163.com/.help/CentOS7-Base-163.repo（使用网络yum源）
yum clean all
yum makecache


yum -y install mariadb mariadb-server httpd php php-mysql 
systemctl enable httpd
systemctl restart httpd
systemctl enable mariadb
systemctl restart mariadb
mysql_secure_installation
	三、安装 Zabbix 程序
	rpm -ivh  http://repo.zabbix.com/zabbix/3.2/rhel/7/x86_64/zabbix-release-3.2-1.el7.noarch.rpm   （官方镜像仓库）
rpm --import /etc/pki/rpm-gpg/RPM-GPG-KEY-ZABBIX
yum -y install zabbix-server-mysql zabbix-web-mysql  zabbix-agent
	 初始化数据库：
	mysql -u root -p
CREATE DATABASE zabbix DEFAULT CHARACTER SET utf8 COLLATE utf8_bin;
grant all privileges on zabbix.* to zabbix@localhost identified by 'zabbix';  
		 读入数据库
cd /usr/share/doc/zabbix-server-mysql-3.2.1
zcat create.sql.gz | mysql -uroot -p  zabbix 
		 启动 Zabbix 服务
vim /etc/zabbix/zabbix_server.conf
DBHost=localhost
DBName=zabbix
DBUser=zabbix
DBPassword=zabbix

	systemctl start zabbix-server
systemctl enable zabbix-server
		 编辑 zabbix 前端 php 配置
		 vim /etc/httpd/conf.d/zabbix.conf
php_value max_execution_time 300
php_value memory_limit 128M
php_value post_max_size 16M
php_value upload_max_filesize 2M
php_value max_input_time 300
php_value always_populate_raw_post_data -1
php_value date.timezone Asia/Shanghai
	
	调整时间同步
yum -y install ntpdate 
ntpdate cn.pool.ntp.org
	
	重启 Apache 服务生效
systemctl restart httpd

浏览器测试：   192.168.154.129/zabbix

端口  3306  密码：zabbix

安装成功之后：将语言修改为中文
Administration————users——————admin————————language
四、修改中文乱码问题
	Win+R>fonts>	拷贝微软雅黑字体改名为 msyh.ttf	  >/usr/share/zabbix/fonts

vim /usr/share/zabbix/include/defines.inc.php
修改 zabbix php 页面配置，将'graphfont' 修改为 msyh    45行
define('ZBX_GRAPH_FONT_NAME', 'msyh');

五、添加agent端插件用于监控本机
	vi /usr/local/zabbix/etc/zabbix_agentd.configure   源码包
yum -y install zabbix-agent-3.2.7-1.el6.x86_64.rpm
vim /etc/zabbix/zabbix_agentd.conf
	LogFile=/tmp/zabbix_agentd.log
	Server= 192.168.1.195 （主服务器IP）          95
ServerActive= 192.168.1.195（主服务器IP）     136
Hostname=192.168.1.195                           147

systemctl restart zabbix-agent   重启
六、监控另一台linux端                      vi /usr/local/zabbix/etc/zabbix_agentd.configure   源码包
yum -y install zabbix-agent-3.2.7-1.el6.x86_64.rpm
vim /etc/zabbix/zabbix_agentd.conf
	LogFile=/tmp/zabbix_agentd.log
	Server= 192.168.1.195 （主服务器IP）          95
ServerActive= 192.168.1.195（主服务器IP）     136
Hostname=192.168.1.195                           147

/etc/init.d/zabbix-agent restart
  重启

设置报警音需要点人头然后进行设置

四、Zabbix监控nginx
1、开启 Nginx 自带状态统计

useradd	    ./configure --prefix=/usr/local/nginx --user=nginx --group=nginx --with-http_stub_status_module
	make && make install
	添加监控模块
47行下添加即可	vi /usr/local/nginx/conf/nginx.conf
location /ngx_status {
stub_status on;
}
	
2、添加客户端脚本
cd /usr/local/zabbix/zabbix_agentd.d
vim ngx-status.sh		
	#!/bin/bash
# DateTime: 2015-10-25
# AUTHOR：凉白开
# WEBSITE: http://www.ttlsa.com
# Description：zabbix监控nginx性能以及进程状态
# Note：此脚本需要配置在被监控端，否则ping检测将会得到不符合预期的结果
# 文章地址：<span id="sample-permalink" tabindex="-1">http://www.ttlsa.com/zabbix/<span id="editable-post-name" title="临时固定链接，点击可更改这部分。">zabbix-monitor-nginx-performance</span>/</span> ‎
HOST="127.0.0.1"
PORT="80"
# 检测nginx进程是否存在
function ping {
/sbin/pidof nginx | wc -l 
}
# 检测nginx性能
function active {
/usr/bin/curl "http://$HOST:$PORT/ngx_status/" 2>/dev/null| grep 'Active' | awk '{print $NF}'
}
function reading {
/usr/bin/curl "http://$HOST:$PORT/ngx_status/" 2>/dev/null| grep 'Reading' | awk '{print $2}'
}
function writing {
/usr/bin/curl "http://$HOST:$PORT/ngx_status/" 2>/dev/null| grep 'Writing' | awk '{print $4}'
}
function waiting {
/usr/bin/curl "http://$HOST:$PORT/ngx_status/" 2>/dev/null| grep 'Waiting' | awk '{print $6}'
}
function accepts {
/usr/bin/curl "http://$HOST:$PORT/ngx_status/" 2>/dev/null| awk NR==3 | awk '{print $1}'
}
function handled {
/usr/bin/curl "http://$HOST:$PORT/ngx_status/" 2>/dev/null| awk NR==3 | awk '{print $2}'
}
function requests {
/usr/bin/curl "http://$HOST:$PORT/ngx_status/" 2>/dev/null| awk NR==3 | awk '{print $3}'
}
# 执行function
$1
	
3、在客户端添加自定义脚本规则

vim /etc/zabbix/zabbix_agentd.conf
  284 行  0改为1
		 UserParameter=nginx.status[*],/etc/zabbix/zabbix_agentd.d/ngx-status.sh $1    293行
service zabbix-agent restart
	
4、在服务器端使用 zabbix-get 测试脚本获取数据情况
yum -y install zabbix-get-3.2.7-1.el7.x86_64.rpm
# /usr/local/zabbix-3.0.0/bin/zabbix_get -s 10.10.1.121 -k 'nginx.status[accepts]'
# /usr/local/zabbix-3.0.0/bin/zabbix_get -s 10.10.1.121 -k 'nginx.status[ping]'      (可不用绝对路径)
	
5、配置 Nginx 服务器并添加 Nginx 监控模板（Web端）
1小时38分
1小时53分

五、自动发现
1.被监控端安装agent端
   
   yum -y install zabbix-agent-3.2.7-1.el6.x86_64.rpm
vim /etc/zabbix/zabbix_agentd.conf
LogFile=/tmp/zabbix_agentd.log
Server= 192.168.1.195 （主服务器IP）
ServerActive= 192.168.1.195（主服务器IP）
Hostname=192.168.1.195

service zabbix-agent restart   重启
2. 创建发现规则
   1小时54分
六、钉钉+zabbix
1.被监控端
   service httpd start
   echo “123” > /var/www/html/index.html

   安装agent yum -y install zabbix-agent-3.2.7-1.el6.x86_64.rpm端
   Server= 192.168.1.195 （主服务器IP）
ServerActive= 192.168.1.195（主服务器IP）
Hostname=192.168.1.195 

service zabbix-agent restart   重启
chkconfig –-add zabbix-agent
chkconfig zabbix-agent on

2. web监控端创建发现规则
    
    检测
    service  httpd stop
 
3.配置报警发送消息给钉钉

步骤三.Zabbix 配置文件中查找”Alert”查看告警脚本存放路径：
[root@localhost ~]# vim /etc/zabbix/zabbix_server.conf（不做修改）
AlertScriptsPath=/usr/lib/zabbix/alertscripts     453行
步骤四.进入配置中路径创建配置文件：
[root@localhost ~]# cd /usr/lib/zabbix/alertscripts/
[root@localhost alertscripts]# vim token.sh
按”I”键进行辑，粘帖以下脚本内容
Zabbix 钉钉告警脚本内容：
Xxxxxxx 是填写创建机器人时复制的 token
==================================分隔线=====================================
#!/bin/bash
to=$1
subject=$2
text=$3
curl 'xxxxxxxxx' \                                 将创建机器人生成的api粘贴到此
-H 'Content-Type: application/json' \
-d '
{"msgtype": "text",
"text": {
"content": "'"$text"'"
},
"at":{
"atMobiles":[
"'"$1"'"
],
"isAtAll":false
}
}'
===================================分隔线=====================================
步骤五.配置执行文件权限与归属
[root@localhost alertscripts]# chown zabbix.zabbix token.sh
[root@localhost alertscripts]# chmod +x token.sh
切换至 zabbix 用户测试脚本是否执行成功

测试
bash token.sh 17610017385 baojing sdfsdfsdfdsfsdf

4.配置报警并发送消息给钉钉

见文档


2小时41分



   

    












































----9.27                         Iptables/netfilter
	

防火墙简介
iptables基础
规则表&规则链
制定防火墙规则
防火墙应用
一、防火墙简介
防火墙：工作在主机边缘处或网络边缘处，可以自定义规则，防火墙核心代码根据设定的规则对数据包进行拦截处理或者放行

    1.安全设备的分类：
基础类防火墙：实现简单的包过滤
IDS:入侵检测系统   堡垒机  记录日志 事后分析 	
IPS：入侵防御系统   检测入站数据包，发现恶意代码主动进行拦截
主动安全设备：   waf  daf
	
2. 设备类型：
软件：iptables
硬件：网御  深信服  华为   
	
3. 工作机制:
包过滤防火墙：MAC  IP  PORT 协议
应用层防火墙：根据 URL 进行拦截
	
4.工作形态：  iptables
用户态：iptables firewalld
内核态：netfilter
	
吞吐量（评价性能的标志）
5.规则：
规则类型：
默认规则：开启或关闭
自定义规则：MAC IP 协议 端口  URL
      表作用：容纳各种规则链
      依据：根据防火墙对数据的处理方式

规则表：
raw表：确定是否对该数据包进行状态跟踪
mangle表：为数据包设置标记
nat表：修改数据包中的源、目标IP地址或端口
filter表：确定是否放行该数据包（过滤）iptables预设的规则表
   
INPUT:处理入站请求数据包
OUTPUT：处理出站请求数据包
FORWARD：处理路由转发
PREROUTING：修改目的地址
POSTROUTING：修改源地址


6.数据在本机行为：
入站：PREROUTING  >  INPUT
出站：OUTPUT  >  POSTROUTING
路由转发：PREROUTING > FORWARD > POSTROUTING 

	  INPUT:处理入站请求数据包
OUTPUT：处理出站请求数据包
FORWARD：处理路由转发
PREROUTING：修改目的地址
POSTROUTING：修改源地址

二、原理图
1.防火墙位置摆放
    
 

	

	




	web为公司内网服务器，s为交换机，R为路由器
           若要设置防火墙，应在1和2处设置防火墙，1处用来过滤内网数据包，2用来过滤外网数据包

2.防火墙在linux上的工作原理
routertables：路由表
TCP/IP协议栈：所有的协议存放位置
iptables：用户态
netfilter：内核态
1接口：INPUT:处理入站请求数据包
2接口：OUTPUT处理出站请求数据包
3接口： FORWARD：处理路由转发
4接口：PREROUTING：修改目的地址
5接口：POSTROUTING：修改源地址

服务器上有两块网卡，数据包从网卡1进，网卡2出
假设数据包的流向是从左到右
数据包从左侧网卡进入，（接口4置PREROUTING规则，修改目的地址，）过路由表，判断数据包是否是找自己的，
如果是交给1接口，通过input规则处理入栈请求数据包，如果数据包是访问上层应用，通过Input函数转发给上层应用，如果不是交给2接口，通过output规则处理出战请求数据包（接口5配置POSTROUTING规则，修改源地址）,数据包从右侧网卡出去。
如果要进行路由转发，经过4、3、5接（PREROUTING > FORWARD > POSTROUTING）
如果入栈，经过4、1接口（PREROUTING  >  INPUT）
如果出栈，经过2、5接口OUTPUT  >  POSTROUTING）

三、规则表&规则链详解
    
1.规则链内的匹配顺序
按顺序依次检查，匹配即停止（LOG策略例外）
若找不到相匹配规则，则按该链的默认策略处理

2.定义规则要求：
    如果没有联系，小范围优先；如果有联系，大范围优先。
    eg：编写规则允许443、80、22端口，拒绝所有
        允许这些端口和拒绝所有之间没有联系，而允许443、80、22端口是小范围的，所以小范围优先匹配
        允许443、80、22端口，属于同一类型，都是允许，这时就需要根据各个端口的访问量定义，443端口的访问量最大，属于大范围，优先匹配



3. raw表：确定是否对该数据包进行状态跟踪
	 mangle表：为数据包设置标记
	 nat表：修改数据包中的源、目标IP地址或端口
	 filter表：确定是否放行该数据包（过滤
四、应用

1.语法构成：
    iptables  [-t 表名]  选项  [链名]  [条件]  [-j 控制类型]
    iptables -t filter -A INPUT -p tcp --dport 80 -j DROP
几个注意事项
不指定表名时，默认指filter表
不指定链名时，默认指表内的所有链
除非设置链的默认策略，否则必须指定匹配条件
选项、链名、控制类型使用大写字母，其余均为小写
2. 数据包的常见控制类型
	ACCEPT：允许通过
	DROP：直接丢弃，不给出任何回应
	REJECT：拒绝通过，必要时会给出提示
	LOG：记录日志信息，然后传给下一条规则继续匹配
	SNAT：修改数据包源地址
	DNAT：修改数据包目的地址
	REDIRECT：重定向（先经过这条链，然后再跳转到下一条链，不会匹配即停止）
3. 保存和恢复 iptables 规则
	防火墙规则只在计算机处于开启状态时才有效。如果系统被重新引导，这些规则就会自动被清除并重设。要保存规则以便今，请使用以下命令：后载入
	sbin/service iptables save
	保存在 /etc/sysconfig/iptables 文件中的规则会在服务启动或重新启动时（包括机器被重新引导时）被应用。
4. 添加新的规则
-A：在链的末尾追加一条规则
-I：在链的开头（或指定序号）插入一条规则
#iptables -t filter -A INPUT -p tcp -j ACCEPT
#iptables -I  INPUT -p udp -j ACCEPT
#iptables -I  INPUT  2 -p icmp -j ACCEPT
    5. 查看规则列表
-L：列出所有的规则条目
-n：以数字形式显示地址、端口等信息
-v：以更详细的方式显示规则信息
--line-numbers：查看规则时，显示规则的序
6. 删除、清空规则
-D：删除链内指定序号（或内容）的一条规则
-F：清空所有的规则
#iptables -D INPUT 3
    7. 设置默认策略
-P：为指定的链设置默认规则
# iptables -t filter -P FORWARD DROP
# iptables -P OUTPUT ACCEPT

放行443、22端口，丢弃其他端口数据包的配置方法
[root@www1 ~]# iptables -t filter -A INPUT -p tcp --dport 443 -j ACCEPT
[root@www1 ~]# iptables -t filter -A INPUT -p tcp --dport 22 -j ACCEPT
[root@www1 ~]# iptables -P INPUT drop
[root@www1 ~]# iptables -L
Chain INPUT (policy DROP)
target     prot opt source               destination         
ACCEPT     tcp  --  anywhere             anywhere            tcp dpt:https 
ACCEPT     tcp  --  anywhere             anywhere            tcp dpt:ssh

五、条件匹配
通用匹配
可直接使用，不依赖于其他条件或扩展
包括网络协议、IP地址、网络接口等条件

隐含匹配
要求以特定的协议匹配作为前提
包括端口、TCP标记、ICMP类型等条件

显式匹配
要求以“-m 扩展模块”的形式明确指出类型
包括多端口、MAC地址、IP范围、数据包状态等条常见的通用匹配条件
协议匹配：-p 协议名
地址匹配：-s 源地址、-d 目的地址
接口匹配：-i 入站网卡、-o 出站网卡

# iptables -A FORWARD -s 192.168.1.11 -j REJECT
# iptables -I INPUT -s 10.20.30.0/24 -j DROP 
# iptables -I INPUT -p icmp -j DROP
# iptables -A FORWARD -p ! icmp -j ACCEPT 
# iptables -A INPUT -i eth1 -s 192.168.0.0/16 -j DROP 
# iptables -A INPUT -i eth1 -s 10.0.0.0/8 -j DROP
# iptables -A INPUT -i eth1 -s 172.16.0.0/12 -j DROP

常用的隐含匹配条件
端口匹配：--sport 源端口、--dport 目的端口
ICMP类型匹配：--icmp-type ICMP类型

# iptables -A FORWARD -s 192.168.4.0/24 -p udp --dport 53 -j ACCEPT
# iptables -A INPUT -p tcp --dport 20:21 -j ACCEPT
# iptables -A INPUT -p icmp --icmp-type 8 -j DROP      不让其他主机ping本机
# iptables -A INPUT -p icmp --icmp-type 0 -j ACCEPT    本机可以ping其他主机
# iptables -A INPUT -p icmp --icmp-type 3 -j ACCEPT    本机ping未知主机可以收到回复
# iptables -A INPUT -p icmp -j DROP

常用的显式匹配条件
多端口匹配：-m multiport  --sport 源端口列表
                        -m multiport  --dport 目的端口列表
IP范围匹配：-m iprange --src-range IP范围
MAC地址匹配：-m mac –mac1-source MAC地址
状态匹配：-m state --state 连接状态

# iptables -A INPUT -p tcp -m multiport --dport 25,80,110,143 -j ACCEPT
# iptables -A FORWARD -p tcp -m iprange --src-range 192.168.4.21-192.168.4.28 -j ACCEPT
# iptables -A INPUT -m mac --mac-source 00:0c:29:c0:55:3f -j DROP
# iptables -P INPUT DROP
# iptables -I INPUT -p tcp -m multiport --dport 80:82,85 -j  ACCEPT
# iptables -I INPUT -p tcp -m state --state NEW,ESTABLISHED,RELATED -j ACCEPT

六、SNAT策略和DNAT策略
1.SNAT策略
（1）目的：内网用户可以访问外网




实现方法：
三台主机：
内网用户IP：192.168.19.62
网关服务器IP：eth0:192.168.19.63
              eth1：192.168.20.63
外网服务器IP：192.168.20.64

内网主机：
    网关指向网关服务器eth0
[root@www1 ~]# route add default gw 192.168.19.63

网关服务器：
    开启路由转发：
[root@www2 ~]# vim /etc/sysctl.conf 
[root@www2 ~]# sysctl –p
    编写防火墙规则：
 [root@www2 ~]# service iptables start
 [root@www2 ~]# iptables –F
[root@www2 ~]# chkconfig iptables on
[root@www2 ~]# iptables -t nat -A POSTROUTING -s 192.168.19.0/24 -o eth1 -j SNAT --to-source 192.168.20.63
[root@www2 ~]# service iptables save
（2）如果外网IP一直在变，需要用到地址伪装
MASQUERADE —— 地址伪装
适用于外网IP地址非固定的情况
网关服务器：iptables -t nat -A POSTROUTING -s 192.168.19.0/24 -o eth1 -j MASQUERADE

2.DNAT策略（外网用户可以访问公司内网服务器）
DNAT策略的典型应用环境
在Internet中发布位于企业局域网内的服务器
DNAT策略的原理
	目标地址转换，Destination Network Address Translation
修改数据包的目标地址

方法：
(1)	准备内网用户IP：192.168.19.62
网关服务器IP：eth0:192.168.19.63
              eth1：192.168.20.63
外网服务器IP：192.168.20.64
      （2） 内网主机：
       网关指向网关服务器eth0
[root@www1 ~]# route add default gw 192.168.19.63
[root@www1 ~]# service httpd start
[root@www1 ~]# echo 123 > /var/www/html/index.html

网关服务器：
       开启路由转发：
[root@www2 ~]# vim /etc/sysctl.conf 
[root@www2 ~]# sysctl –p
       编写防火墙规则：
 [root@www2 ~]# service iptables start
 [root@www2 ~]# iptables –F
[root@www2 ~]# chkconfig iptables on
 [root@www2 ~]# service iptables save


[root@www2 ~]# iptables -t nat -A PREROUTING -d 192.168.20.63 -i eth1 -p tcp --dport 80 -j DNAT --to-destination 192.168.19.62

3.全映射（用户无论访问外网ip哪个端口，都把目标地址映射到内网的那台主机）
方法：在DNAT实验的基础上，清除防火墙规则，然后重新编写规则
[root@www2 ~]# iptables -t nat –F
[root@www2 ~]# iptables -t nat -A PREROUTING -d 192.168.20.63 -i eth1 -p tcp --dport 80 -j DNAT --to-destination 192.168.19.62
[root@www2 ~]# service iptables save

测试：外网主机192.168.20.64测试
      ssh root@192.168.20.63导出（备份）规则
4.简单的路由器配置
 （1）准备两台主机
      路由器：eth0:192.168.19.62
              eth1：dhcp 自动获取   nat模式（连接外网）
      客户端：192.168.19.63  
 （2）配置路由端：
      配置eth1为dhcp获取，nat模式（保证可以上外网）
      开启路由转发
      vim /etc/sysctl.conf
      sysctl –p
      配置防火墙规则：
       [root@www1 ~]# iptables -t nat -A POSTROUTING -s 192.168.19.0/24 -o eth1 -j MASQUERADE
       [root@www1 ~]# service iptables save
（3）客户端，设置网关
     网关指向路由端
5.iptables-save工具
可结合重定向输出保存到指定文件
  iptables-save > 1.iptables
  
导入（还原）规则
iptables-restore工具
可结合重定向输入指定规则来源
  iptbles-restore < 1.iptables

————SELINUX


     虚拟化
vcent（vmware提出的一整套虚拟化解决方案）
   EXSI是vcent当中的一个组件




























-----Python                                                                       
-2017-10.9 
Python编程基础


Python简介


1. 1991年，第一个Python编译器诞生。它是用C语言实现的，并能够调用C语言的库文件。Python的作者，Guido von Rossum，荷兰人。





Python支持解释运行，并能调用C库进行拓展。Python有强大的标准库。由于标准库的体系已经稳定，所以Python的生态系统开始拓展到第三方包。这些包，如Django、web.py、wxpython、numpy、matplotlib、PIL等。
Python崇尚优美、清晰、简单，是一个优秀并广泛使用的语言。


Python的意思是蟒蛇，源于作者喜欢的一部电视剧。
Python的解释器如今有多个语言实现，我们常用的是CPython（官方版本的C语言实现），其他还有Jython（可以运行在Java平台）、IronPython（可以运行在.NET和Mono平台）、PyPy（Python实现的，支持JIT即时编译）
Python目前有两个版本，Python2和Python3，最新版分别为2.7和3.6，现阶段大部分公司用的是Python2。
Life is shot, you need Python. 人生苦短，我用Python。





Python特点

优点

    简单————Python是一种代表简单主义思想的语言。

易学————Python极其容易上手。

免费、开源————Python是自由/开放源码软件之一。

跨平台/可移植性————由于它的开源本质，Python已经被移植在许多平台上。

面向对象————Python既支持面向过程的编程也支持面向对象的编程。

    可扩展性————可以使用其它代码，进行重用，然后在你的Python程序中使用它们。

    丰富的库————Python标准库众多。


缺点

运行速度，有速度要求的话，用C++改写关键部分。

版本发展，国内处于发展阶段，资料相对较少，架构选择太多。


3.Python的应用

Web应用开发

Python经常用于Web开发。比如，通过mod_wsgi模块，Apache可以运行用Python编写的Web程序。Python定义了WSGI标准应用接口来协调Http服务器与基于Python的Web程序之间的通信。一些Web框架，如Django,TurboGears,web2py,Zope等，可以让程序员轻松地开发和管理复杂的Web程序。



服务器应用软件

Python对于各种网络协议的支持很完善，因此经常被用于编写服务器软件、网络爬虫。第三方库Twisted支持服务器)，并且提供了多种工具，被广泛用于编写高性能的服务器软件。

科学计算

NumPy,SciPy,Matplotlib可以让Python程序员编写科学计算程序。

操作系统管理、服务器运维的自动化脚本

Python是标准的系统组件。Python编写的系统管理脚本在可读性、性能、代码重用度、扩展性几方面都优于普通的shell脚本。

桌面软件

PyQt、PySide、wxPython、PyGTK是Python快速开发桌面应用程序的利器。


游戏

很多游戏使用C++编写图形显示等高性能模块，而使用Python或者Lua编写游戏的逻辑、服务器。相较于Python，Lua的功能更简单、体积更小；而Python则支持更多的特性和数据类型。



网易，腾讯，搜狐，金山，豆瓣；Google、Yahoo!、NASA、YouTube都在使用Python。





二.  Python 安装

Linux系统自带python，注意版本问题。

开发工具：vim   shell     IDE  pycharm     
 

Python安装


安装python3.6可能使用的依赖

#yum -y install openssl-devel bzip2-devel expat-devel gdbm-devel reaqlite-develdline-devel sqlite-devel

# tar -xzvf Python-3.6.1.tgz 
# cd  Python-3.6.1/

把Python3.6安装到 /usr/local 目录
# ./configure  --prefix=/usr/local/
# make
# make altinstall

python3.6程序的执行文件：/usr/local/bin/python3.6
python3.6应用程序目录：/usr/local/lib/python3.6
pip3的执行文件：/usr/local/bin/pip3.6
pyenv3的执行文件：/usr/local/bin/pyenv-3.6

--------------------------------------------------------------

更改/usr/bin/python链接
# cd/usr/bin
# mv  python python.backup
# ln -s /usr/local/bin/python3.6 /usr/bin/python
# ln -s /usr/local/bin/python3.6 /usr/bin/python3

#rm -rf /usr/bin/python2 
#ln -s /usr/bin/python2.6 /usr/bin/python2    *****

更改yum脚本的python依赖
# cd /usr/bin
# ls yum*
yum yum-config-manager yum-debug-restore yum-groups-manager
yum-builddep yum-debug-dump yumdownloader
更改以上文件头为
#!/usr/bin/python 改为 #!/usr/bin/python2






-------------------------------------------------------------
常用的科学计算、数据挖掘机器学习等python第三方库主要有：Numpy、Scipy、Matplotlib、Pandas、StatsModels、Scikit-Learn、Keras、Gensim

pip install 库名
三.  Python编程基础

1.第一个python程序

Hello world！

程序运行：命令行  
程序脚本  vim ex1.py 
          #!/usr/bin/python
         权限运行 ./ex1.py

注释
 单行注释
  # 我是注释
 
 多行注释
  ‘’’ 
我是注释
  ‘’’
  “””
我是注释
  “””

  中文支持
   #coding=utf-8

  标准写法：# -*- coding:utf-8 -*-

变量
    num1 = 10

num2 = 20  

result = num1 + num2


变量的类型：
  
1.Numbers（数字）2.String（字符串）3.List（列表）4.Tuple（元组）5.Sets（集合）6.Dictionary（字典）

Number可以具体分为 int、float、bool、complex（复数）四种



布尔类型


在python2中当时是没有布尔类型的 使用 0 或者1表示

在python3中新增了True和False的关键字，但是依然使用数字存储

布尔类型只有2个值：True和False

True：真值，表示对的，真，是的

False：假值，表示错的，假，不是


变量的类型确定

在python中，只要定义了一个变量，而且它有数据，那么它的类型就已经确定了，不需要咱们开发者主动的去说明它的类型，系统会自动辨别
可以使用type(变量的名字)，来查看变量的类型


4.标示符和关键字


标示符由字母、下划线和数字组成，且数字不能开头

命名规则

驼峰式命名规则

单驼峰式命名法： 第一个单词以小写字母开始；第二个单词的首字母大写，例如：myName、aDog

双驼峰式命名法： 每一个单字的首字母都采用大写字母，例如：FirstName、LastName

在程序员中还有一种命名法比较流行，就是用下划线“_”来连接所有的单词，比如send_buf




关键字

python一些具有特殊功能的标示符，这就是所谓的关键字

关键字，是python已经使用的了，所以不允许开发者自己定义和关键字相同的名字的标示符

    查看关键字:

          and     as      assert     break     class      continue    def     del
          elif    else    except     exec      finally    for         from    global
          if      in      import     is        lambda     not         or      pass
          print   raise   return     try       while      with        yield

可以通过以下命令进行查看当前系统中python的关键字

>>> import keyword
>>> keyword.kwlist



5 输出

python中变量的输出

print('hello world')

格式化输出
    
name = "lamp"
age = 11
  
print("我的姓名是%s,年龄是%d"%(name,age))

换行输出

print("我的姓名是%s\n年龄是%d"%(name,age))
                     \t 制表符 4个空格	








输入

在Python中，获取键盘输入的数据的方法是采用 raw_input 函数。

 password = raw_input("请输入密码:")
 print '您刚刚输入的密码是:', password



    raw_input()的小括号中放入的是，提示信息，用来在获取数据之前给用户的一个简单提示
    raw_input()在从键盘获取了数据以后，会存放到等号左边的变量中
    raw_input()会把用户输入的任何值都作为字符串来对待

input()
input()函数与raw_input()类似，但其接受的输入必须是表达式。

>>> a = input() 
123
>>> a
123
>>> type(a)
<type 'int'>
>>> a = input()
abc
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<string>", line 1, in <module>
NameError: name 'abc' is not defined
>>> a = input()
"abc"
>>> a
'abc'
>>> type(a)
<type 'str'>
>>> a = input()
1+3
>>> a
‘1+3’
>>> a = input()
"abc"+"def"
>>> a
“abc”+“def”

python3版本中

没有raw_input()函数，只有input()


运算符

算术运算符



赋值运算符



复合赋值运算符




数据类型转换

函数	          说明
int(x)	         将x转换为一个整数
float(x )	         将x转换到一个浮点数


a = '100'     # 此时a的类型是一个字符串，里面存放了100这3个字符
b = int(a)    # 此时b的类型是整型，里面存放的是数字100



8. if判断语句 (python2)   python3 print加括号！！！

    if 要判断的条件:
        条件成立时，要做的事情

    age = 20

    print "------if判断开始------"

    if age>=18:
        print "我已经成年了"

print "------if判断结束------"


9. 比较/关系运算符




逻辑运算符











2017-10-10
Python编程基础
一．判断语句和循环语句



1.  if-else


if-else的使用格式

    if 条件:
        满足条件时要做的事情1
        满足条件时要做的事情2
      
        ...(省略)...
    else:
        不满足条件时要做的事情1
        不满足条件时要做的事情2
     
        ...(省略)...


实例if1.py

    chePiao = 1 
    if chePiao == 1:
        print("有车票，可以上车")
        print("终于可以出发了：）")
    else:
        print("没有票，不能上车")
        print("：（")



2.  elif

elif的功能

elif的使用格式如下:


    if xxx1:
        事情1
    elif xxx2:
        事情2
    elif xxx3:
        事情3

实例if2.py
score = 85

if score>=90 and score<=100:
    print('本次考试，等级为A')
elif score>=80 and score<90:
    print('本次考试，等级为B')
elif score>=70 and score<80:
    print('本次考试，等级为C')
elif score>=60 and score<70:
    print('本次考试，等级为D')
elif score>=0 and score<60:
    print('本次考试，等级为E')



可以和else一起使用

   if 性别为男性:
       输出男性的特征
       ...
   elif 性别为女性:
       输出女性的特征
       ...
   else:
       第三种性别的特征
       ...

elif必须和if一起使用，否则出错


3.  if嵌套

if嵌套的格式

    if 条件1:

        满足条件1 做的事情1
        满足条件1 做的事情2
        ...(省略)...

        if 条件2:
            满足条件2 做的事情1
            满足条件2 做的事情2
            ...(省略)...


 实例if3.py：
chePiao = 1    
daoLenght = 9     

    if chePiao == 1:
        print("有车票，可以上车")
        if daoLenght < 10:
            print("通过安检")
            print("终于可以出发了：）")
        else:
            print("没有通过安检")
            print("刀子的长度超过规定，等待警察")
    else:
        print("没有票，不能上车")
        

结果1：chePiao = 1;daoLenght = 9

    有车票，可以上车
    通过安检
终于可以出发了：）

结果2：chePiao = 1;daoLenght = 20

    有车票，可以上车
    没有通过安检
刀子的长度超过规定，等待警察

结果3：chePiao = 0;daoLenght = 9

    没有票，不能上车

结果4：chePiao = 0;daoLenght = 20

    没有票，不能上车
    



4.  while循环

while循环的格式

    while 条件:
        条件满足时，做的事情1
        条件满足时，做的事情2
        条件满足时，做的事情3
        ...(省略)...

实例while1.py：
Pri
    i = 0
    while i<5:
        print("当前是第%d次执行循环"%(i+1))
        print("i=%d"%i)
        i+=1


实例while2.py

计算1~100的累积和（包含1和100）


#encoding=utf-8

i = 1
sum = 0
while i<=100:
    sum = sum + i
    i += 1

print("1~100的累积和为:%d"%sum)  （注意缩进）




5.  for循环

    for 临时变量 in 列表或者字符串等:
        循环满足条件时执行的代码
    else:
        循环不满足条件时执行的代码




实例for1.py

    name = 'lampBrother'

    for x in name:
        print(x)

-------------------

    name = ''

    for x in name:
        print(x)
    else:
        print("没有数据")





6.  break和continue

(1) break.py
<1> for循环

    普通的循环示例如下：


      name = 'lampBrother'

      for x in name:
          print('----')
          print(x)

    

    带有break的循环示例如下:


      name = 'lampBrother'

      for x in name:
          print('----')
          if x == 'm': 
              break
          print(x)



<2> while循环



    普通的循环示例如下：


      i = 0

      while i<10:
          i = i+1
          print('----')
          print(i)

    运行结果:

    带有break的循环示例如下:


      i = 0

      while i<10:
          i = i+1
          print('----')
          if i==5:
              break
          print(i)

小总结:

    break的作用：用来结束整个循环

(2) continue.py

<1> for循环

    带有continue的循环示例如下:


      name = 'lampBrother'

      for x in name:
          print('----')
          if x == 'm': 
              continue
          print(x)

    

<2> while循环

    带有continue的循环示例如下:


      i = 0

      while i<10:
          i = i+1
          print('----')
          if i==5:
              continue
          print(i)

   

    小总结:
        continue的作用：用来结束本次循环，紧接着执行下一次的循环






二. 字符串   列表   元组   字典

1. 字符串

python中字符串的格式
如下定义的变量a，存储的是数字类型的值

    a = 100

如下定义的变量b，存储的是字符串类型的值

    b = "hello lampbrother"
    或者
    b = 'hello lampbrother'


双引号或者单引号中的数据，就是字符串

字符串输出

实例str1.py
    name = 'lamp'
    position = 'gongchengshi'
    address = 'xdldalou'

    print('--------------------------------------------------')
    print("姓名：%s"%name)
    print("职位：%s"%position)
    print("公司地址：%s"%address)
    print('--------------------------------------------------')


字符串输入

之前在学习input的时候，通过它能够完成从键盘获取数据，然后保存到指定的变量中；

注意：input获取的数据，vimage方式进行保存，即使输入的是数字，那么也是以字符串方式保存

实例str2.py：（注意版本）

    userName = input('请输入用户名:')
    print("用户名为：%s"%userName)

    password = input('请输入密码:')
    print("密码为：%s"%password)


下标和切片

所谓“下标”，就是编号

字符串中"下标"的使用

列表与元组支持下标索引，字符串实际上就是字符的数组，所以也支持下标索引。

如果有字符串:name = 'abcdef'，在内存中的实际存储如下:

  >>> name = 'abcdef'

  >>> print(name[0])
  >>> print(name[1])
  >>> print(name[2])

切片是指对操作的对象截取其中一部分的操作。字符串、列表、元组都支持切片操作。

切片的语法：[起始:结束:步长]

注意：选取的区间属于左闭右开型，即从"起始"位开始，到"结束"位的前一位结束（不包含结束位本身)。


如果取出一部分，则可以在中括号[]中，使用:

     name = 'abcdef'

     print(name[0:3]) # 取 下标0~2 的字符

     name = 'abc'

     print(name[0:5]) # 取 下标为0~4 的字符

     name = 'abcde'

     print(name[3:5]) # 取 下标为3、4 的字符

     name = 'de'

     print(name[2:]) # 取 下标为2开始到最后的字符

name = 'cdef'


 >>> a = "abcdef"
 >>> a[:3]
 'abc'
 >>> a[::2]
 'ace'
 >>> a[5:1:2] 
 ''
 >>> a[1:5:2]
 'bd'
 >>> a[::-2]
 'fdb' 
 >>> a[5:1:-2]
 'fd'


实例

如有字符串mystr = 'hello world lamp and lampbrother'，以下是常见的操作
<1>find

检测 str 是否包含在 mystr中，如果是返回开始的索引值，否则返回-1
str=’hello’


>>> mystr = 'hello world lamp and lampbrother'
>>> str=’hello’
>>> mystr.find(str)


<2>index

跟find()方法一样，只不过如果str不在 mystr中会报一个异常.

mystr.index(str) 

<3>count

返回 str在start和end之间 在 mystr里面出现的次数

mystr.count(str)

<4>replace

把 mystr 中的 str1 替换成 str2,如果 count 指定，则替换不超过 count 次.
str=’aaa’

mystr.replace(str1, str2)

 

<5>capitalize

把字符串的第一个字符大写

mystr.capitalize()


<6>title

把字符串的每个单词首字母大写
mystr.title()

<7>startswith

检查字符串是否是以 he 开头, 是则返回 True，否则返回 False

mystr.startswith(“he”)

<8>endswith

检查字符串是否以he结束，如果是返回True,否则返回 False.

mystr.endswith(“he”)






2.  列表list


思考：如果需要定义30个变量，每个变量存放一个人的名字？


列表的格式

变量A的类型为列表

    namesList = ['xiaoZhang',’xiaoLi','xiaoWang']



打印列表

实例list.py:

    namesList = ['xiaoZhang','xiaoLi,'xiaoWang']
    print(namesList[0])
    print(namesList[1])
    print(namesList[2])



列表的循环遍历

使用for循环

为了更有效率的输出列表的每个数据，可以使用循环来完成

实例list.py:

List = ['xiaoZhang','xiaoLi,'xiaoWang']
for name in namesList:
        print(name)


使用while循环


实例list.py:

    namesList = ['xiaoZhang','xiaoLi,'xiaoWang']

    length = len(namesList)

    i = 0

    while i<length:
        print(namesList[i])
        i+=1



列表的相关操作

<1>添加元素("增"append, extend, insert)

append

通过append可以向列表添加元素

实例list1.py:

    #定义变量A，默认有3个元素
    A = ['xiaoWang','xiaoZhang','xiaoHua']

    print("-----添加之前，列表A的数据-----")
    for tempName in A:
        print(tempName)

    #提示、并添加元素
    temp = input('请输入要添加的学生姓名:')
    A.append(temp)

    print("-----添加之后，列表A的数据-----")
    for tempName in A:
        print(tempName)


extend

通过extend可以将另一个集合中的元素逐一添加到列表中

>>> a = [1, 2]
>>> b = [3, 4]
>>> a.append(b)
>>> a
[1, 2, [3, 4]]
>>> a.extend(b)
>>> a
[1, 2, [3, 4], 3, 4]


insert

insert(index, object) 在指定位置index前插入元素object

>>> a = [0, 1, 2]
>>> a.insert(1, 3)
>>> a
[0, 3, 1, 2]

<2>修改元素("改")

修改元素的时候，要通过下标来确定要修改的是哪个元素，然后才能进行修改

实例list2.py:

    #定义变量A，默认有3个元素
    A = ['xiaoWang','xiaoZhang','xiaoHua']

    print("-----修改之前，列表A的数据-----")
    for tempName in A:
        print(tempName)

    #修改元素
    A[1] = 'xiaoLu'

    print("-----修改之后，列表A的数据-----")
    for tempName in A:
        print(tempName)




<3>查找元素("查"in, not in, index, count)

所谓的查找，就是看看指定的元素是否存在
in, not in

python中查找的常用方法为：

    in（存在）,如果存在那么结果为true，否则为false
    not in（不存在），如果不存在那么结果为true，否则false

实例list3.py

    #待查找的列表
    nameList = ['xiaoWang','xiaoZhang','xiaoHua']

    #获取用户要查找的名字
    findName = input('请输入要查找的姓名:')

    #查找是否存在
    if findName in nameList:
        print('在字典中找到了相同的名字')
    else:
        print('没有找到')




<4>删除元素("删"del, pop, remove)


列表元素的常用删除方法有：

    del：根据下标进行删除
    pop：删除最后一个元素
    remove：根据元素的值进行删除

实例list4.py:(del)

    movieName = ['战狼1','战狼2','速8','孙悟空','星球大战','异星觉醒']

    print('------删除之前------')
    for tempName in movieName:
        print(tempName)

    del movieName[2]

    print('------删除之后------')
    for tempName in movieName:
        print(tempName)

实例(pop)

movieName = ['战狼1','战狼2','速8','孙悟空','星球大战','异星觉醒']

    print('------删除之前------')
    for tempName in movieName:
        print(tempName)

    movieName.pop()

    print('------删除之后------')
    for tempName in movieName:
        print(tempName)

实例:(remove)

    movieName = ['战狼1','战狼2','速8','孙悟空','星球大战','异星觉醒']

    print('------删除之前------')
    for tempName in movieName:
        print(tempName)

    movieName.remove('星球大战')

    print('------删除之后------')
    for tempName in movieName:
        print(tempName)


<5>排序(sort, reverse)

sort方法是将list按特定顺序重新排列，默认为由小到大，参数reverse=True可改为倒序，由大到小。

reverse方法是将list逆置。

>>> a = [1, 4, 2, 3]
>>> a
[1, 4, 2, 3]
>>> a.reverse()
>>> a
[3, 2, 4, 1]
>>> a.sort()
>>> a
[1, 2, 3, 4]
>>> a.sort(reverse=True)
>>> a
[4, 3, 2, 1]







3. 元组 tuple


Python的元组与列表类似，不同之处在于元组的元素不能修改。元组使用小括号，列表使用方括号。

>>> Tuple = ('xiaoming',177,79)
>>> Tuple
('xiaoming',177,79)

<1>访问元组
Tuple[1]

<2>修改元组 （不允许）

注意： python中不允许修改元组的数据，包括不能删除其中的元素。




4.  字典dict


字典定义

变量info为字典类型：


    info = {'name':'超哥', 'id':100, 'sex':'f', 'address':'回龙观'}

注意：

    字典和列表一样，也能够存储多个数据
    列表中找某个元素时，是根据下标进行的
    字典中找某个元素时，是根据'名字'（就是冒号:前面的那个值，例如上面代码中的'name'、'id'、'sex'）
    字典的每个元素由2部分组成，键:值。例如 'name':'超哥' ,'name'为键，'超哥'为值



根据键访问值
info.py

    info = {'name':'超哥', 'id':100, 'sex':'f', 'address':'回龙观'}

    print(info['name'])
    print(info['address'])

结果:

    超哥
    回龙观

若访问不存在的键，则会报错：

>>> info['age']
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
KeyError: 'age'

在我们不确定字典中是否存在某个键而又想获取其值时，可以使用get方法，还可以设置默认值：

>>> age = info.get('age')
>>> age #'age'键不存在，所以age为None
>>> type(age)
<type 'NoneType'>
>>> age = info.get('age', 30) # 若info中不存在'age'这个键，就返回默认值30
>>> age
30

修改元素

字典的每个元素中的数据是可以修改的，只要通过key找到，即可修改

实例info1.py:

    info = {'name':'超哥', 'id':100, 'sex':'f', 'address':'回龙观'}

    newId = input('请输入新的学号')

    info['id'] = int(newId)

    print('修改之后的id为%d:'%info['id'])



添加元素

访问不存在的元素

    info = {'name':'超哥', 'sex':'f', 'address':'回龙观'}

    print('id为:%d'%info['id'])



如果在使用 变量名['键'] = 数据 时，这个“键”在字典中，不存在，那么就会新增这个元素

实例info2.py:添加新的元素

    info = {'name':'超哥', 'sex':'f', 'address':'回龙观'}

# print('id为:%d'%info['id'])

    newId = input('请输入新的学号:')

    info['id'] = int(newId)

    print('添加之后的id为:%d'%info['id'])


删除元素

对字典进行删除操作，有以下几种：

    del
    clear()

实例del.py:del删除指定的元素


    info = {'name':'超哥', 'sex':'f', 'address':'回龙观'}

    print('删除前,%s'%info['name'])

    del info['name']

    print('删除后,%s'%info['name'])


实例del1.py:del删除整个字典  报错！！！


    info = {'name':'monitor', 'sex':'f', 'address':'China'}

    print('删除前,%s'%info)

    del info

    print('删除后,%s'%info)

实例del2.py:clear清空整个字典


    info = {'name':'monitor', 'sex':'f', 'address':'China'}

    print('清空前,%s'%info)

    info.clear()

    print('清空后,%s'%info)


字典常用操作

info = {'name':'超哥', 'id':100, 'sex':'f', 'address':'回龙观'}

<1>len()

测量字典中，键值对的个数

>>>len(info)

<2>keys

返回一个包含字典所有KEY的列表

>>> info.keys()

<3>values

返回一个包含字典所有value的列表

>>> info.values()

<4>items

返回一个包含所有（键，值）元祖的列表

>>> info.items()
















```
